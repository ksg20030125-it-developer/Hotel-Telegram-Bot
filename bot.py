import os
import httpx
import calendar
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
from database import DatabaseManager
from languages import get_text, get_user_language, set_user_language, get_available_languages, TRANSLATIONS, get_work_role_display
from event_logger import get_event_logger
from shift_operations import (
    get_current_shift_type,
    get_on_shift_employees,
    is_employee_on_shift,
    get_all_department_employees,
    get_shift_status_summary
)


def create_calendar(year: int, month: int, lang: str = 'en', callback_prefix: str = 'task_date') -> InlineKeyboardMarkup:
    """Create an inline calendar keyboard for date selection
    
    Args:
        year: Year to display
        month: Month to display
        lang: Language code
        callback_prefix: Prefix for date callback (e.g., 'task_date', 'event_date')
    """
    keyboard = []
    
    # Month/Year header with navigation
    month_names = {
        'en': ['', 'January', 'February', 'March', 'April', 'May', 'June', 
               'July', 'August', 'September', 'October', 'November', 'December'],
        'sr': ['', 'Januar', 'Februar', 'Mart', 'April', 'Maj', 'Jun',
               'Jul', 'Avgust', 'Septembar', 'Oktobar', 'Novembar', 'Decembar']
    }
    month_name = month_names.get(lang, month_names['en'])[month]
    
    # Use different navigation callbacks based on prefix
    nav_prefix = 'event_cal' if callback_prefix == 'event_date' else 'cal'
    
    keyboard.append([
        InlineKeyboardButton("◀️", callback_data=f"{nav_prefix}_prev_{year}_{month}"),
        InlineKeyboardButton(f"{month_name} {year}", callback_data="cal_ignore"),
        InlineKeyboardButton("▶️", callback_data=f"{nav_prefix}_next_{year}_{month}")
    ])
    
    # Day names header
    day_names = {
        'en': ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'],
        'sr': ['Po', 'Ut', 'Sr', 'Če', 'Pe', 'Su', 'Ne']
    }
    days = day_names.get(lang, day_names['en'])
    keyboard.append([InlineKeyboardButton(day, callback_data="cal_ignore") for day in days])
    
    # Calendar days
    cal = calendar.monthcalendar(year, month)
    today = datetime.now().date()
    
    for week in cal:
        row = []
        for day in week:
            if day == 0:
                row.append(InlineKeyboardButton(" ", callback_data="cal_ignore"))
            else:
                date = datetime(year, month, day).date()
                # Disable past dates
                if date < today:
                    row.append(InlineKeyboardButton(f"·{day}·", callback_data="cal_ignore"))
                elif date == today:
                    row.append(InlineKeyboardButton(f"[{day}]", callback_data=f"{callback_prefix}_{year}-{month:02d}-{day:02d}"))
                else:
                    row.append(InlineKeyboardButton(str(day), callback_data=f"{callback_prefix}_{year}-{month:02d}-{day:02d}"))
        keyboard.append(row)
    
    return keyboard


# Serbian translation dictionary (for display) - DEPRECATED, use languages.py
DEPT_NAMES_SR = {
    "Reception": "Recepcija",
    "Housekeeping": "Domaćinstvo", 
    "Laundry": "Vešeraj",
    "Kitchen": "Kuhinja",
    "Procurement": "Nabavka",
    "Technical": "Tehnička služba",
    "Accounting": "Računovodstvo",
    "Management": "Uprava"
}

DEPT_EMOJIS = {
    "Reception": "🛎️",
    "Housekeeping": "🧹",
    "Laundry": "🧺",
    "Kitchen": "🍳",
    "Procurement": "📦",
    "Technical": "🔧",
    "Accounting": "💰",
    "Management": "👔"
}

# Work role emojis
ROLE_EMOJIS = {
    "Возач": "🚗",
    "Вођа тима": "👨‍💼",
    "Генерални директор": "👔",
    "Домаћица": "🏠",
    "Кувар": "👨‍🍳",
    "Мајстор": "🔧",
    "Менаџер": "📊",
    "Рачуновођа": "💰",
    "Рецепционар": "🛎️",
    "Спремачица": "🧹",
    "Техничар": "🔌",
    "избацивач": "💪",
    # English fallbacks
    "Driver": "🚗",
    "Team Leader": "👨‍💼",
    "General Director": "👔",
    "Housekeeper": "🏠",
    "Cook": "👨‍🍳",
    "Technician": "🔧",
    "Manager": "📊",
    "Accountant": "💰",
    "Receptionist": "🛎️",
    "Cleaner": "🧹",
    "Bouncer": "💪"
}

def get_role_emoji(role_name):
    """Get emoji for work role"""
    if not role_name:
        return "👤"
    return ROLE_EMOJIS.get(role_name, "👤")

def get_dept_display(dept_name, lang='en'):
    """Display department name in user's language"""
    # Map department internal names to translation keys
    dept_key_map = {
        "Reception": "reception",
        "Housekeeping": "housekeeping",
        "Laundry": "laundry",
        "Kitchen": "kitchen",
        "Procurement": "procurement",
        "Technical": "technical",
        "Accounting": "accounting",
        "Management": "management"
    }
    
    key = dept_key_map.get(dept_name)
    if key:
        return get_text(key, lang).replace('🛎️ ', '').replace('🧹 ', '').replace('🧺 ', '').replace('🍳 ', '').replace('📦 ', '').replace('🔧 ', '').replace('💰 ', '').replace('👔 ', '')
    return dept_name

def get_dept_emoji(dept_name):
    """Get department emoji"""
    return DEPT_EMOJIS.get(dept_name, "🏢")

class HotelBot:
    """Hotel Management Telegram Bot"""
    
    def _progress_bar(self, percentage, length=10):
        """Generate a text-based progress bar"""
        filled = int(percentage / 100 * length)
        empty = length - filled
        bar = '█' * filled + '░' * empty
        return f"  [{bar}] {percentage}%"
    
    def __init__(self, token: str, db_manager: DatabaseManager):
        """
        Initialize bot
        
        Args:
            token: Telegram bot token
            db_manager: Database manager
        """
        self.token = token
        self.db = db_manager
        self.user_context = {}
        
        self.application = Application.builder().token(token).build()
        
        from notification_manager import get_notification_manager
        self.notification_manager = None
        
        # Initialize event logger with database connection
        event_logger = get_event_logger(db_manager)
        print("Event logger connected to database")
        
        self._setup_handlers()
    
    def _setup_handlers(self):
        """Setup command handlers"""
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("admin", self.admin_command))
        self.application.add_handler(CommandHandler("rooms", self.rooms_command))
        self.application.add_handler(CommandHandler("reservations", self.reservations_command))
        self.application.add_handler(CommandHandler("shift_status", self.shift_status_command))
        self.application.add_handler(CommandHandler("test_shift_alarm", self.test_shift_alarm_command))
        self.application.add_handler(CallbackQueryHandler(self.button_handler))
        self.application.add_handler(MessageHandler(filters.PHOTO | filters.VIDEO | filters.Document.ALL, self.handle_media))
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))
        self.application.add_error_handler(self.error_handler)
    
    async def error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Handle errors"""
        import logging
        logging.warning(f"Update {update} caused error: {context.error}")
        print(f"⚠️ Error occurred: {context.error}")
        
        # Log error to event logger
        try:
            event_logger = get_event_logger()
            user_id = None
            if update and hasattr(update, 'effective_user') and update.effective_user:
                user_id = update.effective_user.id
            event_logger.log_error(
                error_type=type(context.error).__name__,
                error_message=str(context.error)[:500],
                user_id=user_id,
                context={"update_type": str(type(update).__name__) if update else None}
            )
        except Exception as log_error:
            print(f"Error logging failed: {log_error}")
    
    async def show_employee_profile(self, query, telegram_user_id: int):
        """Helper function to show employee profile"""
        lang = get_user_language(telegram_user_id, self.db)
        employee = self.db.check_employee_exists(telegram_user_id)
        
        if employee:
            employee_id, name, department, work_role, gmail, whatsapp = employee
            dept_display = get_dept_display(department, lang)
            
            gmail_display = gmail if gmail else get_text('not_set', lang)
            whatsapp_display = whatsapp if whatsapp else get_text('not_set', lang)
            work_role_display = work_role if work_role else get_text('not_set', lang)
            
            profile_text = f"""{get_text('my_profile', lang)}

━━━━━━━━━━━━━━━━━━
📋 {get_text('personal_info', lang)}
━━━━━━━━━━━━━━━━━━
• {get_text('employee_id', lang)}: {employee_id}
• {get_text('name', lang)}: {name}
• {get_text('department', lang)}: {dept_display}
• {get_text('work_role', lang)}: {work_role_display}
• {get_text('telegram_id', lang)}: {telegram_user_id}

━━━━━━━━━━━━━━━━━━
📧 {get_text('contact_details', lang)}
━━━━━━━━━━━━━━━━━━
• Gmail: {gmail_display}
• WhatsApp: {whatsapp_display}
━━━━━━━━━━━━━━━━━━"""
            
            keyboard = [
                [InlineKeyboardButton(get_text('edit_name', lang), callback_data="emp_profile_edit_name"),
                 InlineKeyboardButton(get_text('edit_department', lang), callback_data="emp_profile_edit_dept")],
                [InlineKeyboardButton(get_text('edit_work_role', lang), callback_data="emp_profile_edit_role"),
                 InlineKeyboardButton(get_text('edit_contact', lang), callback_data="emp_settings_contact")],
                [InlineKeyboardButton(get_text('back', lang), callback_data="emp_main_menu")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(profile_text, reply_markup=reply_markup)
    
    async def _show_room_detail(self, query, room_id: int, telegram_user_id: int):
        """Helper function to display room detail page (for reception view)"""
        lang = get_user_language(telegram_user_id, self.db)
        room = self.db.get_room_detail(room_id)
        
        if not room:
            await query.edit_message_text(get_text('room_not_found', lang))
            return
        
        room_id_db, id_room, is_check, ac, tv, toilet, remote, total_capacity, current_guests = room
        
        check_status = get_text('occupied_room', lang) if str(is_check) == "1" else get_text('available_room', lang)
        ac_status = get_text('good_condition', lang) if str(ac) == "1" else get_text('bad_condition', lang)
        tv_status = get_text('good_condition', lang) if str(tv) == "1" else get_text('bad_condition', lang)
        toilet_status = get_text('good_condition', lang) if str(toilet) == "1" else get_text('bad_condition', lang)
        remote_status = get_text('good_condition', lang) if str(remote) == "1" else get_text('bad_condition', lang)
        
        employee_info = self.db.get_employee_info(telegram_user_id)
        is_admin_or_reception = False
        if employee_info:
            dept = employee_info['department']
            is_admin_or_reception = (dept == 'Management' or dept == 'Reception')
        
        room_info = f"""🚪 {get_text('room', lang)} {id_room} - {get_text('room_details', lang).replace('🚪 Room {} - Details', 'Details')}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('room_status', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('occupancy', lang)}: {check_status}
{get_text('room_guests', lang)}: {current_guests}/{total_capacity} {get_text('persons', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('equipment', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('air_conditioning', lang)}: {ac_status}
{get_text('tv', lang)}: {tv_status}
{get_text('toilet', lang)}: {toilet_status}
{get_text('remote_control', lang)}: {remote_status}"""
        
        keyboard = []
        
        if is_admin_or_reception:
            keyboard.append([
                InlineKeyboardButton(get_text('check_in_guests', lang), callback_data=f"room_view_checkin_{room_id}"),
                InlineKeyboardButton(get_text('check_out_guests', lang), callback_data=f"room_view_checkout_{room_id}")
            ])
            keyboard.append([
                InlineKeyboardButton(get_text('set_capacity', lang), callback_data=f"room_view_capacity_{room_id}")
            ])
        
        keyboard.append([InlineKeyboardButton(get_text('back_to_rooms', lang), callback_data="dept_2")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(room_info, reply_markup=reply_markup)
    
    async def _show_key_take_list(self, query):
        """Helper function to display key take list"""
        from database import get_active_rooms_for_keys, get_borrowed_room_ids
        rooms = get_active_rooms_for_keys(self.db)
        borrowed_ids = get_borrowed_room_ids(self.db)
        lang = get_user_language(query.from_user.id, self.db)
        
        if not rooms:
            await query.answer(f"❌ {get_text('no_active_rooms', lang)}", show_alert=True)
            return
        
        def get_room_id(room):
            return room['id'] if isinstance(room, dict) else room[0]
        def get_room_name(room):
            return room['name'] if isinstance(room, dict) else room[1]
        
        available_count = len([r for r in rooms if get_room_id(r) not in borrowed_ids])
        borrowed_count = len([r for r in rooms if get_room_id(r) in borrowed_ids])
        
        lang = get_user_language(query.from_user.id, self.db)
        text = f"{get_text('select_room_key', lang)}\n\n"
        text += f"{get_text('available_keys', lang)}: {available_count} | {get_text('borrowed_keys', lang)}: {borrowed_count}"
        
        keyboard = []
        for room in rooms:
            room_id = get_room_id(room)
            name = get_room_name(room)
            
            if room_id in borrowed_ids:
                keyboard.append([InlineKeyboardButton(
                    f"🔒 {name} ({get_text('key_borrowed', lang)})",
                    callback_data=f"key_borrowed_{room_id}"
                )])
            else:
                keyboard.append([InlineKeyboardButton(
                    f"🔑 {name}",
                    callback_data=f"key_select_{room_id}"
                )])
        
        keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="reception_keys")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text, reply_markup=reply_markup)

    async def _show_room_manage(self, query, room_id: int):
        """Helper function to display room management page"""
        from database import get_room_by_id
        
        room = get_room_by_id(self.db, room_id)
        lang = get_user_language(query.from_user.id, self.db)
        
        if not room:
            await query.edit_message_text(f"❌ {get_text('room_not_found', lang)}")
            return
        
        active_icon = "✅" if room['is_active'] == 1 else "❌"
        check_icon = "🔴" if str(room['is_check']) == "1" else "🟢"
        ac_icon = "✅" if str(room['AC']) == "1" else "❌"
        tv_icon = "✅" if str(room['TV']) == "1" else "❌"
        toilet_icon = "✅" if str(room['Toilet']) == "1" else "❌"
        remote_icon = "✅" if str(room['Remote_Control']) == "1" else "❌"
        
        total_capacity = room.get('total_capacity', 2)
        current_guests = room.get('current_guests', 0)
        available = total_capacity - current_guests
        percent = int((current_guests / total_capacity * 100)) if total_capacity > 0 else 0
        
        floor = room['id_room'][:-2] if len(room['id_room']) > 2 else "1"
        
        room_info = f"""🚪 {get_text('room', lang)} {room['id_room']}

📊 {get_text('status', lang).upper()}
{get_text('status_label', lang)}: {active_icon} | {get_text('occupancy_label', lang)}: {check_icon}

{get_text('capacity_label', lang)}
{get_text('capacity_info', lang).format(total_capacity=total_capacity, current_guests=current_guests, available=available)}
{get_text('occupancy_percentage', lang).format(percentage=percent)}

{get_text('equipment_label', lang)}
❄️ {get_text('climate', lang)}: {ac_icon} | 📺 {get_text('tv', lang)}: {tv_icon}
🚽 {get_text('toilet', lang)}: {toilet_icon} | 🎮 {get_text('remote', lang)}: {remote_icon}"""
        
        toggle_text = get_text('deactivate', lang) if room['is_active'] == 1 else get_text('activate', lang)
        
        keyboard = [
            [InlineKeyboardButton(toggle_text, callback_data=f"room_toggle_{room_id}"),
             InlineKeyboardButton(f"🗑️ {get_text('delete', lang)}", callback_data=f"room_delete_{room_id}")],
            [InlineKeyboardButton(f"{get_text('air_conditioning', lang)}", callback_data=f"room_equip_{room_id}_AC"),
             InlineKeyboardButton(f"{get_text('tv', lang)}", callback_data=f"room_equip_{room_id}_TV")],
            [InlineKeyboardButton(f"{get_text('toilet', lang)}", callback_data=f"room_equip_{room_id}_Toilet"),
             InlineKeyboardButton(f"{get_text('remote_control', lang)}", callback_data=f"room_equip_{room_id}_Remote_Control")],
            [InlineKeyboardButton(get_text('back', lang), callback_data=f"room_floor_{floor}")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(room_info, reply_markup=reply_markup)
    
    async def _show_emp_room_detail(self, query, room_id: int):
        """Helper function to display employee room detail page"""
        from database import get_room_by_id
        
        room = get_room_by_id(self.db, room_id)
        lang = get_user_language(query.from_user.id, self.db)
        
        if not room:
            await query.edit_message_text(f"❌ {get_text('room_not_found', lang)}")
            return
        
        active_icon = "✅" if room['is_active'] == 1 else "❌"
        check_icon = "🔴" if str(room['is_check']) == "1" else "🟢"
        ac_icon = "✅" if str(room['AC']) == "1" else "❌"
        tv_icon = "✅" if str(room['TV']) == "1" else "❌"
        toilet_icon = "✅" if str(room['Toilet']) == "1" else "❌"
        remote_icon = "✅" if str(room['Remote_Control']) == "1" else "❌"
        
        total_capacity = room.get('total_capacity', 2)
        current_guests = room.get('current_guests', 0)
        available = total_capacity - current_guests
        percent = int((current_guests / total_capacity * 100)) if total_capacity > 0 else 0
        
        floor = room['id_room'][:-2] if len(room['id_room']) > 2 else "1"
        
        room_info = f"""🚪 {get_text('room', lang)} {room['id_room']}

📊 {get_text('status', lang).upper()}
{get_text('status_label', lang)}: {active_icon} | {get_text('occupancy_label', lang)}: {check_icon}

{get_text('capacity_label', lang)}
{get_text('capacity_info', lang).format(total_capacity=total_capacity, current_guests=current_guests, available=available)}
{get_text('occupancy_percentage', lang).format(percentage=percent)}

{get_text('equipment_label', lang)}
❄️ {get_text('climate', lang)}: {ac_icon} | 📺 {get_text('tv', lang)}: {tv_icon}
🚽 {get_text('toilet', lang)}: {toilet_icon} | 🎮 {get_text('remote', lang)}: {remote_icon}"""
        
        toggle_text = get_text('deactivate', lang) if room['is_active'] == 1 else get_text('activate', lang)
        
        keyboard = [
            [InlineKeyboardButton(toggle_text, callback_data=f"emp_room_toggle_{room_id}")],
            [InlineKeyboardButton(get_text('check_in_guests', lang), callback_data=f"emp_room_checkin_{room_id}"),
             InlineKeyboardButton(get_text('check_out_guests', lang), callback_data=f"emp_room_checkout_{room_id}")],
            [InlineKeyboardButton(get_text('set_capacity', lang), callback_data=f"emp_room_capacity_{room_id}")],
            [InlineKeyboardButton(f"{get_text('air_conditioning', lang)} {ac_icon}", callback_data=f"emp_room_equip_AC_{room_id}"),
             InlineKeyboardButton(f"{get_text('tv', lang)} {tv_icon}", callback_data=f"emp_room_equip_TV_{room_id}")],
            [InlineKeyboardButton(f"{get_text('toilet', lang)} {toilet_icon}", callback_data=f"emp_room_equip_Toilet_{room_id}"),
             InlineKeyboardButton(f"{get_text('remote_control', lang)} {remote_icon}", callback_data=f"emp_room_equip_Remote_Control_{room_id}")],
            [InlineKeyboardButton(get_text('back_to_rooms', lang), callback_data=f"emp_room_floor_{floor}")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(room_info, reply_markup=reply_markup)
    
    async def _show_room_create_floor_select(self, query):
        """Helper function to display floor selection screen for room creation (Step 1)"""
        lang = get_user_language(query.from_user.id, self.db)
        text = f"""➕ {get_text('create_new_room', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('step_select_floor', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('select_floor_create', lang)}"""
        
        keyboard = []
        row = []
        for i in range(1, 11):
            row.append(InlineKeyboardButton(f"🏢 {i}", callback_data=f"room_new_floor_{i}"))
            if len(row) == 5:
                keyboard.append(row)
                row = []
        if row:
            keyboard.append(row)
        
        keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="action_2")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text, reply_markup=reply_markup)
    
    async def _show_room_create_num_select(self, query, floor: str):
        """Helper function to display room number selection screen for room creation (Step 2)"""
        from database import get_rooms_by_floor
        
        # Get existing rooms on this floor
        existing_rooms = get_rooms_by_floor(self.db, floor)
        existing_room_numbers = set()
        for r in existing_rooms:
            room_num = r[1]  # id_room like "101", "102"
            if room_num.startswith(floor):
                room_part = room_num[len(floor):]
                if room_part.isdigit():
                    existing_room_numbers.add(int(room_part))
        
        lang = get_user_language(query.from_user.id, self.db)
        text = f"""➕ {get_text('create_new_room', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('step_select_room_number', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('floor_number', lang)}: {floor}

{get_text('select_room_number', lang)}
{get_text('available_short', lang)} | {get_text('exists_short', lang)}"""
        
        keyboard = []
        row = []
        for i in range(1, 11):
            if i in existing_room_numbers:
                row.append(InlineKeyboardButton(f"❌ {i}", callback_data=f"room_exists_{floor}_{i}"))
            else:
                row.append(InlineKeyboardButton(f"✅ {i}", callback_data=f"room_new_num_{floor}_{i}"))
            if len(row) == 5:
                keyboard.append(row)
                row = []
        if row:
            keyboard.append(row)
        
        text += f"""

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('example_room', lang).format(floor, floor)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━"""
        
        keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="room_create_new")])
        keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="action_2")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text, reply_markup=reply_markup)
    
    async def _show_floor_rooms(self, query, floor: str, back_callback: str = "action_2", room_callback_prefix: str = "room_manage_"):
        """Helper function to display rooms on a floor"""
        from database import get_rooms_by_floor
        
        rooms = get_rooms_by_floor(self.db, floor)
        lang = get_user_language(query.from_user.id, self.db)
        
        text = f"""🏠 {get_text('floor_number', lang)} {floor}

{get_text('room_list', lang)}"""
        keyboard = []
        
        if rooms:
            # Always show 3 rooms per row for consistency
            per_row = 3
            
            row = []
            for room_id, id_room, is_check, ac, tv, toilet, remote, is_active, total_capacity, current_guests in rooms:
                if is_active == 0:
                    status_icon = "⚫"
                elif str(ac) == "1" and str(tv) == "1" and str(toilet) == "1" and str(remote) == "1":
                    status_icon = "🟢"
                else:
                    status_icon = "🔴"
                
                # Check occupancy
                if current_guests > 0:
                    occupancy_icon = "🟢"  # Occupied
                else:
                    occupancy_icon = status_icon  # Show equipment status
                
                row.append(InlineKeyboardButton(
                    f"{occupancy_icon} {id_room}", 
                    callback_data=f"{room_callback_prefix}{room_id}"
                ))
                
                if len(row) == per_row:
                    keyboard.append(row)
                    row = []
            
            if row:
                keyboard.append(row)
        else:
            text += f"\n\n{get_text('no_rooms_on_floor', lang)}"
        
        text += f"\n\n🟢 = Equipment OK | 🔴 = Equipment broken | ⚫ = Inactive"
        
        keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data=back_callback)])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text, reply_markup=reply_markup)
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle start command - Employee authentication/registration"""
        try:
            from database import log_action
            
            telegram_user_id = update.effective_user.id
            username = update.effective_user.username or "Unknown"
            lang = get_user_language(telegram_user_id, self.db)
            
            # Remove Menu button for this user's chat
            try:
                from telegram import MenuButtonCommands
                await self.application.bot.set_chat_menu_button(
                    chat_id=telegram_user_id,
                    menu_button=MenuButtonCommands()
                )
            except Exception:
                pass
            
            print(f"📋 /start command request: User ID {telegram_user_id} (@{username})")
            
            employee = self.db.check_employee_exists(telegram_user_id)
            
            if employee:
                employee_id, name, department, work_role, gmail, whatsapp = employee
                dept_display = get_dept_display(department, lang)
                
                # Log employee login
                try:
                    event_logger = get_event_logger()
                    event_logger.log_employee_login(
                        user_id=telegram_user_id,
                        user_name=name,
                        department=department,
                        employee_id=employee_id
                    )
                except Exception as log_error:
                    print(f"Event logging error: {log_error}")
                
                if department == "Management":
                    pending_reports = self.db.get_pending_admin_reports()
                    languages = get_available_languages()
                    current_lang_name = languages.get(lang, '🇷🇸 Srpski')
                    
                    info_lines = [
                        f"• {get_text('name', lang)}: {name}",
                        f"• {get_text('employee_id', lang)}: {employee_id}",
                        f"• {get_text('department', lang)}: {dept_display} (Admin)",
                        f"• {get_text('telegram_id', lang)}: {telegram_user_id}"
                    ]
                    
                    if work_role:
                        info_lines.append(f"• {get_text('work_role', lang)}: {work_role}")
                    
                    gmail_display = gmail if gmail else get_text('not_set', lang)
                    info_lines.append(f"• 📧 Gmail: {gmail_display}")
                    
                    whatsapp_display = whatsapp if whatsapp else get_text('not_set', lang)
                    info_lines.append(f"• 📱 WhatsApp: {whatsapp_display}")
                    info_lines.append(f"• 🌐 {get_text('language', lang)}: {current_lang_name}")
                    
                    welcome_text = f"""{get_text('welcome_admin', lang)}

{get_text('your_info', lang)}
{chr(10).join(info_lines)}

{get_text('full_access', lang)}"""
                    
                    pending_complaints = self.db.get_unconfirmed_complaints()
                    from database import get_laundry_stats
                    laundry_stats = get_laundry_stats(self.db)
                    laundry_pending = laundry_stats.get('Pending', 0) + laundry_stats.get('Accepted', 0)
                    
                    if pending_reports:
                        welcome_text += f"\n\n🔔 {get_text('pending_reports', lang).format(len(pending_reports))}"
                    if pending_complaints:
                        welcome_text += f"\n📢 {get_text('pending_complaints', lang).format(pending_complaints)}"
                    if laundry_pending > 0:
                        welcome_text += f"\n🧺 {get_text('active_laundry', lang).format(laundry_pending)}"
                    
                    hotel_settings = self.db.get_hotel_settings()
                    ai_enabled = hotel_settings.get('ai_analysis_enabled', False)
                    ai_button_text = get_text('ai_analysis', lang) if ai_enabled else f"🔒 {get_text('ai_analysis', lang)}"
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('dashboard', lang), callback_data="dashboard"),
                         InlineKeyboardButton(get_text('actions', lang), callback_data="actions")],
                        [InlineKeyboardButton(get_text('reports_pending_count', lang).format(len(pending_reports)) if pending_reports else get_text('reports_pending', lang), callback_data="admin_pending_reports"),
                         InlineKeyboardButton(get_text('complaints_pending_count', lang).format(pending_complaints) if pending_complaints else get_text('complaints_pending', lang), callback_data="admin_complaints")],
                        [InlineKeyboardButton(ai_button_text, callback_data="ai_analysis_menu")],
                        [InlineKeyboardButton(f"📞 {get_text('service_contacts', lang)}", callback_data="admin_contacts")],
                        [InlineKeyboardButton(get_text('settings', lang), callback_data="settings"),
                         InlineKeyboardButton(get_text('information', lang), callback_data="information")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await update.message.reply_text(welcome_text, reply_markup=reply_markup)
                    return
                
                unread_count = self.db.get_unread_task_count(telegram_user_id, department)
                print(f"✅ Unread task count: {unread_count} items")
                notification_text = get_text('new_task_notification_count', lang).format(unread_count) if unread_count > 0 else get_text('new_task_notification', lang)
                
                reportable_tasks = self.db.get_reportable_tasks(telegram_user_id, department)
                report_count = len(reportable_tasks)
                print(f"✅ Reportable tasks retrieved: {report_count} items")
                report_text = get_text('report_task_count', lang).format(report_count) if report_count > 0 else get_text('report_task', lang)
                
                languages = get_available_languages()
                current_lang_name = languages.get(lang, '🇷🇸 Srpski')
                
                info_lines = [
                    f"• {get_text('employee_id', lang)}: {employee_id}",
                    f"• {get_text('department', lang)}: {dept_display}"
                ]
                
                if work_role:
                    info_lines.append(f"• {get_text('work_role', lang)}: {work_role}")
                
                if gmail:
                    info_lines.append(f"• 📧 Gmail: {gmail}")
                
                if whatsapp:
                    info_lines.append(f"• 📱 WhatsApp: {whatsapp}")
                
                info_lines.append(f"• 🌐 {get_text('language', lang)}: {current_lang_name}")
                
                welcome_text = f"""{get_text('welcome_back', lang).format(name)}

{get_text('your_info', lang)}
{chr(10).join(info_lines)}

{get_text('select_option', lang)}"""
                
                print(f"📝 Welcome message created for {name}")
                keyboard = [
                    [InlineKeyboardButton(get_text('tasks', lang), callback_data="emp_work_menu"),
                     InlineKeyboardButton(report_text, callback_data="emp_report_task")],
                    [InlineKeyboardButton(notification_text, callback_data="emp_notifications")],
                    [InlineKeyboardButton(get_text('schedule', lang), callback_data="emp_schedule_menu"),
                     InlineKeyboardButton(get_text('complaint', lang), callback_data="emp_complaint")],
                    [InlineKeyboardButton(get_text('my_profile', lang), callback_data="emp_profile"),
                     InlineKeyboardButton(get_text('settings', lang), callback_data="emp_settings")]
                ]
                
                if department == 'Reception':
                    keyboard.insert(3, [InlineKeyboardButton(f"📞 {get_text('service_contacts', lang)}", callback_data="admin_contacts")])
                print(f"⌨️ Keyboard created with {len(keyboard)} rows")
                reply_markup = InlineKeyboardMarkup(keyboard)
                print(f"📤 Sending employee menu to {name} (ID: {employee_id})")
                
                import asyncio
                for attempt in range(3):
                    try:
                        await update.message.reply_text(welcome_text, reply_markup=reply_markup)
                        print(f"✅ Employee menu sent successfully!")
                        break
                    except Exception as send_error:
                        if "Timed out" in str(send_error) and attempt < 2:
                            print(f"⚠️ Timeout on attempt {attempt + 1}, retrying...")
                            await asyncio.sleep(1)
                        else:
                            raise send_error
            else:
                languages = get_available_languages()
                current_lang_name = languages.get(lang, '🇷🇸 Srpski')
                
                context.user_data['registration'] = {
                    'step': 'language',
                    'telegram_user_id': telegram_user_id,
                    'username': username
                }
                
                keyboard = []
                for lang_code, lang_name in languages.items():
                    keyboard.append([InlineKeyboardButton(
                        f"{'✅ ' if lang_code == lang else ''}{lang_name}",
                        callback_data=f"reg_lang_{lang_code}"
                    )])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                welcome_text = f"""{get_text('welcome', lang)} @{username}! 👋

{get_text('registration_welcome', lang)}

🌐 {get_text('select_language', lang)}
{get_text('current_language', lang)}: {current_lang_name}"""
                
                # Retry logic for timeout errors
                import asyncio
                for attempt in range(3):
                    try:
                        await update.message.reply_text(welcome_text, reply_markup=reply_markup)
                        break
                    except Exception as send_error:
                        if "Timed out" in str(send_error) and attempt < 2:
                            print(f"⚠️ Timeout on attempt {attempt + 1}, retrying...")
                            await asyncio.sleep(1)
                        else:
                            raise send_error
        except Exception as e:
            print(f"❌ Error in start_command: {e}")
            import traceback
            traceback.print_exc()
            try:
                await update.message.reply_text(get_text('error_occurred', lang))
            except:
                pass
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle help command"""
        try:
            help_message = """
📋 Opis komandi:

/start - Pokrenite bota i prikažite poruku dobrodošlice
/help - Prikažite ovu poruku pomoći
/admin - Pristup admin panelu (samo za upravu)
/rooms - Pogledajte sve registrovane sobe
/reservations - Pogledajte trenutne rezervacije

Uskoro dolaze nove funkcije!
        """
            await update.message.reply_text(help_message)
        except Exception as e:
            print(f"❌ Error in help_command: {e}")
            try:
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                await update.message.reply_text(get_text('error_occurred_try_again', lang))
            except:
                pass
    
    async def shift_status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle shift status command - shows current shift info"""
        try:
            telegram_user_id = update.effective_user.id
            lang = get_user_language(telegram_user_id, self.db)
            
            # Check if user is admin
            if not self.db.check_admin(telegram_user_id):
                await update.message.reply_text(get_text('command_not_available', lang))
                return
            
            # Get shift status summary
            summary = get_shift_status_summary(self.db)
            
            if not summary or not summary.get('current_shift'):
                await update.message.reply_text("❌ Shift system not configured yet.")
                return
            
            # Build status message
            shift_icons = {'A': '🌅', 'B': '🌆', 'C': '🌙'}
            shift_names = {
                'A': 'Morning (08:00-16:00)',
                'B': 'Evening (16:00-00:00)', 
                'C': 'Night (00:00-08:00)'
            }
            
            current_shift = summary['current_shift']
            current_time = summary['current_time']
            
            status_text = f"""🔄 **SHIFT STATUS**

🕐 Current Time: {current_time}
{shift_icons.get(current_shift, '⏰')} Current Shift: **{current_shift}** - {shift_names.get(current_shift, 'Unknown')}

━━━━━━━━━━━━━━━━━━━━
"""
            
            # Add department info
            departments = summary.get('departments', {})
            if departments:
                for dept_name, dept_data in departments.items():
                    on_shift_count = dept_data.get('on_shift_count', 0)
                    off_shift_count = dept_data.get('off_shift_count', 0)
                    total = on_shift_count + off_shift_count
                    
                    status_text += f"\n📊 **{dept_name}**\n"
                    status_text += f"   🟢 ON SHIFT: {on_shift_count} employees\n"
                    status_text += f"   ⏭️ OFF SHIFT: {off_shift_count} employees\n"
                    status_text += f"   Total: {total}\n"
                    status_text += f"   Distribution: A:{dept_data.get('A', 0)} | B:{dept_data.get('B', 0)} | C:{dept_data.get('C', 0)}\n"
                
                # Get detailed employee list for current shift
                status_text += "\n━━━━━━━━━━━━━━━━━━━━\n"
                status_text += "👥 **ON-SHIFT EMPLOYEES:**\n\n"
                
                for dept_name in ['Reception', 'Restaurant']:
                    if dept_name in departments:
                        on_shift_emps = get_on_shift_employees(self.db, dept_name)
                        if on_shift_emps:
                            status_text += f"**{dept_name}:**\n"
                            for emp in on_shift_emps:
                                status_text += f"  • {emp['name']} ({emp['employee_id']}) - Shift {emp['shift_type']}\n"
                            status_text += "\n"
            else:
                status_text += "\n⚠️ No shift assignments found.\n"
            
            await update.message.reply_text(status_text, parse_mode='Markdown')
            
        except Exception as e:
            print(f"❌ Error in shift_status_command: {e}")
            import traceback
            traceback.print_exc()
            try:
                await update.message.reply_text(f"❌ Error: {str(e)}")
            except:
                pass
    
    async def test_shift_alarm_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manual trigger for shift report alarm - for testing purposes"""
        try:
            telegram_user_id = update.effective_user.id
            
            # Check admin permission
            if not self.db.check_admin(telegram_user_id):
                await update.message.reply_text("❌ This command is only available for administrators.")
                return
            
            await update.message.reply_text("🔔 Manually triggering shift report check...")
            
            # Import the shift notification function
            from shift_operations import send_shift_notifications
            from database import get_reception_shift_times
            
            # Get shift times
            shift_times = get_reception_shift_times(self.db)
            if not shift_times:
                await update.message.reply_text("❌ No active shift configuration found.")
                return
            
            # Manually trigger notification for Shift 1 (you can change this)
            shift_number = 1
            shift_end_time = shift_times.get('shift_1_end')
            
            if not shift_end_time:
                await update.message.reply_text("❌ Shift 1 end time not configured.")
                return
            
            await update.message.reply_text(f"📋 Sending shift report notifications for Shift {shift_number} (ends at {shift_end_time})...")
            
            # Send notifications
            await send_shift_notifications(
                self.application.bot,
                self.db,
                shift_number,
                shift_end_time,
                reminder_number=1
            )
            
            await update.message.reply_text(f"✅ Shift report notifications sent! Check your Telegram for the notification.")
            
        except Exception as e:
            print(f"❌ Error in test_shift_alarm_command: {e}")
            import traceback
            traceback.print_exc()
            try:
                await update.message.reply_text(f"❌ Error: {str(e)}")
            except:
                pass
    
    async def admin_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):

        """Handle admin command"""
        try:
            # Get Telegram user ID
            telegram_user_id = update.effective_user.id
            username = update.effective_user.username or "Unknown"
            
            print(f"\n📋 /admin command request: User ID {telegram_user_id} (@{username})")
            
            # Check admin permission (using telegram_user_id)
            if not self.db.check_admin(telegram_user_id):
                lang = get_user_language(telegram_user_id, self.db)
                await update.message.reply_text(get_text('command_not_available', lang))
                return
            
            # Get employee info (using telegram_user_id)
            employee_info = self.db.get_employee_info(telegram_user_id)
            if not employee_info:
                lang = get_user_language(telegram_user_id, self.db)
                await update.message.reply_text(get_text('command_not_available', lang))
                return
            
            lang = get_user_language(telegram_user_id, self.db)
            employee_id = employee_info['employee_id']
            name = employee_info['name']
            department = employee_info['department']
            work_role = employee_info.get('work_role')
            gmail = employee_info.get('gmail')
            whatsapp = employee_info.get('whatsapp')
            dept_display = get_dept_display(department, lang)
            
            pending_reports = self.db.get_pending_admin_reports()
            
            info_lines = [
                f"• {get_text('name', lang)}: {name}",
                f"• {get_text('employee_id', lang)}: {employee_id}",
                f"• {get_text('department', lang)}: {dept_display} (Admin)",
                f"• {get_text('telegram_id', lang)}: {telegram_user_id}"
            ]
            
            if work_role:
                info_lines.append(f"• {get_text('work_role', lang)}: {work_role}")
            
            gmail_display = gmail if gmail else get_text('not_set', lang)
            info_lines.append(f"• 📧 Gmail: {gmail_display}")
            
            whatsapp_display = whatsapp if whatsapp else get_text('not_set', lang)
            info_lines.append(f"• 📱 WhatsApp: {whatsapp_display}")
            
            welcome_text = f"""{get_text('welcome_admin', lang)}

{get_text('you_are_first_employee', lang)}
Automatski ste dodeljeni odeljenju Uprave sa punim pristupom.

{get_text('your_info', lang)}
{chr(10).join(info_lines)}

{get_text('now_full_access', lang)}
        """
            
            if pending_reports:
                welcome_text += f"\n\n🔔 {get_text('pending_reports', lang).format(len(pending_reports))}"
            
            pending_complaints = self.db.get_unconfirmed_complaints()
            if pending_complaints:
                welcome_text += f"\n📢 {get_text('pending_complaints', lang).format(pending_complaints)}"
            
            hotel_settings = self.db.get_hotel_settings()
            ai_enabled = hotel_settings.get('ai_analysis_enabled', False)
            ai_button_text = get_text('ai_analysis', lang) if ai_enabled else f"🔒 {get_text('ai_analysis', lang)}"
            
            keyboard = [
                [InlineKeyboardButton(get_text('dashboard', lang), callback_data="dashboard"),
                 InlineKeyboardButton(get_text('actions', lang), callback_data="actions")],
                [InlineKeyboardButton(get_text('reports_pending_count', lang).format(len(pending_reports)) if pending_reports else get_text('reports_pending', lang), callback_data="admin_pending_reports"),
                 InlineKeyboardButton(get_text('complaints_pending_count', lang).format(pending_complaints) if pending_complaints else get_text('complaints_pending', lang), callback_data="admin_complaints")],
                [InlineKeyboardButton(ai_button_text, callback_data="ai_analysis_menu")],
                [InlineKeyboardButton(get_text('settings', lang), callback_data="settings"),
                 InlineKeyboardButton(get_text('information', lang), callback_data="information")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(welcome_text, reply_markup=reply_markup)
                        
        except Exception as e:
            print(f"❌ Error in admin_command: {e}")
            lang = get_user_language(telegram_user_id, self.db)
            try:
                await update.message.reply_text(get_text('loading_error', lang))
            except:
                pass
    
    def _should_log_action(self, callback_data):
        """Determine if this action should be logged (only important actions)"""
        # Define important action prefixes that should be logged
        important_actions = [
            'create_', 'add_', 'new_',  # Creating/Adding
            'update_', 'edit_', 'modify_',  # Updating/Editing
            'delete_', 'remove_',  # Deleting
            'confirm_', 'accept_', 'approve_',  # Confirming/Accepting
            'reject_', 'decline_',  # Rejecting
            'assign_', 'reassign_',  # Assigning tasks
            'complete_', 'finish_',  # Completing tasks
            'checkout_', 'checkin_',  # Check in/out operations
            'record_',  # Recording transactions
            'toggle_email_', 'toggle_whatsapp_',  # Settings changes
        ]
        
        # Check if callback_data starts with any important action
        return any(callback_data.startswith(action) for action in important_actions)
    
    def _get_action_summary(self, callback_data, action_type):
        """Get a concise summary of the action"""
        # Map callback patterns to concise English descriptions
        summaries = {
            'create_': 'create',
            'add_': 'add',
            'new_': 'new',
            'update_': 'update',
            'edit_': 'edit',
            'modify_': 'modify',
            'delete_': 'delete',
            'remove_': 'remove',
            'confirm_': 'confirm',
            'accept_': 'accept',
            'approve_': 'approve',
            'reject_': 'reject',
            'decline_': 'decline',
            'assign_': 'assign',
            'reassign_': 'reassign',
            'complete_': 'complete',
            'finish_': 'finish',
            'checkout_': 'checkout',
            'checkin_': 'checkin',
            'record_': 'record',
            'toggle_email_': 'email_setting',
            'toggle_whatsapp_': 'whatsapp_setting',
        }
        
        for prefix, summary in summaries.items():
            if callback_data.startswith(prefix):
                return summary
        
        return action_type
    
    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle button clicks"""
        try:
            from database import log_action
            
            query = update.callback_query
            
            try:
                await query.answer()
            except Exception as answer_error:
                print(f"⚠️ Warning: query.answer() failed: {answer_error}")
            
            telegram_user_id = update.effective_user.id
            
            is_employee_action = (
                query.data == "noop" or
                query.data.startswith("reg_lang_") or
                query.data.startswith("reg_dept_") or 
                query.data.startswith("reg_role_") or
                query.data == "reg_back_to_dept" or
                query.data.startswith("emp_") or
                query.data.startswith("emp_task_") or
                query.data.startswith("emp_complete_") or
                query.data.startswith("emp_proof_") or
                query.data.startswith("report_task_") or
                query.data.startswith("report_complete_") or
                query.data == "report_skip_attachment" or
                query.data == "report_complete_with_attachments" or
                query.data.startswith("admin_confirm_") or
                query.data.startswith("admin_view_report_") or
                query.data.startswith("admin_contact") or
                query.data.startswith("schedule_") or
                query.data.startswith("complaint_") or
                query.data.startswith("duty_yes_") or
                query.data.startswith("duty_no_") or
                query.data.startswith("hotel_room_") or
                query.data.startswith("reception_") or
                query.data.startswith("key_") or
                query.data.startswith("tool_") or
                query.data.startswith("vehicle_") or
                query.data.startswith("clean_") or
                query.data.startswith("laundry_") or
                query.data.startswith("rest_") or
                query.data.startswith("restaurant_") or
                query.data.startswith("driver_") or
                query.data.startswith("acct_") or
                query.data.startswith("repair_") or
                query.data.startswith("finance_") or
                query.data.startswith("kitchen_") or
                query.data.startswith("inventory_") or
                query.data.startswith("task_accept_") or
                query.data.startswith("task_reject_") or
                query.data.startswith("shift_report_") or
                query.data.startswith("event_ack_") or
                query.data.startswith("event_confirm_") or
                query.data.startswith("event_ready_") or
                query.data == "cancel_event_ready" or
                query.data == "my_laundry_tasks" or
                query.data == "my_restaurant_tasks" or
                query.data == "my_delivery_tasks" or
                query.data == "my_accounting_tasks" or
                query.data == "my_repair_tasks" or
                query.data == "back_to_employee_menu" or
                query.data == "admin_pending_reports"
            )
            
            if not is_employee_action and not self.db.check_admin(telegram_user_id):
                lang = get_user_language(telegram_user_id, self.db)
                await query.edit_message_text(get_text('command_not_available', lang))
                return
            
            # No-op handler for non-clickable buttons (date headers, page indicators)
            if query.data == "noop":
                return
            
            # Handle overdue task pagination
            if query.data.startswith("view_overdue_page_"):
                page = int(query.data.split("_")[-1])
                await self.show_overdue_tasks_page(query, telegram_user_id, page)
                return
            
            if query.data == "dashboard":
                lang = get_user_language(telegram_user_id, self.db)
                departments = self.db.get_departments(exclude_management=True)
                
                if not departments:
                    await query.edit_message_text(f"{get_text('dashboard', lang)}\n\n{get_text('no_departments_found', lang)}")
                    return
                
                keyboard = []
                row = []
                for dept_id, dept_name, dept_content in departments:
                    emoji = get_dept_emoji(dept_name)
                    dept_display = get_dept_display(dept_name, lang)
                    row.append(InlineKeyboardButton(f"{emoji} {dept_display}", callback_data=f"dept_{dept_id}"))
                    if len(row) == 2:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="back_to_admin")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(f"{get_text('dashboard', lang)}\n\n{get_text('select_department', lang)}", reply_markup=reply_markup)
            
            # Laundry Dashboard - for managers and receptionists
            elif query.data == "laundry_dashboard":
                lang = get_user_language(telegram_user_id, self.db)
                from database import get_laundry_dashboard_view, get_laundry_stats
                
                dashboard_text = get_laundry_dashboard_view(self.db)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('tasks_pending', lang), callback_data="laundry_dash_pending")],
                    [InlineKeyboardButton(get_text('tasks_in_progress', lang), callback_data="laundry_dash_accepted")],
                    [InlineKeyboardButton(get_text('tasks_completed', lang), callback_data="laundry_dash_completed")],
                    [InlineKeyboardButton(get_text('refresh', lang), callback_data="laundry_dashboard")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="back_to_admin")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(dashboard_text, reply_markup=reply_markup)
            
            # Laundry Dashboard - Pending tasks
            elif query.data == "laundry_dash_pending":
                lang = get_user_language(telegram_user_id, self.db)
                from database import get_all_laundry_tasks
                
                tasks = get_all_laundry_tasks(self.db, status="Pending")
                
                if not tasks:
                    text = f"{get_text('tasks_pending', lang)}\n\n{get_text('no_tasks_pending', lang)}"
                    keyboard = [[InlineKeyboardButton(get_text('back_to_dashboard', lang), callback_data="laundry_dashboard")]]
                else:
                    text = f"{get_text('tasks_pending', lang)} ({len(tasks)})\n\n"
                    keyboard = []
                    
                    for task in tasks[:15]:  # Show max 15 tasks
                        task_id, room_number, floor, assignee_name, description, due_date, due_time, status, assigned_by_name, assigned_at, accepted_at, completed_at, proof_path, report_notes = task
                        
                        short_desc = description[:25] + "..." if len(description) > 25 else description
                        button_text = f"🚪{room_number} | {assignee_name[:15]} - {short_desc}"
                        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"laundry_view_{task_id}")])
                    
                    keyboard.append([InlineKeyboardButton(get_text('back_to_dashboard', lang), callback_data="laundry_dashboard")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Laundry Dashboard - Accepted tasks
            elif query.data == "laundry_dash_accepted":
                lang = get_user_language(telegram_user_id, self.db)
                from database import get_all_laundry_tasks
                
                tasks = get_all_laundry_tasks(self.db, status="Accepted")
                
                if not tasks:
                    text = f"{get_text('tasks_in_progress', lang)}\n\n{get_text('no_tasks_in_progress', lang)}"
                    keyboard = [[InlineKeyboardButton(get_text('back_to_dashboard', lang), callback_data="laundry_dashboard")]]
                else:
                    text = f"{get_text('tasks_in_progress', lang)} ({len(tasks)})\n\n"
                    keyboard = []
                    
                    for task in tasks[:15]:  # Show max 15 tasks
                        task_id, room_number, floor, assignee_name, description, due_date, due_time, status, assigned_by_name, assigned_at, accepted_at, completed_at, proof_path, report_notes = task
                        
                        short_desc = description[:25] + "..." if len(description) > 25 else description
                        button_text = f"🚪{room_number} | {assignee_name[:15]} - {short_desc}"
                        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"laundry_view_{task_id}")])
                    
                    keyboard.append([InlineKeyboardButton(get_text('back_to_dashboard', lang), callback_data="laundry_dashboard")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Laundry Dashboard - Completed tasks
            elif query.data == "laundry_dash_completed":
                lang = get_user_language(telegram_user_id, self.db)
                from database import get_all_laundry_tasks
                
                tasks = get_all_laundry_tasks(self.db, status="Completed")
                
                if not tasks:
                    text = f"{get_text('tasks_completed', lang)}\n\n{get_text('no_tasks_completed', lang)}"
                    keyboard = [[InlineKeyboardButton(get_text('back_to_dashboard', lang), callback_data="laundry_dashboard")]]
                else:
                    text = f"{get_text('tasks_completed', lang)} ({len(tasks)})\n\n"
                    keyboard = []
                    
                    for task in tasks[:15]:
                        task_id, room_number, floor, assignee_name, description, due_date, due_time, status, assigned_by_name, assigned_at, accepted_at, completed_at, proof_path, report_notes = task
                        
                        short_desc = description[:25] + "..." if len(description) > 25 else description
                        time_str = completed_at.split()[1] if completed_at and ' ' in completed_at else ""
                        button_text = f"✅ {time_str} | 🚪{room_number} | {assignee_name[:12]}"
                        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"laundry_view_{task_id}")])
                    
                    keyboard.append([InlineKeyboardButton(get_text('back_to_dashboard', lang), callback_data="laundry_dashboard")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            elif query.data.startswith("laundry_view_"):
                from database import get_laundry_task_by_id
                
                lang = get_user_language(query.from_user.id, self.db)
                task_id = int(query.data.replace("laundry_view_", ""))
                task = get_laundry_task_by_id(self.db, task_id)
                
                if not task:
                    await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    return
                
                status_emoji = {"Pending": "⏳", "Accepted": "🔄", "Completed": "✅"}.get(task['status'], "❓")
                
                text = f"""{status_emoji} {get_text('task_details', lang)} #{task_id}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📍 {get_text('location', lang)}:
🚪 {get_text('room', lang)}: {task['room_number']}
🏢 {get_text('floor', lang)}: {task['floor']}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 {get_text('assigned_to', lang)}: {task['assignee_name']}
📝 {get_text('description', lang)}: {task['description']}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ {get_text('deadline', lang)}: {task['due_date']} {task['due_time']}
📸 {get_text('proof', lang)}: {get_text('required', lang) if task['proof_required'] else get_text('not_required', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 {get_text('status', lang)}: {task['status']}"""

                if task['assigned_by_name']:
                    text += f"\n👨‍💼 {get_text('assigned_by', lang)}: {task['assigned_by_name']}"
                if task['assigned_at']:
                    text += f"\n📅 {get_text('assigned_at', lang)}: {task['assigned_at']}"
                if task['accepted_at']:
                    text += f"\n✅ {get_text('accepted_at', lang)}: {task['accepted_at']}"
                if task['completed_at']:
                    text += f"\n🎉 {get_text('completed_at', lang)}: {task['completed_at']}"
                if task['report_notes']:
                    text += f"\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📄 {get_text('report', lang)}:\n{task['report_notes']}"
                keyboard = [[InlineKeyboardButton(get_text('back_to_dashboard', lang), callback_data="laundry_dashboard")]]
                
                if task['proof_path']:
                    text += f"\n\n{get_text('task_contains_proof', lang)}"
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Department Statistics by Period - MUST be before dept_ handler
            elif query.data.startswith("dept_stats_"):
                parts = query.data.replace("dept_stats_", "").split("_")
                dept_id = parts[0]
                period = parts[1] if len(parts) > 1 else 'daily'
                
                # Map department IDs to names and labels
                dept_map = {
                    '5': ('Technical', 'Tehnička služba', '🔧'),
                    '7': ('Restaurant', 'Restaurant', '🍽️'),
                    '6': ('Accounting', 'Računovodstvo', '💰'),
                    '10': ('Transportation', 'Transportation', '🚗'),
                    '11': ('Laundry', 'Waskamer', '🧺')
                }
                
                lang = get_user_language(query.from_user.id, self.db)
                
                if dept_id not in dept_map:
                    await query.answer(get_text('unknown_department', lang), show_alert=True)
                    return
                
                dept_name, dept_label, dept_emoji = dept_map[dept_id]
                
                # Technical uses repair stats (dept_id = 5)
                if dept_id == '5':
                    from database import get_repair_task_stats
                    stats = get_repair_task_stats(self.db, period)
                    
                    text = f"{dept_emoji} {get_dept_display(dept_label, lang)} - {get_text('overview', lang)}\n\n"
                    text += f"📅 {stats['period_label']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"{get_text('total_repairs', lang)}: {stats['total']}\n"
                    text += f"   ├─ {get_text('tasks_pending', lang)}: {stats['pending']}\n"
                    text += f"   ├─ {get_text('tasks_in_progress', lang)}: {stats['accepted']}\n"
                    text += f"   └─ {get_text('tasks_completed', lang)}: {stats['completed']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    
                    if stats['tasks']:
                        text += f"\n{get_text('recent_repairs', lang)}\n"
                        for task in stats['tasks'][:5]:
                            status_emoji = {'Pending': '⏳', 'Accepted': '🔄', 'Completed': '✅'}.get(task['status'], '❓')
                            text += f"{status_emoji} #{task['id']} {task['assignee']}: {task['description']}\n"
                else:
                    from database import get_department_task_stats
                    stats = get_department_task_stats(self.db, dept_name, period)
                    
                    text = f"{dept_emoji} {get_dept_display(dept_label, lang)} - {get_text('task_overview', lang)}\n\n"
                    text += f"📅 {stats['period_label']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"{get_text('total_tasks', lang)}: {stats['total']}\n"
                    text += f"   ├─ {get_text('tasks_pending', lang)}: {stats['pending']}\n"
                    text += f"   ├─ {get_text('tasks_in_progress', lang)}: {stats['accepted']}\n"
                    text += f"   └─ {get_text('tasks_completed', lang)}: {stats['completed']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    
                    if stats['tasks']:
                        text += f"\n{get_text('recent_tasks', lang)}\n"
                        for task in stats['tasks'][:5]:
                            status_emoji = {'Pending': '⏳', 'Accepted': '🔄', 'Completed': '✅'}.get(task['status'], '❓')
                            text += f"{status_emoji} #{task['id']} {task['assignee']}: {task['description']}\n"
                
                # Highlight current period
                daily_label = f"✓ {get_text('daily', lang)}" if period == 'daily' else get_text('today', lang)
                weekly_label = f"✓ {get_text('weekly', lang)}" if period == 'weekly' else get_text('week', lang)
                monthly_label = f"✓ {get_text('monthly', lang)}" if period == 'monthly' else get_text('month', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(daily_label, callback_data=f"dept_stats_{dept_id}_daily"),
                        InlineKeyboardButton(weekly_label, callback_data=f"dept_stats_{dept_id}_weekly"),
                        InlineKeyboardButton(monthly_label, callback_data=f"dept_stats_{dept_id}_monthly")
                    ],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="dashboard")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            elif query.data.startswith("dept_"):
                # Handle department selection
                dept_id = query.data.replace("dept_", "").split("_page_")[0]
                
                # Reception department (id=2) - show room list with pagination
                if dept_id == "2" or query.data.startswith("dept_2_page_"):
                    rooms = self.db.get_customer_rooms()
                    summary = self.db.get_customer_rooms_summary()
                    hotel_settings = self.db.get_hotel_settings()
                    
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    if not rooms:
                        await query.edit_message_text(get_text('reception_no_rooms', lang))
                        return
                    
                    # Calculate active rooms for equipment percentage
                    active_rooms = summary['active']
                    total_configured = hotel_settings['total_rooms']
                    occupied_count = summary['checked_in']
                    
                    # Generate summary text
                    summary_text = f"""🛎️ {get_text('reception', lang)} - {get_text('room_status', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('room_overview', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('capacity_settings', lang).format(total_configured)}
{get_text('currently_registered', lang).format(summary['total'])}
   {get_text('active_rooms_count', lang).format(summary['active'])}
   {get_text('inactive_rooms_count', lang).format(summary['inactive'])}

{get_text('occupancy_status', lang)}:
   {get_text('occupied_count', lang).format(occupied_count)}
   {get_text('available_count', lang).format(summary['available'])}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('equipment_status', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('air_conditioning', lang)}: {summary['ac_working']}/{active_rooms}
{get_text('tv', lang)}: {summary['tv_working']}/{active_rooms}
{get_text('toilet', lang)}: {summary['toilet_working']}/{active_rooms}
{get_text('remote_control', lang)}: {summary['remote_working']}/{active_rooms}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('select_room_details', lang)}
🟢 = {get_text('all_equipment_ok', lang)} | 🔴 = {get_text('equipment_broken', lang)} | {get_text('inactive_label', lang)}"""
                    
                    # Parse page from callback data if available
                    page = 1
                    if "_page_" in query.data:
                        try:
                            page = int(query.data.split("_page_")[1])
                        except:
                            page = 1
                    
                    # Pagination settings - 3 rooms per row, 7 rows per page = 21 rooms per page (round to 20)
                    items_per_row = 3
                    items_per_page = 21  # 7 rows of 3
                    
                    total_pages = (len(rooms) + items_per_page - 1) // items_per_page if rooms else 1
                    page = max(1, min(page, total_pages))
                    
                    start_idx = (page - 1) * items_per_page
                    end_idx = min(start_idx + items_per_page, len(rooms))
                    page_rooms = rooms[start_idx:end_idx]
                    
                    # Update summary text with page info
                    summary_text = f"""🛎️ {get_text('reception', lang)} - {get_text('room_status', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('room_overview', lang)} (Page {page}/{total_pages})
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('capacity_settings', lang).format(total_configured)}
{get_text('currently_registered', lang).format(summary['total'])}
   {get_text('active_rooms_count', lang).format(summary['active'])}
   {get_text('inactive_rooms_count', lang).format(summary['inactive'])}

{get_text('occupancy_status', lang)}:
   {get_text('occupied_count', lang).format(occupied_count)}
   {get_text('available_count', lang).format(summary['available'])}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('equipment_status', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('air_conditioning', lang)}: {summary['ac_working']}/{active_rooms}
{get_text('tv', lang)}: {summary['tv_working']}/{active_rooms}
{get_text('toilet', lang)}: {summary['toilet_working']}/{active_rooms}
{get_text('remote_control', lang)}: {summary['remote_working']}/{active_rooms}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('select_room_details', lang)}
🟢 = {get_text('all_equipment_ok', lang)} | 🔴 = {get_text('equipment_broken', lang)} | {get_text('inactive_label', lang)}"""
                    
                    keyboard = []
                    row = []
                    for room in page_rooms:
                        room_id, id_room, is_check, ac, tv, toilet, remote, is_active, total_capacity, current_guests = room
                        if is_active == 0:
                            status_emoji = "⚫"
                        elif str(ac) == "1" and str(tv) == "1" and str(toilet) == "1" and str(remote) == "1":
                            status_emoji = "🟢"
                        else:
                            status_emoji = "🔴"
                        row.append(InlineKeyboardButton(f"{status_emoji} {id_room}", callback_data=f"room_{room_id}"))
                        
                        if len(row) == 3:  # 3 per row
                            keyboard.append(row)
                            row = []
                    
                    if row:  # Add remaining buttons
                        keyboard.append(row)
                    
                    # Add pagination navigation
                    if total_pages > 1:
                        nav_row = []
                        if page > 1:
                            nav_row.append(InlineKeyboardButton("⬅️ Prev", callback_data=f"dept_2_page_{page-1}"))
                        nav_row.append(InlineKeyboardButton(f"📄 {page}/{total_pages}", callback_data="noop"))
                        if page < total_pages:
                            nav_row.append(InlineKeyboardButton("Next ➡️", callback_data=f"dept_2_page_{page+1}"))
                        keyboard.append(nav_row)
                    
                    # Add back button
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="dashboard")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(summary_text, reply_markup=reply_markup)
                
                # Housekeeping department (id=3) - show amenities status
                elif dept_id == "3":
                    summary = self.db.get_housekeeping_summary()
                    lang = get_user_language(query.from_user.id, self.db)
                    
                    if not summary:
                        await query.edit_message_text(f"🧹 {get_text('housekeeping', lang)}\n\n{get_text('no_data', lang)}")
                        return
                    
                    total = summary['total']
                    
                    # Green if all rooms are OK, blue if any needs attention
                    ac_emoji = "🟢" if summary['ac_ok'] == total else "🔵"
                    tv_emoji = "🟢" if summary['tv_ok'] == total else "🔵"
                    toilet_emoji = "🟢" if summary['toilet_ok'] == total else "🔵"
                    remote_emoji = "🟢" if summary['remote_ok'] == total else "🔵"
                    
                    summary_text = f"""🧹 {get_text('housekeeping', lang)} - {get_text('equipment_status_title', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 {get_text('overview', lang)} ({get_text('working', lang)} / {get_text('total', lang)})
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('air_conditioning', lang)}: {summary['ac_ok']}/{total}
{get_text('tv', lang)}: {summary['tv_ok']}/{total}
{get_text('toilet', lang)}: {summary['toilet_ok']}/{total}
{get_text('remote_control', lang)}: {summary['remote_ok']}/{total}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
🟢 = {get_text('good_condition', lang)} | 🔵 = {get_text('bad_condition', lang)}

{get_text('select_equipment', lang)}"""
                    
                    keyboard = [
                        [InlineKeyboardButton(f"{ac_emoji} {get_text('air_conditioning', lang)} ({summary['ac_ok']}/{total})", callback_data="amenity_AC")],
                        [InlineKeyboardButton(f"{tv_emoji} {get_text('tv', lang)} ({summary['tv_ok']}/{total})", callback_data="amenity_TV")],
                        [InlineKeyboardButton(f"{toilet_emoji} {get_text('toilet', lang)} ({summary['toilet_ok']}/{total})", callback_data="amenity_Toilet")],
                        [InlineKeyboardButton(f"{remote_emoji} {get_text('remote_control', lang)} ({summary['remote_ok']}/{total})", callback_data="amenity_Remote_Control")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="dashboard")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(summary_text, reply_markup=reply_markup)
                
                # Accounting department (id=6) - show financial dashboard
                elif dept_id == "6":
                    from database import get_admin_finance_dashboard
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    dashboard = get_admin_finance_dashboard(self.db)
                    
                    if not dashboard:
                        await query.edit_message_text(
                            "❌ Error loading financial dashboard",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="dashboard")
                            ]])
                        )
                        return
                    
                    # Build financial dashboard view
                    text = f"💰 {get_dept_display('Accounting', lang)} - DASHBOARD\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    
                    # Current Balances
                    balances = dashboard['balances']
                    text += "🏦 CURRENT BALANCES\n"
                    text += f"   💵 Cash: {balances['cash_balance']:,.2f} RSD\n"
                    text += f"   🏛️ Bank: {balances['bank_balance']:,.2f} RSD\n"
                    text += f"   💰 Total: {balances['total_balance']:,.2f} RSD\n\n"
                    
                    # Today's Activity
                    today = dashboard['today']
                    text += "📅 TODAY'S ACTIVITY\n"
                    text += f"   📈 Income: {today['income']:,.2f} RSD\n"
                    text += f"   📉 Expense: {today['expense']:,.2f} RSD\n"
                    today_net = today['income'] - today['expense']
                    net_emoji = "📊" if today_net >= 0 else "⚠️"
                    text += f"   {net_emoji} Net: {today_net:,.2f} RSD\n"
                    text += f"   🧾 Transactions: {today['count']}\n\n"
                    
                    # This Week
                    week = dashboard['week']
                    text += "📆 THIS WEEK\n"
                    text += f"   📈 Income: {week['income']:,.2f} RSD\n"
                    text += f"   📉 Expense: {week['expense']:,.2f} RSD\n"
                    text += f"   🧾 Transactions: {week['count']}\n\n"
                    
                    # This Month
                    month = dashboard['month']
                    text += "🗓️ THIS MONTH\n"
                    text += f"   📈 Income: {month['income']:,.2f} RSD\n"
                    text += f"   📉 Expense: {month['expense']:,.2f} RSD\n"
                    text += f"   🧾 Transactions: {month['count']}\n\n"
                    
                    # Alerts
                    if dashboard['no_proof_count'] > 0:
                        text += "⚠️ ALERTS\n"
                        text += f"   📎 Without proof: {dashboard['no_proof_count']} transactions\n\n"
                    
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    
                    keyboard = [
                        [InlineKeyboardButton("� All Transactions", callback_data="admin_finance_transactions"),
                         InlineKeyboardButton("⚠️ Without Proof", callback_data="admin_finance_no_proof")],
                        [InlineKeyboardButton("📊 Category Report", callback_data="admin_finance_by_category"),
                         InlineKeyboardButton("� Period Report", callback_data="admin_finance_period")],
                        [InlineKeyboardButton("📸 Proof Gallery", callback_data="admin_finance_gallery")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="dashboard")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Restaurant department (id=7) - show task statistics
                elif dept_id == "7":
                    from database import get_department_task_stats
                    stats = get_department_task_stats(self.db, 'Restaurant', 'daily')
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    text = f"🍽️ {get_dept_display('Restaurant', lang)} - {get_text('task_overview', lang)}\n\n"
                    text += f"📅 {stats['period_label']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"{get_text('total_tasks', lang)}: {stats['total']}\n"
                    text += f"   ├─ {get_text('tasks_pending', lang)}: {stats['pending']}\n"
                    text += f"   ├─ {get_text('tasks_in_progress', lang)}: {stats['accepted']}\n"
                    text += f"   └─ {get_text('tasks_completed', lang)}: {stats['completed']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    
                    if stats['tasks']:
                        text += f"\n{get_text('recent_tasks', lang)}\n"
                        for task in stats['tasks'][:5]:
                            status_emoji = {'Pending': '⏳', 'Accepted': '🔄', 'Completed': '✅'}.get(task['status'], '❓')
                            text += f"{status_emoji} #{task['id']} {task['assignee']}: {task['description']}\n"
                    
                    keyboard = [
                        [
                            InlineKeyboardButton(f"📅 {get_text('today', lang)}", callback_data="dept_stats_7_daily"),
                            InlineKeyboardButton(f"📆 {get_text('week', lang)}", callback_data="dept_stats_7_weekly"),
                            InlineKeyboardButton(f"🗓️ {get_text('month', lang)}", callback_data="dept_stats_7_monthly")
                        ],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="dashboard")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Transportation department (id=10) - show task statistics
                elif dept_id == "10":
                    from database import get_department_task_stats
                    stats = get_department_task_stats(self.db, 'Transportation', 'daily')
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    text = f"🚗 {get_dept_display('Transportation', lang)} - {get_text('task_overview', lang)}\n\n"
                    text += f"📅 {stats['period_label']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"{get_text('total_tasks', lang)}: {stats['total']}\n"
                    text += f"   ├─ {get_text('tasks_pending', lang)}: {stats['pending']}\n"
                    text += f"   ├─ {get_text('tasks_in_progress', lang)}: {stats['accepted']}\n"
                    text += f"   └─ {get_text('tasks_completed', lang)}: {stats['completed']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    
                    if stats['tasks']:
                        text += f"\n{get_text('recent_tasks', lang)}\n"
                        for task in stats['tasks'][:5]:
                            status_emoji = {'Pending': '⏳', 'Accepted': '🔄', 'Completed': '✅'}.get(task['status'], '❓')
                            text += f"{status_emoji} #{task['id']} {task['assignee']}: {task['description']}\n"
                    
                    keyboard = [
                        [
                            InlineKeyboardButton(f"📅 {get_text('today', lang)}", callback_data="dept_stats_10_daily"),
                            InlineKeyboardButton(f"📆 {get_text('week', lang)}", callback_data="dept_stats_10_weekly"),
                            InlineKeyboardButton(f"🗓️ {get_text('month', lang)}", callback_data="dept_stats_10_monthly")
                        ],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="dashboard")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Laundry/Waskamer department (id=11) - show task statistics
                elif dept_id == "11":
                    from database import get_department_task_stats
                    stats = get_department_task_stats(self.db, 'Laundry', 'daily')
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    text = f"🧺 {get_dept_display('Laundry', lang)} - {get_text('task_overview', lang)}\n\n"
                    text += f"📅 {stats['period_label']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"{get_text('total_tasks', lang)}: {stats['total']}\n"
                    text += f"   ├─ {get_text('tasks_pending', lang)}: {stats['pending']}\n"
                    text += f"   ├─ {get_text('tasks_in_progress', lang)}: {stats['accepted']}\n"
                    text += f"   └─ {get_text('tasks_completed', lang)}: {stats['completed']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    
                    if stats['tasks']:
                        text += f"\n{get_text('recent_tasks', lang)}\n"
                        for task in stats['tasks'][:5]:
                            status_emoji = {'Pending': '⏳', 'Accepted': '🔄', 'Completed': '✅'}.get(task['status'], '❓')
                            text += f"{status_emoji} #{task['id']} {task['assignee']}: {task['description']}\n"
                    
                    keyboard = [
                        [
                            InlineKeyboardButton(f"📅 {get_text('today', lang)}", callback_data="dept_stats_11_daily"),
                            InlineKeyboardButton(f"📆 {get_text('week', lang)}", callback_data="dept_stats_11_weekly"),
                            InlineKeyboardButton(f"🗓️ {get_text('month', lang)}", callback_data="dept_stats_11_monthly")
                        ],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="dashboard")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Technical department (id=5) - show repair statistics
                elif dept_id == "5":
                    from database import get_repair_task_stats
                    stats = get_repair_task_stats(self.db, 'daily')
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    text = f"🔧 {get_dept_display('Technical', lang)} - {get_text('overview', lang)}\n\n"
                    text += f"📅 {stats['period_label']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"{get_text('total_repairs', lang)}: {stats['total']}\n"
                    text += f"   ├─ {get_text('tasks_pending', lang)}: {stats['pending']}\n"
                    text += f"   ├─ {get_text('tasks_in_progress', lang)}: {stats['accepted']}\n"
                    text += f"   └─ {get_text('tasks_completed', lang)}: {stats['completed']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    
                    if stats['tasks']:
                        text += f"\n{get_text('recent_tasks', lang)}\n"
                        for task in stats['tasks'][:5]:
                            status_emoji = {'Pending': '⏳', 'Accepted': '🔄', 'Completed': '✅'}.get(task['status'], '❓')
                            text += f"{status_emoji} #{task['id']} {task['assignee']}: {task['description']}\n"
                    
                    keyboard = [
                        [
                            InlineKeyboardButton(f"📅 {get_text('today', lang)}", callback_data="dept_stats_5_daily"),
                            InlineKeyboardButton(f"📆 {get_text('week', lang)}", callback_data="dept_stats_5_weekly"),
                            InlineKeyboardButton(f"🗓️ {get_text('month', lang)}", callback_data="dept_stats_5_monthly")
                        ],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="dashboard")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                
                else:
                    await query.edit_message_text(f"📂 {get_text('department_id', lang)}: {dept_id}\n\n{get_text('feature_coming_soon', lang)}\n\n{get_text('press_admin_return', lang)}")
            
            elif query.data.startswith("amenity_"):
                # Handle amenity selection - show status per room with pagination
                parts = query.data.replace("amenity_", "").split("_page_")
                amenity = parts[0]
                page = int(parts[1]) if len(parts) > 1 else 1
                
                rooms = self.db.get_rooms_by_amenity(amenity)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not rooms:
                    await query.edit_message_text(get_text('no_rooms_found', lang))
                    return
                
                # Pagination settings - 20 rooms per page
                items_per_page = 20
                total_pages = (len(rooms) + items_per_page - 1) // items_per_page if rooms else 1
                page = max(1, min(page, total_pages))
                
                start_idx = (page - 1) * items_per_page
                end_idx = min(start_idx + items_per_page, len(rooms))
                page_rooms = rooms[start_idx:end_idx]
                
                # Display amenity name
                amenity_display = amenity.replace("_", " ")
                
                # Generate status text per room
                status_text = f"🔧 {amenity_display} 🏨 Status (Page {page}/{total_pages})\n\n"
                
                for room_id, id_room, status in page_rooms:
                    status_emoji = "✅✅" if str(status) == "1" else "❌❌"
                    status_word = get_text('good_condition', lang) if str(status) == "1" else get_text('bad_condition', lang)
                    status_text += f"🚪 {id_room}: {status_emoji} {status_word}\n"
                
                keyboard = []
                
                # Add pagination navigation
                if total_pages > 1:
                    nav_row = []
                    if page > 1:
                        nav_row.append(InlineKeyboardButton("⬅️ Prev", callback_data=f"amenity_{amenity}_page_{page-1}"))
                    nav_row.append(InlineKeyboardButton(f"📄 {page}/{total_pages}", callback_data="noop"))
                    if page < total_pages:
                        nav_row.append(InlineKeyboardButton("Next ➡️", callback_data=f"amenity_{amenity}_page_{page+1}"))
                    keyboard.append(nav_row)
                
                keyboard.append([InlineKeyboardButton(get_text('back_to_housekeeping', lang), callback_data="dept_3")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(status_text, reply_markup=reply_markup)
            
            elif query.data == "accounting_main":
                # Return to Accounting main
                summary = self.db.get_accounting_summary()
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not summary:
                    await query.edit_message_text(f"💰 {get_dept_display('Accounting', lang)}\n\n{get_text('no_data', lang)}")
                    return
                
                max_val = max(summary['avg_room'], summary['avg_food'], summary['avg_purchase'], summary['avg_utilities'], 1)
                
                def make_bar(value, max_value, width=10):
                    filled = int((value / max_value) * width) if max_value > 0 else 0
                    return "█" * filled + "░" * (width - filled)
                
                summary_text = f"""💰 {get_dept_display('Accounting', lang)} - {get_text('accounting_overview', lang)}

📊 {get_text('daily_avg_income', lang)}:
┌─────────────────────────────┐
│ 🏨 {get_text('rooms', lang)}:     ${summary['avg_room']:,}
│ {make_bar(summary['avg_room'], max_val)}
│
│ 🍽️ {get_text('food', lang)}:    ${summary['avg_food']:,}
│ {make_bar(summary['avg_food'], max_val)}
│
│ 📦 {get_text('purchase', lang)}:  ${summary['avg_purchase']:,}
│ {make_bar(summary['avg_purchase'], max_val)}
│
│ ⚡ {get_text('utilities', lang)}:   ${summary['avg_utilities']:,}
│ {make_bar(summary['avg_utilities'], max_val)}
└─────────────────────────────┘

📈 {get_text('overview', lang)}:
• {get_text('total_days', lang)}: {summary['total_days']}
• {get_text('daily_avg', lang)}: ${summary['avg_total']:,}
• {get_text('total', lang)}: ${summary['sum_total']:,}

{get_text('select_period_details', lang)}"""
                
                keyboard = [
                    [InlineKeyboardButton(f"📅 {get_text('weekly', lang)}", callback_data="acc_weekly"),
                     InlineKeyboardButton(f"📆 {get_text('monthly', lang)}", callback_data="acc_monthly")],
                    [InlineKeyboardButton(f"📊 {get_text('all_data', lang)}", callback_data="acc_all")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="dashboard")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(summary_text, reply_markup=reply_markup)
            
            elif query.data.startswith("acc_"):
                # Show accounting data by period
                period = query.data.replace("acc_", "")
                data = self.db.get_accounting_by_period(period)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not data:
                    await query.edit_message_text(f"💰 {get_dept_display('Accounting', lang)} - {period.title()}\n\n{get_text('no_data', lang)}")
                    return
                
                period_names = {'weekly': get_text('last_7_days', lang), 'monthly': get_text('last_30_days', lang), 'all': get_text('all_data', lang)}
                
                summary_text = f"💰 {get_dept_display('Accounting', lang)} - {period_names.get(period, period.title())}\n\n"
                summary_text += f"📅 {get_text('date', lang)}       💵 {get_text('total', lang)}\n"
                summary_text += "─" * 25 + "\n"
                
                keyboard = []
                for row in data:
                    acc_id, date, room, food, purchase, utilities, total = row
                    summary_text += f"📆 {date}: ${total:,}\n"
                    keyboard.append([InlineKeyboardButton(f"📅 {date} - ${total:,}", callback_data=f"accdet_{acc_id}")])
                
                keyboard.append([InlineKeyboardButton(get_text('back_to_accounting', lang), callback_data="accounting_main")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(summary_text, reply_markup=reply_markup)
            
            elif query.data.startswith("accdet_"):
                # Show accounting detail
                acc_id = int(query.data.replace("accdet_", ""))
                detail = self.db.get_accounting_detail(acc_id)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not detail:
                    await query.edit_message_text(get_text('accounting_details_not_found', lang))
                    return
                
                acc_id, date, room, food, purchase, utilities, total = detail
                
                # Calculate revenue/expenses
                revenue = room + food + purchase
                expenses = utilities
                profit = revenue - expenses
                profit_emoji = "📈" if profit >= 0 else "📉"
                
                detail_text = f"""💰 {get_text('financial_report', lang)} - {date}

┌─────────────────────────────┐
│ 📊 {get_text('income', lang)}
├─────────────────────────────┤
│ 🏨 {get_text('rooms', lang)}:     ${room:,}
│ 🍽️ {get_text('food', lang)}:       ${food:,}
│ 📦 {get_text('purchase', lang)}:  ${purchase:,}
├─────────────────────────────┤
│ 💵 {get_text('total', lang)} {get_text('income', lang)}:      ${revenue:,}
└─────────────────────────────┘

┌─────────────────────────────┐
│ 📊 {get_text('expenses', lang)}
├─────────────────────────────┤
│ ⚡ {get_text('utilities', lang)}:            ${utilities:,}
└─────────────────────────────┘

{profit_emoji} {get_text('profit', lang) if profit >= 0 else get_text('loss', lang)}: ${abs(profit):,}
📊 {get_text('total', lang)}: ${total:,}"""
                
                keyboard = [
                    [InlineKeyboardButton(get_text('back', lang), callback_data="accounting_main")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(detail_text, reply_markup=reply_markup)
            
            elif query.data == "back_to_admin":
                # Return to admin main menu
                lang = get_user_language(telegram_user_id, self.db)
                employee_info = self.db.get_employee_info(telegram_user_id)
                if employee_info:
                    employee_id = employee_info['employee_id']
                    name = employee_info['name']
                    department = employee_info['department']
                    dept_display = get_dept_display(department, lang)
                    
                    # Check pending reports
                    pending_reports = self.db.get_pending_admin_reports()
                    
                    welcome_text = f"""{get_text('welcome_admin', lang)}

{get_text('you_are_first_employee', lang)}
{get_text('auto_assigned_management', lang)}

{get_text('your_info', lang)}
• {get_text('name', lang)}: {name}
• {get_text('employee_id', lang)}: {employee_id}
• {get_text('department', lang)}: {dept_display} (Admin)
• {get_text('telegram_id', lang)}: {telegram_user_id}

{get_text('now_full_access', lang)}
        """
                    if pending_reports:
                        welcome_text += f"\n{get_text('pending_reports', lang).format(len(pending_reports))}"
                    
                    # Get pending complaints count
                    pending_complaints = self.db.get_unconfirmed_complaints()
                    if pending_complaints:
                        welcome_text += f"\n{get_text('pending_complaints', lang).format(pending_complaints)}"
                    
                    # Check AI status from database
                    hotel_settings = self.db.get_hotel_settings()
                    ai_enabled = hotel_settings.get('ai_analysis_enabled', False)
                    ai_button_text = get_text('ai_analysis', lang) if ai_enabled else f"🔒 {get_text('ai_analysis', lang)}"
                    
                    # Improved button layout - 2 columns for better UX
                    keyboard = [
                        [InlineKeyboardButton(get_text('dashboard', lang), callback_data="dashboard"),
                         InlineKeyboardButton(get_text('actions', lang), callback_data="actions")],
                        [InlineKeyboardButton(get_text('reports_pending_count', lang).format(len(pending_reports)) if pending_reports else get_text('reports_pending', lang), callback_data="admin_pending_reports"),
                         InlineKeyboardButton(get_text('complaints_pending_count', lang).format(pending_complaints) if pending_complaints else get_text('complaints_pending', lang), callback_data="admin_complaints")],
                        [InlineKeyboardButton(ai_button_text, callback_data="ai_analysis_menu")],
                        [InlineKeyboardButton(get_text('settings', lang), callback_data="settings"),
                         InlineKeyboardButton(get_text('information', lang), callback_data="information")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(welcome_text, reply_markup=reply_markup)
            
            elif query.data == "actions":
                # Get user language
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get admin action list
                actions = self.db.get_admin_actions()
                
                if not actions:
                    await query.edit_message_text(f"{get_text('actions', lang)}\n\n{get_text('no_records', lang)}")
                    return
                
                # Improved button layout - 2 columns for better UX
                keyboard = [
                    [InlineKeyboardButton(get_text('create_task', lang), callback_data="action_1"),
                     InlineKeyboardButton(get_text('room_management', lang), callback_data="action_2")],
                    [InlineKeyboardButton(get_text('reports', lang), callback_data="reports_menu"),
                     InlineKeyboardButton(get_text('employees', lang), callback_data="employees_menu")],
                    [InlineKeyboardButton(get_text('task_management', lang), callback_data="admin_manage_assignments"),
                     InlineKeyboardButton(get_text('complaints', lang), callback_data="action_6")],
                    [InlineKeyboardButton(get_text('office_management', lang), callback_data="admin_hotel_rooms"),
                     InlineKeyboardButton(f"🔧 {get_text('tool_management', lang)}", callback_data="admin_tools")],
                    [InlineKeyboardButton(f"🚗 {get_text('transportation_management', lang)}", callback_data="admin_transport"),
                     InlineKeyboardButton(f"📦 {get_text('storage_management', lang)}", callback_data="admin_storage")],
                    [InlineKeyboardButton(get_text('event_management', lang), callback_data="admin_events"),
                     InlineKeyboardButton(f"📋 {get_text('shift_reports', lang)}", callback_data="admin_shift_reports")],
                    [InlineKeyboardButton("💎 Finance Dashboard", callback_data="admin_finance_dashboard"),
                     InlineKeyboardButton("📧 Message Management", callback_data="message_management")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="back_to_admin")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                try:
                    await query.edit_message_text(f"{get_text('actions', lang)}\n\n{get_text('select_action', lang)}", reply_markup=reply_markup)
                except Exception:
                    # If edit fails (e.g., message has photo), delete and send new message
                    try:
                        await query.message.delete()
                    except:
                        pass
                    await self.application.bot.send_message(
                        chat_id=telegram_user_id,
                        text=f"{get_text('actions', lang)}\n\n{get_text('select_action', lang)}",
                        reply_markup=reply_markup
                    )
            
            # AI Analysis Menu
            elif query.data == "ai_analysis_menu":
                try:
                    from ai_analyzer import is_ai_enabled as is_openai_configured
                    
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    # Check if AI is enabled in hotel settings (database)
                    hotel_settings = self.db.get_hotel_settings()
                    ai_settings_enabled = hotel_settings.get('ai_analysis_enabled', False)
                    
                    # If AI is disabled in settings, block access
                    if not ai_settings_enabled:
                        await query.answer("⚠️ AI Analysis is disabled. Enable in Settings → AI Analysis Settings.", show_alert=True)
                        return
                    
                    openai_configured = is_openai_configured()
                    
                    # Both settings and OpenAI must be ready
                    ai_ready = ai_settings_enabled and openai_configured
                    
                    text = f"{get_text('ai_analysis_menu', lang)}\n\n"
                    
                    if not ai_settings_enabled:
                        status_text = get_text('ai_disabled', lang)
                        text += f"📊 Status: {status_text}\n\n"
                        text += f"⚠️ AI is disabled in Settings.\n"
                        text += f"Go to Settings → AI Analysis Settings to enable.\n"
                    elif not openai_configured:
                        status_text = get_text('ai_disabled', lang)
                        text += f"📊 Status: {status_text}\n\n"
                        text += f"⚠️ {get_text('ai_not_configured', lang)}\n"
                    else:
                        status_text = get_text('ai_enabled', lang)
                        text += f"📊 Status: {status_text}\n\n"
                        text += "Select a report to generate:\n"
                    
                    # Only show active buttons if AI is ready
                    if ai_ready:
                        keyboard = [
                            [InlineKeyboardButton(get_text('ai_daily_brief', lang), callback_data="ai_daily_brief")],
                            [InlineKeyboardButton(get_text('ai_department_report', lang), callback_data="ai_dept_report"),
                             InlineKeyboardButton(get_text('ai_anomaly_report', lang), callback_data="ai_anomaly_report")],
                            [InlineKeyboardButton(get_text('ai_performance_ranking', lang), callback_data="ai_performance_ranking"),
                             InlineKeyboardButton(get_text('ai_dept_comparison', lang), callback_data="ai_dept_comparison")],
                            [InlineKeyboardButton(get_text('back', lang), callback_data="back_to_admin")]
                        ]
                    else:
                        # Show disabled state - only back button
                        keyboard = [
                            [InlineKeyboardButton(f"🔒 {get_text('ai_daily_brief', lang)}", callback_data="ai_disabled_msg")],
                            [InlineKeyboardButton(f"🔒 {get_text('ai_department_report', lang)}", callback_data="ai_disabled_msg"),
                             InlineKeyboardButton(f"🔒 {get_text('ai_anomaly_report', lang)}", callback_data="ai_disabled_msg")],
                            [InlineKeyboardButton(f"🔒 {get_text('ai_performance_ranking', lang)}", callback_data="ai_disabled_msg"),
                             InlineKeyboardButton(f"🔒 {get_text('ai_dept_comparison', lang)}", callback_data="ai_disabled_msg")],
                            [InlineKeyboardButton(get_text('back', lang), callback_data="back_to_admin")]
                        ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                except Exception as e:
                    import traceback
                    traceback.print_exc()
                    await query.answer(f"Error: {str(e)[:100]}", show_alert=True)
            
            # AI Disabled Message
            elif query.data == "ai_disabled_msg":
                lang = get_user_language(telegram_user_id, self.db)
                await query.answer("⚠️ AI is disabled. Enable it in Settings → AI Analysis Settings.", show_alert=True)
            
            # AI Daily Brief
            elif query.data == "ai_daily_brief":
                from ai_analyzer import DailyBriefGenerator, is_ai_enabled
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not is_ai_enabled():
                    await query.edit_message_text(
                        f"⚠️ {get_text('ai_not_configured', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                        ]])
                    )
                    return
                
                # Show generating message
                await query.edit_message_text(f"⏳ {get_text('ai_generating', lang)}")
                
                try:
                    generator = DailyBriefGenerator()
                    report = await generator.generate_daily_brief(self.db, 1, lang)
                    
                    if report:
                        # Split long messages if needed (Telegram limit is 4096)
                        if len(report) > 4000:
                            report = report[:3990] + "..."
                        
                        await query.edit_message_text(
                            f"{get_text('ai_brief_title', lang)}\n\n{report}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                            ]])
                        )
                    else:
                        await query.edit_message_text(
                            f"❌ {get_text('ai_error', lang)}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                            ]])
                        )
                except Exception as e:
                    print(f"AI Daily Brief error: {e}")
                    await query.edit_message_text(
                        f"❌ {get_text('ai_error', lang)}\n\nError: {str(e)[:100]}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                        ]])
                    )
            
            # AI Anomaly Report
            elif query.data == "ai_anomaly_report":
                from ai_analyzer import DailyBriefGenerator, is_ai_enabled
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not is_ai_enabled():
                    await query.edit_message_text(
                        f"⚠️ {get_text('ai_not_configured', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                        ]])
                    )
                    return
                
                await query.edit_message_text(f"⏳ {get_text('ai_generating', lang)}")
                
                try:
                    generator = DailyBriefGenerator()
                    report = await generator.generate_anomaly_report(self.db, 1, lang)
                    
                    if report:
                        if len(report) > 4000:
                            report = report[:3990] + "..."
                        
                        await query.edit_message_text(
                            f"{get_text('ai_anomaly_title', lang)}\n\n{report}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                            ]])
                        )
                    else:
                        await query.edit_message_text(
                            f"❌ {get_text('ai_error', lang)}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                            ]])
                        )
                except Exception as e:
                    print(f"AI Anomaly Report error: {e}")
                    await query.edit_message_text(
                        f"❌ {get_text('ai_error', lang)}\n\nError: {str(e)[:100]}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                        ]])
                    )
            
            # AI Performance Ranking
            elif query.data == "ai_performance_ranking":
                from ai_analyzer import DailyBriefGenerator, is_ai_enabled
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not is_ai_enabled():
                    await query.edit_message_text(
                        f"⚠️ {get_text('ai_not_configured', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                        ]])
                    )
                    return
                
                await query.edit_message_text(f"⏳ {get_text('ai_generating', lang)}")
                
                try:
                    generator = DailyBriefGenerator()
                    report = await generator.generate_performance_ranking(self.db, lang=lang)
                    
                    if report:
                        if len(report) > 4000:
                            report = report[:3990] + "..."
                        
                        await query.edit_message_text(
                            f"🏆 {get_text('ai_performance_title', lang)}\n\n{report}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                            ]])
                        )
                    else:
                        await query.edit_message_text(
                            f"❌ {get_text('ai_error', lang)}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                            ]])
                        )
                except Exception as e:
                    print(f"AI Performance Ranking error: {e}")
                    await query.edit_message_text(
                        f"❌ {get_text('ai_error', lang)}\n\nError: {str(e)[:100]}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                        ]])
                    )
            
            # AI Department Comparison
            elif query.data == "ai_dept_comparison":
                from ai_analyzer import DailyBriefGenerator, is_ai_enabled
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not is_ai_enabled():
                    await query.edit_message_text(
                        f"⚠️ {get_text('ai_not_configured', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                        ]])
                    )
                    return
                
                await query.edit_message_text(f"⏳ {get_text('ai_generating', lang)}")
                
                try:
                    generator = DailyBriefGenerator()
                    report = await generator.generate_department_comparison(self.db, lang=lang)
                    
                    if report:
                        if len(report) > 4000:
                            report = report[:3990] + "..."
                        
                        await query.edit_message_text(
                            f"📊 {get_text('ai_comparison_title', lang)}\n\n{report}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                            ]])
                        )
                    else:
                        await query.edit_message_text(
                            f"❌ {get_text('ai_error', lang)}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                            ]])
                        )
                except Exception as e:
                    print(f"AI Department Comparison error: {e}")
                    await query.edit_message_text(
                        f"❌ {get_text('ai_error', lang)}\n\nError: {str(e)[:100]}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                        ]])
                    )
            
            # AI Department Report - Select department
            elif query.data == "ai_dept_report":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get list of departments
                departments = self.db.get_departments()
                
                if not departments:
                    await query.edit_message_text(
                        f"❌ No departments found.",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                        ]])
                    )
                    return
                
                keyboard = []
                for dept in departments[:10]:  # Limit to 10 departments
                    # dept is tuple: (id, name, content)
                    dept_name = str(dept[1]) if isinstance(dept, (list, tuple)) else str(dept)
                    keyboard.append([InlineKeyboardButton(dept_name, callback_data=f"ai_dept_{dept_name}")])
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")])
                
                await query.edit_message_text(
                    f"{get_text('select_department', lang)}",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            
            # AI Department Report - Generate for selected department
            elif query.data.startswith("ai_dept_"):
                from ai_analyzer import DailyBriefGenerator, is_ai_enabled
                
                lang = get_user_language(telegram_user_id, self.db)
                department = query.data.replace("ai_dept_", "")
                
                if not is_ai_enabled():
                    await query.edit_message_text(
                        f"⚠️ {get_text('ai_not_configured', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                        ]])
                    )
                    return
                
                await query.edit_message_text(f"⏳ {get_text('ai_generating', lang)}")
                
                try:
                    generator = DailyBriefGenerator()
                    report = await generator.generate_department_report(self.db, 1, department, lang)
                    
                    if report:
                        if len(report) > 4000:
                            report = report[:3990] + "..."
                        
                        await query.edit_message_text(
                            f"{get_text('ai_dept_title', lang)}: {department}\n\n{report}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="ai_dept_report")
                            ]])
                        )
                    else:
                        await query.edit_message_text(
                            f"❌ {get_text('ai_error', lang)}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                            ]])
                        )
                except Exception as e:
                    print(f"AI Department Report error: {e}")
                    await query.edit_message_text(
                        f"❌ {get_text('ai_error', lang)}\n\nError: {str(e)[:100]}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="ai_analysis_menu")
                        ]])
                    )
            
            # ==================== ADMIN SHIFT REPORTS ====================
            
            # Admin Shift Reports Menu
            elif query.data == "admin_shift_reports":
                from database import get_pending_shift_reports, get_shift_reports
                from collections import defaultdict
                from datetime import datetime
                
                lang = get_user_language(telegram_user_id, self.db)
                pending_reports = get_pending_shift_reports(self.db)
                
                text = f"📋 {get_text('shift_reports', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"📊 Total {len(pending_reports)} pending reports\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                keyboard = []
                
                if pending_reports:
                    # Group by date
                    reports_by_date = defaultdict(list)
                    for report in pending_reports:
                        date = report.get('shift_date', 'Unknown')
                        reports_by_date[date].append(report)
                    
                    # Sort by date (newest first)
                    sorted_dates = sorted(reports_by_date.keys(), reverse=True)
                    
                    for date in sorted_dates[:5]:  # Recent 5 days
                        date_reports = reports_by_date[date]
                        text += f"📅 **{date}** ({len(date_reports)} reports)\n"
                        
                        # Sort by time
                        date_reports.sort(key=lambda x: x.get('submitted_at', ''), reverse=True)
                        
                        for report in date_reports[:5]:  # Max 5 per date
                            shift_num = report.get('shift_number', 1)
                            emp_name = report.get('employee_name', 'Unknown')
                            submitted = report.get('submitted_at', '')
                            
                            # Extract time only (HH:MM)
                            time_str = ''
                            if submitted:
                                try:
                                    # Check if it's a datetime object
                                    from datetime import datetime
                                    if isinstance(submitted, datetime):
                                        time_str = submitted.strftime('%H:%M')
                                    elif isinstance(submitted, str):
                                        if 'T' in submitted:
                                            time_str = submitted.split('T')[1][:5]
                                        elif ' ' in submitted:
                                            time_str = submitted.split(' ')[1][:5]
                                        else:
                                            time_str = submitted[:5]
                                except:
                                    time_str = ''
                            
                            shift_icon = '🌅' if shift_num == 1 else ('🌆' if shift_num == 2 else '🌙')
                            text += f"  {shift_icon} {time_str} - Shift {shift_num} - {emp_name}\n"
                            
                            keyboard.append([InlineKeyboardButton(
                                f"{shift_icon} {time_str} | Shift {shift_num} - {emp_name}",
                                callback_data=f"view_shift_report_{report['id']}"
                            )])
                        
                        text += "\n"
                else:
                    text += f"✅ {get_text('no_pending_reports', lang)}\n\n"
                
                # Add filter buttons
                keyboard.append([
                    InlineKeyboardButton("� By Date", callback_data="shift_reports_by_date"),
                    InlineKeyboardButton("📜 All Reports", callback_data="all_shift_reports")
                ])
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="actions")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
            # View Single Shift Report
            elif query.data.startswith("view_shift_report_"):
                from database import get_shift_report_by_id
                
                lang = get_user_language(telegram_user_id, self.db)
                report_id = int(query.data.replace("view_shift_report_", ""))
                report = get_shift_report_by_id(self.db, report_id)
                
                if not report:
                    await query.answer("❌ Report not found", show_alert=True)
                    return
                
                text = f"📋 {get_text('shift_report_detail', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"🕐 Shift: {report.get('shift_number', 'N/A')}\n"
                text += f"👤 {get_text('employee', lang)}: {report.get('employee_name', 'N/A')}\n"
                text += f"📅 {get_text('date', lang)}: {report.get('shift_date', 'N/A')}\n"
                text += f"📊 {get_text('status', lang)}: {report.get('status', 'N/A')}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                text += f"📊 {get_text('reservations', lang)}: {report.get('reservations_count', 0)}\n"
                text += f"🛬 {get_text('arrivals', lang)}: {report.get('arrivals_count', 0)}\n"
                text += f"🛫 {get_text('departures', lang)}: {report.get('departures_count', 0)}\n"
                text += f"💵 {get_text('cash', lang)}: ${report.get('cash_amount', 0)}\n"
                
                if report.get('issues_notes'):
                    text += f"\n⚠️ {get_text('issues', lang)}:\n{report.get('issues_notes')}\n"
                
                if report.get('store_stock_notes'):
                    text += f"\n📦 {get_text('stock_notes', lang)}:\n{report.get('store_stock_notes')}\n"
                
                if report.get('key_log_notes'):
                    text += f"\n🔑 {get_text('key_notes', lang)}:\n{report.get('key_log_notes')}\n"
                
                if report.get('additional_notes'):
                    text += f"\n📝 {get_text('notes', lang)}:\n{report.get('additional_notes')}\n"
                
                keyboard = []
                
                # Show photos if available
                if report.get('cash_photo'):
                    keyboard.append([InlineKeyboardButton(f"📷 {get_text('view_cash_photo', lang)}", callback_data=f"shift_cash_photo_{report_id}")])
                
                if report.get('pos_report_photo'):
                    keyboard.append([InlineKeyboardButton(f"📷 {get_text('view_pos_photo', lang)}", callback_data=f"shift_pos_photo_{report_id}")])
                
                # Confirm button if pending
                if report.get('status') == 'submitted':
                    keyboard.append([InlineKeyboardButton(f"✅ {get_text('confirm_report', lang)}", callback_data=f"confirm_shift_report_{report_id}")])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_shift_reports")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # View Cash Photo
            elif query.data.startswith("shift_cash_photo_"):
                from database import get_shift_report_by_id
                
                report_id = int(query.data.replace("shift_cash_photo_", ""))
                report = get_shift_report_by_id(self.db, report_id)
                
                cash_photo = report.get('cash_photo') if report else None
                if cash_photo and len(cash_photo.strip()) > 0:
                    try:
                        await self.application.bot.send_photo(
                            chat_id=telegram_user_id,
                            photo=cash_photo,
                            caption=f"💵 Cash Photo - Shift {report.get('shift_number')} - {report.get('employee_name')}"
                        )
                    except Exception as e:
                        print(f"❌ Failed to send cash photo: {e}")
                        await query.answer("❌ Failed to load photo", show_alert=True)
                else:
                    await query.answer("❌ Photo not found", show_alert=True)
            
            # View POS Photo
            elif query.data.startswith("shift_pos_photo_"):
                from database import get_shift_report_by_id
                
                report_id = int(query.data.replace("shift_pos_photo_", ""))
                report = get_shift_report_by_id(self.db, report_id)
                
                pos_photo = report.get('pos_report_photo') if report else None
                if pos_photo and len(pos_photo.strip()) > 0:
                    try:
                        await self.application.bot.send_photo(
                            chat_id=telegram_user_id,
                            photo=pos_photo,
                            caption=f"📊 POS Report - Shift {report.get('shift_number')} - {report.get('employee_name')}"
                        )
                    except Exception as e:
                        print(f"Failed to send POS photo: {e}")
                        await query.answer("❌ Failed to load photo", show_alert=True)
                else:
                    await query.answer("❌ Photo not found", show_alert=True)
            
            # Confirm Shift Report
            elif query.data.startswith("confirm_shift_report_"):
                from database import confirm_shift_report, get_shift_report_by_id
                
                lang = get_user_language(telegram_user_id, self.db)
                report_id = int(query.data.replace("confirm_shift_report_", ""))
                
                if confirm_shift_report(self.db, report_id, telegram_user_id):
                    report = get_shift_report_by_id(self.db, report_id)
                    await query.answer(f"✅ {get_text('report_confirmed', lang)}", show_alert=True)
                    
                    # Notify the employee
                    if report:
                        try:
                            emp_info = self.db.get_employee_by_id(report.get('employee_id'))
                            if emp_info and emp_info.get('telegram_user_id'):
                                await self.application.bot.send_message(
                                    chat_id=emp_info['telegram_user_id'],
                                    text=f"✅ {get_text('your_shift_report_confirmed', lang)}\n\nShift {report.get('shift_number')} - {report.get('shift_date')}"
                                )
                        except:
                            pass
                    
                    # Return to shift reports list
                    from database import get_pending_shift_reports
                    pending_reports = get_pending_shift_reports(self.db)
                    
                    text = f"📋 {get_text('shift_reports', lang)}\n\n"
                    text += f"✅ {get_text('report_confirmed', lang)}!\n\n"
                    text += f"📊 {get_text('pending_reports', lang).format(len(pending_reports))}\n"
                    
                    keyboard = []
                    for rpt in pending_reports[:10]:
                        keyboard.append([InlineKeyboardButton(
                            f"📋 Shift {rpt.get('shift_number')} - {rpt.get('employee_name')}",
                            callback_data=f"view_shift_report_{rpt['id']}"
                        )])
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="actions")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("❌ Error confirming report", show_alert=True)
            
            # All Shift Reports (History)
            elif query.data == "all_shift_reports":
                from database import get_shift_reports
                
                lang = get_user_language(telegram_user_id, self.db)
                reports = get_shift_reports(self.db, limit=20)
                
                text = f"📜 {get_text('all_shift_reports', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = []
                if reports:
                    for row in reports:
                        # row is a tuple, parse it
                        report_id = row[0]
                        shift_num = row[1] if len(row) > 1 else 1
                        emp_name = row[3] if len(row) > 3 else 'Unknown'
                        status = row[-2] if len(row) > 2 else 'unknown'
                        status_icon = "✅" if status == 'confirmed' else "⏳"
                        
                        keyboard.append([InlineKeyboardButton(
                            f"{status_icon} Shift {shift_num} - {emp_name}",
                            callback_data=f"view_shift_report_{report_id}"
                        )])
                else:
                    text += f"{get_text('no_reports_found', lang)}\n"
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_shift_reports")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Shift Reports by Date
            elif query.data == "shift_reports_by_date":
                from database import get_shift_reports
                from collections import defaultdict
                
                lang = get_user_language(telegram_user_id, self.db)
                all_reports = get_shift_reports(self.db, limit=50)
                
                text = "📅 **Shift Reports - By Date**\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                # Group by date
                reports_by_date = defaultdict(lambda: {'confirmed': 0, 'pending': 0, 'reports': []})
                
                for row in all_reports:
                    report_id = row[0]
                    shift_num = row[1] if len(row) > 1 else 1
                    date = row[2] if len(row) > 2 else 'Unknown'
                    emp_name = row[3] if len(row) > 3 else 'Unknown'
                    status = row[-2] if len(row) > 2 else 'submitted'
                    
                    reports_by_date[date]['reports'].append({
                        'id': report_id,
                        'shift_num': shift_num,
                        'emp_name': emp_name,
                        'status': status
                    })
                    
                    if status == 'confirmed':
                        reports_by_date[date]['confirmed'] += 1
                    else:
                        reports_by_date[date]['pending'] += 1
                
                # Sort by date (newest first)
                sorted_dates = sorted(reports_by_date.keys(), reverse=True)
                
                keyboard = []
                
                for date in sorted_dates[:10]:  # Recent 10 days
                    date_data = reports_by_date[date]
                    total = len(date_data['reports'])
                    confirmed = date_data['confirmed']
                    pending = date_data['pending']
                    
                    text += f"📅 **{date}**\n"
                    text += f"   Total {total} (✅ {confirmed} confirmed, ⏳ {pending} pending)\n\n"
                    
                    # Date selection button
                    keyboard.append([InlineKeyboardButton(
                        f"📅 {date} ({total} reports)",
                        callback_data=f"view_date_reports_{date}"
                    )])
                
                if not sorted_dates:
                    text += "No reports found.\n"
                
                keyboard.append([InlineKeyboardButton("🔙 Back", callback_data="admin_shift_reports")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
            # View reports for a specific date
            elif query.data.startswith("view_date_reports_"):
                from database import get_shift_reports_by_date
                
                lang = get_user_language(telegram_user_id, self.db)
                date = query.data.replace("view_date_reports_", "")
                
                # Get reports for this date
                reports = get_shift_reports_by_date(self.db, date)
                
                text = f"📅 **Shift Reports - {date}**\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                keyboard = []
                
                if reports:
                    # Sort by time
                    reports_sorted = sorted(reports, key=lambda x: x.get('submitted_at', ''))
                    
                    for report in reports_sorted:
                        shift_num = report.get('shift_number', 1)
                        emp_name = report.get('employee_name', 'Unknown')
                        status = report.get('status', 'submitted')
                        submitted = report.get('submitted_at', '')
                        
                        # Extract time
                        time_str = ''
                        if submitted:
                            try:
                                if 'T' in submitted:
                                    time_str = submitted.split('T')[1][:5]
                                elif ' ' in submitted:
                                    time_str = submitted.split(' ')[1][:5]
                            except:
                                pass
                        
                        status_icon = "✅" if status == 'confirmed' else "⏳"
                        shift_icon = '🌅' if shift_num == 1 else ('🌆' if shift_num == 2 else '🌙')
                        
                        text += f"{status_icon} {shift_icon} **{time_str}** - Shift {shift_num}\n"
                        text += f"   👤 {emp_name}\n\n"
                        
                        keyboard.append([InlineKeyboardButton(
                            f"{status_icon} {time_str} | {shift_icon} Shift {shift_num} - {emp_name}",
                            callback_data=f"view_shift_report_{report['id']}"
                        )])
                else:
                    text += "No reports found for this date.\n"
                
                keyboard.append([InlineKeyboardButton("🔙 Date List", callback_data="shift_reports_by_date")])
                keyboard.append([InlineKeyboardButton("🏠 Main Menu", callback_data="admin_shift_reports")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
            # ==================== ADMIN FINANCE DASHBOARD ====================
            
            # Admin Finance Dashboard - Main view
            elif query.data == "admin_finance_dashboard":
                from database import get_admin_finance_dashboard
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not self.db.check_admin(telegram_user_id):
                    await query.edit_message_text("❌ Admin access required.")
                    return
                
                dashboard = get_admin_finance_dashboard(self.db)
                
                if not dashboard:
                    await query.edit_message_text(
                        "❌ Unable to load finance dashboard.",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="actions")
                        ]])
                    )
                    return
                
                balances = dashboard['balances']
                today = dashboard['today']
                week = dashboard['week']
                month = dashboard['month']
                
                text = "💰 FINANCE DASHBOARD\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                # Current Balances
                text += "🏦 CURRENT BALANCES\n"
                text += f"   💵 Cash: {balances['cash_balance']:,.2f} RSD\n"
                text += f"   🏦 Bank: {balances['bank_balance']:,.2f} RSD\n"
                text += f"   💰 Total: {balances['total_balance']:,.2f} RSD\n\n"
                
                # Today's Summary
                text += "📅 TODAY'S ACTIVITY\n"
                text += f"   📈 Income: {today['income']:,.2f} RSD\n"
                text += f"   📉 Expense: {today['expense']:,.2f} RSD\n"
                text += f"   💹 Net: {today['income'] - today['expense']:,.2f} RSD\n"
                text += f"   📊 Transactions: {today['count']}\n\n"
                
                # This Week
                text += "📆 THIS WEEK\n"
                text += f"   📈 Income: {week['income']:,.2f} RSD\n"
                text += f"   📉 Expense: {week['expense']:,.2f} RSD\n"
                text += f"   📊 Transactions: {week['count']}\n\n"
                
                # This Month
                text += "🗓️ THIS MONTH\n"
                text += f"   📈 Income: {month['income']:,.2f} RSD\n"
                text += f"   📉 Expense: {month['expense']:,.2f} RSD\n"
                text += f"   📊 Transactions: {month['count']}\n\n"
                
                # Alerts
                if dashboard['no_proof_count'] > 0:
                    text += f"⚠️ ALERTS\n"
                    text += f"   📎 Transactions without proof: {dashboard['no_proof_count']}\n\n"
                
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                
                keyboard = [
                    [InlineKeyboardButton("📋 All Transactions", callback_data="admin_finance_transactions"),
                     InlineKeyboardButton("⚠️ Without Proof", callback_data="admin_finance_no_proof")],
                    [InlineKeyboardButton("📊 Category Report", callback_data="admin_finance_by_category"),
                     InlineKeyboardButton("📅 Period Report", callback_data="admin_finance_period")],
                    [InlineKeyboardButton("📸 Proof Gallery", callback_data="admin_finance_gallery")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="actions")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Finance - View All Transactions
            elif query.data == "admin_finance_transactions" or query.data.startswith("admin_finance_tx_page_"):
                from database import get_financial_transactions
                
                lang = get_user_language(telegram_user_id, self.db)
                
                page = 0
                if query.data.startswith("admin_finance_tx_page_"):
                    page = int(query.data.replace("admin_finance_tx_page_", ""))
                
                transactions = get_financial_transactions(self.db, period='month', limit=100)
                
                if not transactions:
                    await query.edit_message_text(
                        "📋 No transactions found.",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="admin_finance_dashboard")
                        ]])
                    )
                    return
                
                # Pagination
                per_page = 8
                start = page * per_page
                end = start + per_page
                page_txs = transactions[start:end]
                total_pages = (len(transactions) + per_page - 1) // per_page
                
                text = f"📋 ALL TRANSACTIONS ({len(transactions)})\n"
                text += f"Page {page + 1}/{total_pages}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                keyboard = []
                for tx in page_txs:
                    emoji = "📈" if tx['type'] == 'income' else "📉"
                    proof = "✅" if tx.get('has_proof') else "❌"
                    short_desc = tx['description'][:20] + "..." if len(tx['description']) > 20 else tx['description']
                    button_text = f"{emoji} #{tx['id']} - {tx['amount']:,.0f} RSD - {proof}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"admin_view_tx_{tx['id']}")])
                
                # Pagination buttons
                nav_row = []
                if page > 0:
                    nav_row.append(InlineKeyboardButton("⬅️ Prev", callback_data=f"admin_finance_tx_page_{page-1}"))
                if page < total_pages - 1:
                    nav_row.append(InlineKeyboardButton("➡️ Next", callback_data=f"admin_finance_tx_page_{page+1}"))
                if nav_row:
                    keyboard.append(nav_row)
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_finance_dashboard")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Finance - View Transaction Proof (MUST be before admin_view_tx_)
            elif query.data.startswith("admin_view_tx_proof_"):
                from database import get_transaction_detail
                
                lang = get_user_language(telegram_user_id, self.db)
                tx_id = int(query.data.replace("admin_view_tx_proof_", ""))
                
                tx = get_transaction_detail(self.db, tx_id)
                
                if not tx or not tx['attachment_file_id']:
                    await query.answer("❌ No proof attached", show_alert=True)
                    return
                
                caption = f"📎 Proof for Transaction #{tx_id}\n"
                caption += f"💰 {tx['amount']:,.2f} RSD - {tx['description'][:50]}"
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_view_tx_{tx_id}")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                try:
                    if tx['attachment_type'] == 'photo':
                        await query.message.delete()
                        await self.application.bot.send_photo(
                            chat_id=telegram_user_id,
                            photo=tx['attachment_file_id'],
                            caption=caption,
                            reply_markup=reply_markup
                        )
                    else:
                        await query.message.delete()
                        await self.application.bot.send_document(
                            chat_id=telegram_user_id,
                            document=tx['attachment_file_id'],
                            caption=caption,
                            reply_markup=reply_markup
                        )
                except Exception as e:
                    print(f"Error sending proof: {e}")
                    await query.answer("❌ Error viewing proof", show_alert=True)
            
            # Admin Finance - View Transaction Detail
            elif query.data.startswith("admin_view_tx_"):
                from database import get_transaction_detail
                
                lang = get_user_language(telegram_user_id, self.db)
                tx_id = int(query.data.replace("admin_view_tx_", ""))
                
                tx = get_transaction_detail(self.db, tx_id)
                
                if not tx:
                    await query.answer("❌ Transaction not found", show_alert=True)
                    return
                
                emoji = "📈" if tx['type'] == 'income' else "📉"
                text = f"{emoji} TRANSACTION #{tx['id']}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"📅 Date: {tx['date']}\n"
                text += f"📌 Type: {tx['type'].upper()}\n"
                text += f"📁 Category: {tx['category']}\n"
                text += f"💰 Amount: {tx['amount']:,.2f} RSD\n"
                text += f"💳 Payment: {tx['payment_method']}\n"
                text += f"📝 Description: {tx['description']}\n"
                text += f"👤 Recorded by: {tx['recorded_by_name']}\n"
                text += f"📎 Proof: {'✅ Attached' if tx['attachment_file_id'] else '❌ No proof'}\n"
                text += f"🕐 Created: {tx['created_at']}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                
                keyboard = []
                if tx['attachment_file_id']:
                    keyboard.append([InlineKeyboardButton("📎 View Proof", callback_data=f"admin_view_tx_proof_{tx_id}")])
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_finance_transactions")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                try:
                    await query.edit_message_text(text, reply_markup=reply_markup)
                except Exception:
                    try:
                        await query.message.delete()
                    except Exception:
                        pass
                    await context.bot.send_message(
                        chat_id=telegram_user_id,
                        text=text,
                        reply_markup=reply_markup
                    )
            
            # Admin Finance - Transactions without proof (with pagination)
            elif query.data == "admin_finance_no_proof" or query.data.startswith("admin_finance_no_proof_page_"):
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get page number
                page = 0
                if query.data.startswith("admin_finance_no_proof_page_"):
                    page = int(query.data.replace("admin_finance_no_proof_page_", ""))
                
                items_per_page = 10
                offset = page * items_per_page
                
                # Get total count
                self.db.cursor.execute("""
                    SELECT COUNT(*) FROM tbl_financial_transactions
                    WHERE attachment_file_id IS NULL
                """)
                total_count = self.db.cursor.fetchone()[0]
                total_pages = (total_count + items_per_page - 1) // items_per_page
                
                if total_count == 0:
                    await query.edit_message_text(
                        "✅ All transactions have proof attached!",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="admin_finance_dashboard")
                        ]])
                    )
                    return
                
                # Get transactions without proof with pagination
                self.db.cursor.execute("""
                    SELECT id, transaction_date, transaction_type, category, description,
                           amount, payment_method, recorded_by_name
                    FROM tbl_financial_transactions
                    WHERE attachment_file_id IS NULL
                    ORDER BY created_at DESC
                    LIMIT %s OFFSET %s
                """, (items_per_page, offset))
                rows = self.db.cursor.fetchall()
                
                text = f"⚠️ TRANSACTIONS WITHOUT PROOF\n"
                text += f"📊 Total: {total_count} | Page {page + 1}/{total_pages}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                keyboard = []
                for row in rows:
                    tx_id, date, tx_type, category, desc, amount, payment, recorder = row
                    emoji = "📈" if tx_type == 'income' else "📉"
                    button_text = f"{emoji} #{tx_id} - {amount:,.0f} - {recorder[:10]}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"admin_view_tx_{tx_id}")])
                
                # Pagination buttons
                nav_buttons = []
                if page > 0:
                    nav_buttons.append(InlineKeyboardButton("⬅️ Prev", callback_data=f"admin_finance_no_proof_page_{page - 1}"))
                if page < total_pages - 1:
                    nav_buttons.append(InlineKeyboardButton("Next ➡️", callback_data=f"admin_finance_no_proof_page_{page + 1}"))
                if nav_buttons:
                    keyboard.append(nav_buttons)
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_finance_dashboard")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Finance - By Category
            elif query.data == "admin_finance_by_category":
                lang = get_user_language(telegram_user_id, self.db)
                
                self.db.cursor.execute("""
                    SELECT category, transaction_type, COUNT(*) as cnt, SUM(amount) as total
                    FROM tbl_financial_transactions
                    WHERE transaction_date >= DATE_TRUNC('month', CURRENT_DATE)
                    GROUP BY category, transaction_type
                    ORDER BY total DESC
                """)
                rows = self.db.cursor.fetchall()
                
                text = "📊 CATEGORY REPORT (This Month)\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                income_cats = []
                expense_cats = []
                
                for row in rows:
                    cat, tx_type, cnt, total = row
                    if tx_type == 'income':
                        income_cats.append((cat, cnt, total))
                    else:
                        expense_cats.append((cat, cnt, total))
                
                if income_cats:
                    text += "📈 INCOME\n"
                    for cat, cnt, total in income_cats:
                        text += f"   • {cat}: {total:,.2f} RSD ({cnt})\n"
                    text += "\n"
                
                if expense_cats:
                    text += "📉 EXPENSES\n"
                    for cat, cnt, total in expense_cats:
                        text += f"   • {cat}: {total:,.2f} RSD ({cnt})\n"
                
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="admin_finance_dashboard")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Finance - Period Selection
            elif query.data == "admin_finance_period":
                lang = get_user_language(telegram_user_id, self.db)
                
                text = "📅 SELECT REPORT PERIOD\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                
                keyboard = [
                    [InlineKeyboardButton("📅 Today", callback_data="admin_finance_report_today")],
                    [InlineKeyboardButton("📆 This Week", callback_data="admin_finance_report_week")],
                    [InlineKeyboardButton("🗓️ This Month", callback_data="admin_finance_report_month")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="admin_finance_dashboard")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Finance - Period Report
            elif query.data in ["admin_finance_report_today", "admin_finance_report_week", "admin_finance_report_month"]:
                lang = get_user_language(telegram_user_id, self.db)
                
                period = query.data.replace("admin_finance_report_", "")
                period_labels = {"today": "TODAY", "week": "THIS WEEK", "month": "THIS MONTH"}
                period_filters = {
                    "today": "transaction_date = CURRENT_DATE",
                    "week": "transaction_date >= CURRENT_DATE - INTERVAL '7 days'",
                    "month": "transaction_date >= DATE_TRUNC('month', CURRENT_DATE)"
                }
                
                self.db.cursor.execute(f"""
                    SELECT 
                        COALESCE(SUM(CASE WHEN transaction_type='income' THEN amount END), 0) as income,
                        COALESCE(SUM(CASE WHEN transaction_type='expense' THEN amount END), 0) as expense,
                        COUNT(*) as total_count,
                        COUNT(CASE WHEN attachment_file_id IS NULL THEN 1 END) as no_proof_count
                    FROM tbl_financial_transactions
                    WHERE {period_filters[period]}
                """)
                summary = self.db.cursor.fetchone()
                
                income = float(summary[0])
                expense = float(summary[1])
                net = income - expense
                total_count = summary[2]
                no_proof = summary[3]
                
                text = f"📊 FINANCIAL REPORT - {period_labels[period]}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"📈 Total Income: {income:,.2f} RSD\n"
                text += f"📉 Total Expense: {expense:,.2f} RSD\n"
                text += f"💹 Net: {net:,.2f} RSD\n\n"
                text += f"📊 Transactions: {total_count}\n"
                if no_proof > 0:
                    text += f"⚠️ Without proof: {no_proof}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="admin_finance_dashboard")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Finance - Proof Gallery (with pagination)
            elif query.data == "admin_finance_gallery" or query.data.startswith("admin_finance_gallery_page_"):
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get page number
                page = 0
                if query.data.startswith("admin_finance_gallery_page_"):
                    page = int(query.data.replace("admin_finance_gallery_page_", ""))
                
                # Get transactions with proof
                self.db.cursor.execute("""
                    SELECT COUNT(*) FROM tbl_financial_transactions
                    WHERE attachment_file_id IS NOT NULL
                """)
                total_count = self.db.cursor.fetchone()[0]
                
                if total_count == 0:
                    # Try to edit, if fails (media message), delete and send new
                    try:
                        await query.edit_message_text(
                            "📸 No proof attachments found.",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="admin_finance_dashboard")
                            ]])
                        )
                    except:
                        await query.message.delete()
                        await self.application.bot.send_message(
                            chat_id=telegram_user_id,
                            text="📸 No proof attachments found.",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="admin_finance_dashboard")
                            ]])
                        )
                    return
                
                items_per_page = 5
                total_pages = (total_count + items_per_page - 1) // items_per_page
                offset = page * items_per_page
                
                self.db.cursor.execute("""
                    SELECT id, transaction_date, transaction_type, category, description,
                           amount, recorded_by_name, attachment_file_id, attachment_type
                    FROM tbl_financial_transactions
                    WHERE attachment_file_id IS NOT NULL
                    ORDER BY created_at DESC
                    LIMIT %s OFFSET %s
                """, (items_per_page, offset))
                rows = self.db.cursor.fetchall()
                
                text = f"📸 PROOF GALLERY\n"
                text += f"📊 Total: {total_count} | Page {page + 1}/{total_pages}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += "Click a transaction to view its proof:\n\n"
                
                keyboard = []
                for row in rows:
                    tx_id, date, tx_type, category, desc, amount, recorder, file_id, file_type = row
                    emoji = "📈" if tx_type == 'income' else "📉"
                    media_icon = "🖼️" if file_type == 'photo' else "📄"
                    button_text = f"{emoji} #{tx_id} {media_icon} {amount:,.0f} RSD - {date}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"admin_gallery_view_{tx_id}")])
                
                # Pagination buttons
                nav_buttons = []
                if page > 0:
                    nav_buttons.append(InlineKeyboardButton("⬅️ Prev", callback_data=f"admin_finance_gallery_page_{page - 1}"))
                if page < total_pages - 1:
                    nav_buttons.append(InlineKeyboardButton("Next ➡️", callback_data=f"admin_finance_gallery_page_{page + 1}"))
                if nav_buttons:
                    keyboard.append(nav_buttons)
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_finance_dashboard")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                # Try to edit, if fails (media message), delete and send new
                try:
                    await query.edit_message_text(text, reply_markup=reply_markup)
                except:
                    await query.message.delete()
                    await self.application.bot.send_message(
                        chat_id=telegram_user_id,
                        text=text,
                        reply_markup=reply_markup
                    )
            
            # Admin Finance - Gallery View Single Transaction with Proof
            elif query.data.startswith("admin_gallery_view_"):
                from database import get_transaction_detail
                
                lang = get_user_language(telegram_user_id, self.db)
                tx_id = int(query.data.replace("admin_gallery_view_", ""))
                
                tx = get_transaction_detail(self.db, tx_id)
                
                if not tx or not tx['attachment_file_id']:
                    await query.answer("❌ Proof not found", show_alert=True)
                    return
                
                emoji = "📈" if tx['type'] == 'income' else "📉"
                caption = f"{emoji} TRANSACTION #{tx['id']}\n"
                caption += "━━━━━━━━━━━━━━━━━━━━━━━\n"
                caption += f"📅 Date: {tx['date']}\n"
                caption += f"📌 Type: {tx['type'].upper()}\n"
                caption += f"📁 Category: {tx['category']}\n"
                caption += f"💰 Amount: {tx['amount']:,.2f} RSD\n"
                caption += f"💳 Payment: {tx['payment_method']}\n"
                caption += f"📝 Description: {tx['description']}\n"
                caption += f"👤 Recorded by: {tx['recorded_by_name']}\n"
                caption += "━━━━━━━━━━━━━━━━━━━━━━━"
                
                keyboard = [[InlineKeyboardButton("🔙 Back to Gallery", callback_data="admin_finance_gallery")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                try:
                    await query.message.delete()
                    if tx['attachment_type'] == 'photo':
                        await self.application.bot.send_photo(
                            chat_id=telegram_user_id,
                            photo=tx['attachment_file_id'],
                            caption=caption,
                            reply_markup=reply_markup
                        )
                    else:
                        await self.application.bot.send_document(
                            chat_id=telegram_user_id,
                            document=tx['attachment_file_id'],
                            caption=caption,
                            reply_markup=reply_markup
                        )
                except Exception as e:
                    print(f"Error sending gallery proof: {e}")
                    await query.answer("❌ Error viewing proof", show_alert=True)
            
            # ==================== MESSAGE MANAGEMENT ====================
            
            # Message Management Menu
            elif query.data == "message_management":
                lang = get_user_language(telegram_user_id, self.db)
                
                text = "📧 <b>Message Management</b>\n\n"
                text += "Select an option below to manage email and WhatsApp notifications for hotel staff.\n\n"
                text += "📧 <b>Send Reminder</b> - Send email registration reminder to employees\n"
                text += "📋 <b>View Logs</b> - View recent email sending logs\n"
                text += "📱 <b>Send WhatsApp</b> - Send WhatsApp message to staff\n"
                text += "📋 <b>WhatsApp Logs</b> - View WhatsApp message history"
                
                keyboard = [
                    [InlineKeyboardButton("� Send Email Reminder", callback_data="send_test_email")],
                    [InlineKeyboardButton("📊 Email Logs", callback_data="view_email_logs")],
                    [InlineKeyboardButton("📱 Send WhatsApp", callback_data="send_whatsapp_menu")],
                    [InlineKeyboardButton("📋 WhatsApp Logs", callback_data="view_whatsapp_logs")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="actions")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="HTML")
            
            # WhatsApp Menu - Show Department Selection
            elif query.data == "send_whatsapp_menu":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get departments with WhatsApp registered employees
                result = self.db.execute_query("""
                    SELECT department, COUNT(*) as whatsapp_count
                    FROM tbl_employeer
                    WHERE whatsapp IS NOT NULL AND whatsapp != ''
                    AND department != 'Management'
                    GROUP BY department
                    ORDER BY department
                """)
                
                if not result:
                    await query.answer("❌ No employees with WhatsApp registered", show_alert=True)
                    return
                
                text = "📱 <b>Send WhatsApp Message</b>\n\n"
                text += "Select a department to send WhatsApp messages:\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                keyboard = []
                for dept, count in result:
                    text += f"🏢 <b>{dept}</b>: {count} employee(s) with WhatsApp\n"
                    keyboard.append([InlineKeyboardButton(
                        f"🏢 {dept} ({count})",
                        callback_data=f"whatsapp_dept_{dept}"
                    )])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="message_management")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="HTML")
            
            # View WhatsApp Logs
            elif query.data == "view_whatsapp_logs":
                lang = get_user_language(telegram_user_id, self.db)
                
                from database import get_whatsapp_logs
                
                # Get WhatsApp logs from database
                logs = get_whatsapp_logs(self.db, limit=20)
                
                if not logs:
                    text = "📋 <b>WhatsApp Message History</b>\n\n"
                    text += "No WhatsApp messages have been sent yet."
                else:
                    text = "📋 <b>WhatsApp Message History</b>\n\n"
                    text += f"Showing last {len(logs)} message(s):\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    
                    for log in logs:
                        status_icon = "✅" if log['status'] == 'sent' else "❌"
                        text += f"{status_icon} <b>{log['recipient_name']}</b>\n"
                        text += f"   📱 {log['recipient']}\n"
                        text += f"   📝 {log['message_body'][:50]}...\n" if len(log['message_body']) > 50 else f"   📝 {log['message_body']}\n"
                        text += f"   🕐 {log['sent_at'].strftime('%Y-%m-%d %H:%M')}\n"
                        
                        if log['status'] == 'failed' and log['error_message']:
                            text += f"   ⚠️ Error: {log['error_message'][:50]}\n"
                        
                        text += "\n"
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="message_management")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="HTML")
            
            # WhatsApp Department Selection - Show Employees
            elif query.data.startswith("whatsapp_dept_"):
                lang = get_user_language(telegram_user_id, self.db)
                dept_name = query.data.replace("whatsapp_dept_", "")
                
                from database import get_employees_with_whatsapp
                
                # Get employees with WhatsApp in this department
                employees = get_employees_with_whatsapp(self.db, dept_name)
                
                if not employees:
                    await query.answer(f"❌ No employees with WhatsApp in {dept_name}", show_alert=True)
                    return
                
                # Initialize selected employees in context if not exists
                if 'whatsapp_selected' not in context.user_data:
                    context.user_data['whatsapp_selected'] = []
                context.user_data['whatsapp_department'] = dept_name
                
                text = f"📱 <b>Send WhatsApp Message</b>\n\n"
                text += f"🏢 Department: <b>{dept_name}</b>\n"
                text += f"👥 Total: {len(employees)} employee(s) with WhatsApp\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += "Select employees to send message:\n\n"
                
                keyboard = []
                for emp in employees:
                    emp_id = emp['employee_id']
                    emp_name = emp['name']
                    whatsapp = emp['whatsapp']
                    
                    is_selected = emp_id in context.user_data['whatsapp_selected']
                    check = "✅" if is_selected else "☐"
                    keyboard.append([InlineKeyboardButton(
                        f"{check} {emp_name} ({whatsapp})",
                        callback_data=f"whatsapp_toggle_{emp_id}"
                    )])
                
                # Add action buttons
                if context.user_data['whatsapp_selected']:
                    text += f"✅ Selected: {len(context.user_data['whatsapp_selected'])} employee(s)\n"
                    keyboard.append([InlineKeyboardButton("📱 Send WhatsApp", callback_data="whatsapp_send_confirm")])
                
                keyboard.append([InlineKeyboardButton("🔙 Back", callback_data="send_whatsapp_menu")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="HTML")
            
            # Toggle WhatsApp Employee Selection
            elif query.data.startswith("whatsapp_toggle_"):
                emp_id = query.data.replace("whatsapp_toggle_", "")
                
                if 'whatsapp_selected' not in context.user_data:
                    context.user_data['whatsapp_selected'] = []
                
                # Toggle selection
                if emp_id in context.user_data['whatsapp_selected']:
                    context.user_data['whatsapp_selected'].remove(emp_id)
                else:
                    context.user_data['whatsapp_selected'].append(emp_id)
                
                # Refresh the employee list
                dept_name = context.user_data.get('whatsapp_department', '')
                if dept_name:
                    from database import get_employees_with_whatsapp
                    
                    employees = get_employees_with_whatsapp(self.db, dept_name)
                    
                    text = f"📱 <b>Send WhatsApp Message</b>\n\n"
                    text += f"🏢 Department: <b>{dept_name}</b>\n"
                    text += f"👥 Total: {len(employees)} employee(s) with WhatsApp\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    text += "Select employees to send message:\n\n"
                    
                    keyboard = []
                    for emp in employees:
                        emp_id = emp['employee_id']
                        emp_name = emp['name']
                        whatsapp = emp['whatsapp']
                        
                        is_selected = emp_id in context.user_data['whatsapp_selected']
                        check = "✅" if is_selected else "☐"
                        keyboard.append([InlineKeyboardButton(
                            f"{check} {emp_name} ({whatsapp})",
                            callback_data=f"whatsapp_toggle_{emp_id}"
                        )])
                    
                    # Add action buttons
                    if context.user_data['whatsapp_selected']:
                        text += f"✅ Selected: {len(context.user_data['whatsapp_selected'])} employee(s)\n"
                        keyboard.append([InlineKeyboardButton("📱 Send WhatsApp", callback_data="whatsapp_send_confirm")])
                    
                    keyboard.append([InlineKeyboardButton("🔙 Back", callback_data="send_whatsapp_menu")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="HTML")
            
            # WhatsApp Send Confirmation - Ask for message
            elif query.data == "whatsapp_send_confirm":
                lang = get_user_language(telegram_user_id, self.db)
                
                if not context.user_data.get('whatsapp_selected'):
                    await query.answer("❌ No employees selected", show_alert=True)
                    return
                
                dept_name = context.user_data.get('whatsapp_department', 'Unknown')
                selected_count = len(context.user_data['whatsapp_selected'])
                
                text = f"📱 <b>Send WhatsApp Message</b>\n\n"
                text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"🏢 Department: <b>{dept_name}</b>\n"
                text += f"👥 Recipients: <b>{selected_count}</b> employee(s)\n"
                text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += "Please type your WhatsApp message:\n"
                text += "<i>(The message will be sent to all selected employees)</i>"
                
                keyboard = [
                    [InlineKeyboardButton("❌ Cancel", callback_data=f"whatsapp_dept_{dept_name}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="HTML")
                
                # Set awaiting state
                context.user_data['awaiting_whatsapp_message'] = True
            
            # Send Test Email - Show Department Selection
            elif query.data == "send_test_email":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get all departments except Management
                departments = self.notification_manager.get_departments_except_management()
                
                if not departments:
                    await query.answer("❌ No departments found", show_alert=True)
                    return
                
                # Use notification manager to format text
                text = self.notification_manager.format_department_selection_text()
                
                keyboard = []
                for dept_name in departments:
                    keyboard.append([InlineKeyboardButton(f"🏢 {dept_name}", callback_data=f"email_dept_{dept_name}")])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="message_management")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Email Department Selection - Show Employees
            elif query.data.startswith("email_dept_"):
                lang = get_user_language(telegram_user_id, self.db)
                dept_name = query.data.replace("email_dept_", "")
                
                # Get employees in this department
                employees = self.notification_manager.get_employees_by_department(dept_name)
                
                if not employees:
                    await query.answer(f"❌ No employees in {dept_name}", show_alert=True)
                    return
                
                # Initialize selected employees in context if not exists
                if 'email_selected' not in context.user_data:
                    context.user_data['email_selected'] = []
                context.user_data['email_department'] = dept_name
                
                # Use notification manager to format text
                selected_ids = context.user_data.get('email_selected', [])
                text = self.notification_manager.format_employee_selection_text(dept_name, employees, selected_ids)
                
                # Show employees without email
                no_email_count = 0
                
                keyboard = []
                for emp in employees:
                    emp_id = emp['employee_id']
                    emp_name = emp['name']
                    has_email = emp['has_email']
                    
                    if has_email:
                        # Employee has email - can be selected
                        is_selected = emp_id in context.user_data['email_selected']
                        check = "✅" if is_selected else "☐"
                        keyboard.append([InlineKeyboardButton(
                            f"{check} {emp_name}",
                            callback_data=f"email_toggle_{emp_id}"
                        )])
                    else:
                        # No email - show option to notify
                        no_email_count += 1
                        keyboard.append([InlineKeyboardButton(
                            f"❌ {emp_name} (No Email)",
                            callback_data=f"email_notify_{emp_id}"
                        )])
                
                if no_email_count > 0:
                    text += f"⚠️ {no_email_count} employee(s) without email\n\n"
                
                # Add action buttons
                if context.user_data['email_selected']:
                    text += f"✅ Selected: {len(context.user_data['email_selected'])} employee(s)\n"
                    keyboard.append([InlineKeyboardButton("📧 Send Email", callback_data="email_send_confirm")])
                
                keyboard.append([InlineKeyboardButton("� Back to Departments", callback_data="send_test_email")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Toggle Employee Selection
            elif query.data.startswith("email_toggle_"):
                emp_id = query.data.replace("email_toggle_", "")
                
                if 'email_selected' not in context.user_data:
                    context.user_data['email_selected'] = []
                
                # Toggle selection
                if emp_id in context.user_data['email_selected']:
                    context.user_data['email_selected'].remove(emp_id)
                else:
                    context.user_data['email_selected'].append(emp_id)
                
                # Refresh the employee list
                dept_name = context.user_data.get('email_department', '')
                if dept_name:
                    # Get employees in this department
                    employees = self.notification_manager.get_employees_by_department(dept_name)
                    
                    # Use notification manager to format text
                    selected_ids = context.user_data.get('email_selected', [])
                    text = self.notification_manager.format_employee_selection_text(dept_name, employees, selected_ids)
                    
                    # Build keyboard
                    keyboard = []
                    for emp in employees:
                        emp_id = emp['employee_id']
                        emp_name = emp['name']
                        has_email = emp['has_email']
                        
                        if has_email:
                            is_selected = emp_id in context.user_data['email_selected']
                            check = "✅" if is_selected else "☐"
                            keyboard.append([InlineKeyboardButton(
                                f"{check} {emp_name}",
                                callback_data=f"email_toggle_{emp_id}"
                            )])
                        else:
                            keyboard.append([InlineKeyboardButton(
                                f"❌ {emp_name} (No Email)",
                                callback_data=f"email_notify_{emp_id}"
                            )])
                    
                    # Add action buttons
                    if context.user_data['email_selected']:
                        keyboard.append([InlineKeyboardButton("📧 Send Email", callback_data="email_send_confirm")])
                    
                    keyboard.append([InlineKeyboardButton("🔙 Back to Departments", callback_data="send_test_email")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Notify Employee to Register Email
            elif query.data.startswith("email_notify_"):
                lang = get_user_language(telegram_user_id, self.db)
                emp_id = query.data.replace("email_notify_", "")
                
                # Get employee info
                emp_info = self.db.get_employee_info(emp_id)
                if not emp_info:
                    await query.answer("❌ Employee not found", show_alert=True)
                    return
                
                emp_name = emp_info['name']
                
                # Send notification using notification manager
                success = await self.notification_manager.send_email_registration_reminder(emp_id, emp_name)
                
                if success:
                    await query.answer(f"✅ Notification sent to {emp_name}", show_alert=True)
                else:
                    await query.answer(f"❌ Failed to send notification", show_alert=True)
            
            # Send Email Confirmation
            elif query.data == "email_send_confirm":
                lang = get_user_language(telegram_user_id, self.db)
                
                if not context.user_data.get('email_selected'):
                    await query.answer("❌ No employees selected", show_alert=True)
                    return
                
                dept_name = context.user_data.get('email_department', 'Unknown')
                selected_count = len(context.user_data['email_selected'])
                
                # Use notification manager to format text
                text = self.notification_manager.format_email_confirmation_text(dept_name, selected_count)
                
                keyboard = [
                    [InlineKeyboardButton("❌ Cancel", callback_data=f"email_dept_{dept_name}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Set awaiting state
                context.user_data['awaiting_email_message'] = True
            
            # AI Email Confirmation - Send the AI-generated email
            elif query.data == "email_ai_confirm":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get AI-generated content - use body_html field
                ai_subject = context.user_data.get('email_ai_subject', 'Message from Hotel Management')
                ai_body_html = context.user_data.get('email_ai_body_html')
                selected_emp_ids = context.user_data.get('email_selected', [])
                
                if not ai_body_html or not selected_emp_ids:
                    await query.answer("❌ Email data not found", show_alert=True)
                    return
                
                await query.edit_message_text("📤 Sending emails...")
                
                # Send emails using notification manager with AI-generated HTML content
                result = self.notification_manager.send_bulk_email(
                    selected_emp_ids,
                    ai_subject,
                    ai_body_html
                )
                
                # Clear all email-related data
                context.user_data.pop('email_selected', None)
                context.user_data.pop('email_department', None)
                context.user_data.pop('email_ai_subject', None)
                context.user_data.pop('email_ai_body', None)
                context.user_data.pop('email_ai_body_html', None)
                context.user_data.pop('email_original_input', None)
                
                # Format result
                result_text = self.notification_manager.format_email_result_text(result)
                
                await query.edit_message_text(
                    result_text,
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton("🔙 Back to Message Management", callback_data="message_management")
                    ]])
                )
            
            # AI Email Retry - Let user re-enter message
            elif query.data == "email_ai_retry":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Clear AI data but keep selection
                context.user_data.pop('email_ai_subject', None)
                context.user_data.pop('email_ai_body', None)
                
                dept_name = context.user_data.get('email_department', 'Unknown')
                selected_count = len(context.user_data.get('email_selected', []))
                
                text = f"✏️ Edit Email Message\n\n"
                text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"🏢 Department: {dept_name}\n"
                text += f"👥 Recipients: {selected_count} employee(s)\n\n"
                text += "Please enter your message again:\n"
                text += "(The AI will re-analyze your input)"
                
                keyboard = [
                    [InlineKeyboardButton("❌ Cancel", callback_data="message_management")]
                ]
                
                await query.edit_message_text(
                    text,
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                
                # Set awaiting state
                context.user_data['awaiting_email_message'] = True
            
            # WhatsApp AI Confirmation - Send the AI-generated WhatsApp message
            elif query.data == "whatsapp_ai_confirm":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get AI-generated content
                ai_message = context.user_data.get('whatsapp_ai_message')
                selected_emp_ids = context.user_data.get('whatsapp_selected', [])
                dept_name = context.user_data.get('whatsapp_department', 'Unknown')
                
                if not ai_message or not selected_emp_ids:
                    await query.answer("❌ Message data not found", show_alert=True)
                    return
                
                await query.edit_message_text("📤 Sending WhatsApp messages...")
                
                # Get WhatsApp service and send
                try:
                    from whatsapp_service import get_whatsapp_service
                    from database import log_whatsapp_message, get_employees_with_whatsapp
                    
                    whatsapp_service = get_whatsapp_service()
                    
                    # Get employees with WhatsApp from selected department
                    dept_name = context.user_data.get('whatsapp_department', '')
                    all_whatsapp_employees = get_employees_with_whatsapp(self.db, dept_name)
                    
                    # Filter to only selected employees
                    recipients = []
                    for emp in all_whatsapp_employees:
                        if emp['employee_id'] in selected_emp_ids:
                            recipients.append({
                                'name': emp['name'],
                                'whatsapp': emp['whatsapp']
                            })
                    
                    if not recipients:
                        await query.edit_message_text(
                            "❌ No valid WhatsApp numbers found for selected employees",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton("🔙 Back", callback_data="message_management")
                            ]])
                        )
                        return
                    
                    # Send bulk messages with AI-generated content
                    result = whatsapp_service.send_bulk_messages(recipients, ai_message)
                    
                    # Log each message
                    for detail in result.get('details', []):
                        log_whatsapp_message(
                            self.db,
                            recipient=detail.get('whatsapp', 'Unknown'),
                            recipient_name=detail.get('name', 'Unknown'),
                            message_body=ai_message,
                            status='sent' if detail.get('success') else 'failed',
                            message_sid=detail.get('message_sid'),
                            error_message=detail.get('error')
                        )
                    
                    # Clear all WhatsApp-related data
                    context.user_data.pop('whatsapp_selected', None)
                    context.user_data.pop('whatsapp_department', None)
                    context.user_data.pop('whatsapp_ai_message', None)
                    context.user_data.pop('whatsapp_original_input', None)
                    
                    # Format result
                    result_text = f"📱 <b>WhatsApp Messages Sent</b> (AI Generated)\n\n"
                    result_text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    result_text += f"🏢 Department: <b>{dept_name}</b>\n"
                    result_text += f"📊 Total: {result['total']}\n"
                    result_text += f"✅ Success: {result['success']}\n"
                    result_text += f"❌ Failed: {result['failed']}\n"
                    result_text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    
                    if result['success'] > 0:
                        result_text += "✅ <b>Successfully sent to:</b>\n"
                        for detail in result['details']:
                            if detail.get('success'):
                                result_text += f"  • {detail['name']} ({detail['whatsapp']})\n"
                        result_text += "\n"
                    
                    if result['failed'] > 0:
                        result_text += "❌ <b>Failed to send to:</b>\n"
                        for detail in result['details']:
                            if not detail.get('success'):
                                error_msg = detail.get('error', 'Unknown error')[:50]
                                result_text += f"  • {detail['name']}: {error_msg}\n"
                    
                    await query.edit_message_text(
                        result_text,
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton("🔙 Back to Message Management", callback_data="message_management")
                        ]]),
                        parse_mode="HTML"
                    )
                    
                except Exception as e:
                    import traceback
                    error_details = traceback.format_exc()
                    print(f"❌ WhatsApp sending error: {e}")
                    print(f"Traceback:\n{error_details}")
                    
                    await query.edit_message_text(
                        f"❌ Failed to send WhatsApp messages:\n{str(e)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton("🔙 Back", callback_data="message_management")
                        ]])
                    )
            
            # WhatsApp AI Retry - Let user re-enter message
            elif query.data == "whatsapp_ai_retry":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Clear AI data but keep selection
                context.user_data.pop('whatsapp_ai_message', None)
                context.user_data.pop('whatsapp_original_input', None)
                
                dept_name = context.user_data.get('whatsapp_department', 'Unknown')
                selected_count = len(context.user_data.get('whatsapp_selected', []))
                
                text = f"✏️ Edit WhatsApp Message\n\n"
                text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"🏢 Department: {dept_name}\n"
                text += f"👥 Recipients: {selected_count} employee(s)\n\n"
                text += "Please enter your message again:\n"
                text += "(The AI will re-analyze your input)"
                
                keyboard = [
                    [InlineKeyboardButton("❌ Cancel", callback_data="message_management")]
                ]
                
                await query.edit_message_text(
                    text,
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                
                # Set awaiting state
                context.user_data['awaiting_whatsapp_message'] = True
            
            # View Email Logs
            elif query.data == "view_email_logs":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get logs and format text using notification manager
                logs = self.notification_manager.get_email_logs(limit=20)
                text = self.notification_manager.format_email_logs_text(logs)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('back', lang), callback_data="message_management")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="HTML")
            
            # Admin Event Management
            elif query.data == "admin_events":
                from database import get_all_events, get_upcoming_events, get_todays_events
                
                lang = get_user_language(telegram_user_id, self.db)
                all_events = get_all_events(self.db)
                upcoming = get_upcoming_events(self.db, 7)
                today_events = get_todays_events(self.db)
                
                # Count by status
                scheduled = len([e for e in all_events if e[11] == 'scheduled'])
                confirmed = len([e for e in all_events if e[11] == 'confirmed'])
                in_progress = len([e for e in all_events if e[11] == 'in_progress'])
                completed = len([e for e in all_events if e[11] == 'completed'])
                cancelled = len([e for e in all_events if e[11] == 'cancelled'])
                
                text = f"🎉 {get_text('event_management', lang)}\n\n"
                text += f"📊 {get_text('total', lang)}: {len(all_events)}\n"
                text += f"📅 {get_text('event_scheduled', lang)}: {scheduled}\n"
                text += f"✔️ {get_text('event_confirmed', lang)}: {confirmed}\n"
                text += f"🔄 {get_text('event_in_progress', lang)}: {in_progress}\n"
                text += f"✅ {get_text('event_completed', lang)}: {completed}\n"
                
                if today_events:
                    text += f"\n🎉 {get_text('todays_events', lang)}: {len(today_events)}\n"
                    for e in today_events[:3]:
                        text += f"  • {e[1]} ({e[4]}) - {e[2]}\n"
                
                if upcoming:
                    text += f"\n📅 {get_text('upcoming_events', lang)}: {len(upcoming)}\n"
                
                keyboard = [
                    [InlineKeyboardButton(get_text('create_event', lang), callback_data="admin_event_create")],
                    [InlineKeyboardButton(get_text('event_list', lang), callback_data="admin_event_list")],
                    [InlineKeyboardButton(get_text('event_progress', lang), callback_data="admin_event_progress")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="actions")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Event - Create new event (Select event type first)
            elif query.data == "admin_event_create":
                from templates import EVENT_TEMPLATES
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Show event type selection
                keyboard = []
                for key, template in EVENT_TEMPLATES.items():
                    name = template['name'].get(lang, template['name']['en'])
                    keyboard.append([InlineKeyboardButton(name, callback_data=f"event_type_{key}")])
                keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")])
                
                await query.edit_message_text(
                    f"{get_text('create_event', lang)}\n\n🎯 Select event type:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            
            # Event type selected - start creation with template
            elif query.data.startswith("event_type_"):
                from templates import get_event_template, get_event_input_step
                
                lang = get_user_language(telegram_user_id, self.db)
                event_type = query.data.replace("event_type_", "")
                template = get_event_template(event_type)
                
                # Initialize event creation with template
                context.user_data['creating_event'] = {
                    'step': 1,
                    'event_type': event_type,
                    'template': template
                }
                
                step_info = get_event_input_step(lang, 1)
                
                await query.edit_message_text(
                    f"{get_text('create_event', lang)} - {template['name'].get(lang, template['name']['en'])}\n\n"
                    f"Step 1/7: {step_info['title']}\n\n{step_info['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")
                    ]])
                )
            
            # Event calendar - Previous month
            elif query.data.startswith("event_cal_prev_"):
                lang = get_user_language(telegram_user_id, self.db)
                parts = query.data.replace("event_cal_prev_", "").split("_")
                year, month = int(parts[0]), int(parts[1])
                
                # Go to previous month
                if month == 1:
                    month = 12
                    year -= 1
                else:
                    month -= 1
                
                calendar_keyboard = create_calendar(year, month, lang, 'event_date')
                calendar_keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")])
                
                await query.edit_message_text(
                    f"📅 {get_text('enter_event_date', lang)}",
                    reply_markup=InlineKeyboardMarkup(calendar_keyboard)
                )
            
            # Event calendar - Next month
            elif query.data.startswith("event_cal_next_"):
                lang = get_user_language(telegram_user_id, self.db)
                parts = query.data.replace("event_cal_next_", "").split("_")
                year, month = int(parts[0]), int(parts[1])
                
                # Go to next month
                if month == 12:
                    month = 1
                    year += 1
                else:
                    month += 1
                
                calendar_keyboard = create_calendar(year, month, lang, 'event_date')
                calendar_keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")])
                
                await query.edit_message_text(
                    f"📅 {get_text('enter_event_date', lang)}",
                    reply_markup=InlineKeyboardMarkup(calendar_keyboard)
                )
            
            # Event date selected from calendar
            elif query.data.startswith("event_date_"):
                from templates import get_event_input_step
                
                lang = get_user_language(telegram_user_id, self.db)
                selected_date = query.data.replace("event_date_", "")
                
                if context.user_data.get('creating_event') and context.user_data['creating_event'].get('step') == 3:
                    context.user_data['creating_event']['event_date'] = selected_date
                    context.user_data['creating_event']['step'] = 4
                    
                    step_info = get_event_input_step(lang, 4)
                    await query.edit_message_text(
                        f"✅ {get_event_input_step(lang, 3)['title']}: {selected_date}\n\n"
                        f"Step 4/7: {step_info['title']}\n\n{step_info['prompt']}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")
                        ]])
                    )
                else:
                    await query.answer("Please start event creation first", show_alert=True)
            
            # Admin Event - List events
            elif query.data == "admin_event_list":
                from database import get_all_events
                
                lang = get_user_language(telegram_user_id, self.db)
                events = get_all_events(self.db)
                
                if not events:
                    await query.edit_message_text(
                        f"{get_text('event_list', lang)}\n\n{get_text('no_events', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('create_event', lang), callback_data="admin_event_create"),
                            InlineKeyboardButton(get_text('back', lang), callback_data="admin_events")
                        ]])
                    )
                    return
                
                # Build event list buttons
                keyboard = []
                for e in events[:10]:  # Show max 10 events
                    event_id, name, hall, date, time, _, seats, _, _, _, _, status, _, _ = e
                    status_icon = "📅" if status == "scheduled" else "✅" if status == "confirmed" else "🔄" if status == "in_progress" else "✅" if status == "completed" else "❌"
                    keyboard.append([InlineKeyboardButton(
                        f"{status_icon} {name} - {date} {time}",
                        callback_data=f"admin_event_view_{event_id}"
                    )])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_events")])
                
                await query.edit_message_text(
                    f"{get_text('event_list', lang)}",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            
            # Admin Event - View event details
            elif query.data.startswith("admin_event_view_"):
                from database import get_event_by_id, get_event_history, get_event_tasks
                
                lang = get_user_language(telegram_user_id, self.db)
                event_id = int(query.data.replace("admin_event_view_", ""))
                event = get_event_by_id(self.db, event_id)
                
                if not event:
                    await query.answer("Event not found", show_alert=True)
                    return
                
                # Get event history and tasks
                history = get_event_history(self.db, event_id)
                tasks = get_event_tasks(self.db, event_id)
                
                # Build event details text
                status_text = {
                    'scheduled': get_text('event_scheduled', lang),
                    'confirmed': get_text('event_confirmed', lang),
                    'in_progress': get_text('event_in_progress', lang),
                    'completed': get_text('event_completed', lang),
                    'cancelled': get_text('event_cancelled', lang)
                }.get(event['status'], event['status'])
                
                text = f"{get_text('event_details', lang)}\n\n"
                text += f"📌 {get_text('event_name', lang)}: {event['event_name']}\n"
                text += f"📍 {get_text('event_hall', lang)}: {event['hall']}\n"
                text += f"📅 {get_text('event_date', lang)}: {event['event_date']}\n"
                text += f"⏰ {get_text('event_time', lang)}: {event['event_time']}"
                if event['end_time']:
                    text += f" - {event['end_time']}"
                text += f"\n👥 {get_text('event_seats', lang)}: {event['seats']}\n"
                text += f"💰 {get_text('event_price', lang)}: {event['price']}\n"
                text += f"🍽️ {get_text('event_meals_count', lang)}: {event['meals_count']}\n"
                if event['menu']:
                    text += f"📝 {get_text('event_menu', lang)}: {event['menu']}\n"
                if event['notes']:
                    text += f"📋 {get_text('event_notes', lang)}: {event['notes']}\n"
                text += f"\n📊 {get_text('event_status', lang)}: {status_text}\n"
                
                # Show department status summary
                if history:
                    text += f"\n{get_text('department_status', lang)}:\n"
                    dept_status = {}
                    for h in history:
                        dept = h[2]
                        alarm_type = h[3]
                        ack = h[5]
                        conf = h[8]
                        ready = h[11]
                        if dept not in dept_status:
                            dept_status[dept] = {'ack': False, 'conf': False, 'ready': False}
                        if ack:
                            dept_status[dept]['ack'] = True
                        if conf:
                            dept_status[dept]['conf'] = True
                        if ready:
                            dept_status[dept]['ready'] = True
                    
                    for dept, status in dept_status.items():
                        ack_icon = "✅" if status['ack'] else "❌"
                        conf_icon = "✅" if status['conf'] else "❌"
                        ready_icon = "✅" if status['ready'] else "❌"
                        text += f"  • {dept}: {ack_icon} | {conf_icon} | {ready_icon}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"� {get_text('change_status', lang)}", callback_data=f"admin_event_status_{event_id}")],
                    [InlineKeyboardButton(f"�📝 {get_text('manual_task_assign', lang)}", callback_data=f"event_manual_task_{event_id}")],
                    [InlineKeyboardButton(get_text('event_history', lang), callback_data=f"admin_event_history_{event_id}")],
                    [InlineKeyboardButton(get_text('event_tasks', lang), callback_data=f"admin_event_tasks_{event_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="admin_event_list")]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
            
            # Admin Event - Change Event Status
            elif query.data.startswith("admin_event_status_") and not "_set_" in query.data:
                from database import get_event_by_id
                
                lang = get_user_language(telegram_user_id, self.db)
                event_id = int(query.data.replace("admin_event_status_", ""))
                event = get_event_by_id(self.db, event_id)
                
                if not event:
                    await query.answer("Event not found", show_alert=True)
                    return
                
                current_status = event['status']
                
                text = f"🔄 **{get_text('change_status', lang)}**\n\n"
                text += f"📌 {event['event_name']}\n"
                text += f"📅 {event['event_date']} {event['event_time']}\n\n"
                text += f"Current: {current_status.upper()}\n\n"
                text += "Select new status:"
                
                status_options = [
                    ('scheduled', '📅 Scheduled'),
                    ('confirmed', '✔️ Confirmed'),
                    ('in_progress', '🔄 In Progress'),
                    ('completed', '✅ Completed'),
                    ('cancelled', '❌ Cancelled')
                ]
                
                keyboard = []
                for status, label in status_options:
                    if status != current_status:
                        keyboard.append([InlineKeyboardButton(label, callback_data=f"admin_event_status_set_{event_id}_{status}")])
                
                keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_event_view_{event_id}")])
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
            
            # Admin Event - Set Event Status
            elif query.data.startswith("admin_event_status_set_"):
                from database import get_event_by_id, clear_event_notifications
                from datetime import datetime
                
                # Parse callback data: admin_event_status_set_{event_id}_{new_status}
                callback_data = query.data.replace("admin_event_status_set_", "")
                parts = callback_data.split("_", 1)  # Split only on first underscore
                event_id = int(parts[0])
                new_status = parts[1] if len(parts) > 1 else 'scheduled'
                
                lang = get_user_language(telegram_user_id, self.db)
                
                event = get_event_by_id(self.db, event_id)
                if not event:
                    await query.answer("Event not found", show_alert=True)
                    return
                
                # Update status in database
                print(f"🔄 Changing event {event_id} status to: {new_status}")
                now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                self.db.execute_query("""
                    UPDATE tbl_hotel_events 
                    SET status = %s, updated_at = %s
                    WHERE id = %s
                """, (new_status, now, event_id))
                print(f"✅ Event {event_id} status updated successfully")
                
                # If event is cancelled or completed, clear all notification records
                if new_status in ('cancelled', 'completed'):
                    clear_event_notifications(self.db, event_id)
                    print(f"🧹 Cleared notification records for {new_status} event {event_id}")
                
                status_labels = {
                    'scheduled': '📅 Scheduled',
                    'confirmed': '✔️ Confirmed',
                    'in_progress': '🔄 In Progress',
                    'completed': '✅ Completed',
                    'cancelled': '❌ Cancelled'
                }
                
                await query.answer(f"Status changed to {status_labels.get(new_status, new_status)}!", show_alert=True)
                
                # Return to event view - show updated event details
                from database import get_event_history, get_event_tasks
                
                event = get_event_by_id(self.db, event_id)
                if not event:
                    await query.answer("Event not found", show_alert=True)
                    return
                
                # Get event history and tasks
                history = get_event_history(self.db, event_id)
                tasks = get_event_tasks(self.db, event_id)
                
                # Build event details text
                status_text = {
                    'scheduled': get_text('event_scheduled', lang),
                    'confirmed': get_text('event_confirmed', lang),
                    'in_progress': get_text('event_in_progress', lang),
                    'completed': get_text('event_completed', lang),
                    'cancelled': get_text('event_cancelled', lang)
                }.get(event['status'], event['status'])
                
                text = f"{get_text('event_details', lang)}\n\n"
                text += f"📌 {get_text('event_name', lang)}: {event['event_name']}\n"
                text += f"📍 {get_text('event_hall', lang)}: {event['hall']}\n"
                text += f"📅 {get_text('event_date', lang)}: {event['event_date']}\n"
                text += f"⏰ {get_text('event_time', lang)}: {event['event_time']}"
                if event['end_time']:
                    text += f" - {event['end_time']}"
                text += f"\n👥 {get_text('event_seats', lang)}: {event['seats']}\n"
                text += f"💰 {get_text('event_price', lang)}: {event['price']}\n"
                text += f"🍽️ {get_text('event_meals_count', lang)}: {event['meals_count']}\n"
                if event['menu']:
                    text += f"📝 {get_text('event_menu', lang)}: {event['menu']}\n"
                if event['notes']:
                    text += f"📋 {get_text('event_notes', lang)}: {event['notes']}\n"
                text += f"\n📊 {get_text('event_status', lang)}: {status_text}\n"
                
                # Show department status summary
                if history:
                    text += f"\n{get_text('department_status', lang)}:\n"
                    dept_status = {}
                    for h in history:
                        dept = h[2]
                        alarm_type = h[3]
                        ack = h[5]
                        conf = h[8]
                        ready = h[11]
                        if dept not in dept_status:
                            dept_status[dept] = {'ack': False, 'conf': False, 'ready': False}
                        if ack:
                            dept_status[dept]['ack'] = True
                        if conf:
                            dept_status[dept]['conf'] = True
                        if ready:
                            dept_status[dept]['ready'] = True
                    
                    for dept, status in dept_status.items():
                        ack_icon = "✅" if status['ack'] else "❌"
                        conf_icon = "✅" if status['conf'] else "❌"
                        ready_icon = "✅" if status['ready'] else "❌"
                        text += f"  • {dept}: {ack_icon} | {conf_icon} | {ready_icon}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"🔄 {get_text('change_status', lang)}", callback_data=f"admin_event_status_{event_id}")],
                    [InlineKeyboardButton(f"📝 {get_text('manual_task_assign', lang)}", callback_data=f"event_manual_task_{event_id}")],
                    [InlineKeyboardButton(get_text('event_history', lang), callback_data=f"admin_event_history_{event_id}")],
                    [InlineKeyboardButton(get_text('event_tasks', lang), callback_data=f"admin_event_tasks_{event_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="admin_event_list")]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
            
            # Admin Event - View Event History (Alarm/Confirmation status)
            elif query.data.startswith("admin_event_history_"):
                from database import get_event_history, get_event_by_id
                
                lang = get_user_language(telegram_user_id, self.db)
                event_id = int(query.data.replace("admin_event_history_", ""))
                event = get_event_by_id(self.db, event_id)
                history = get_event_history(self.db, event_id)
                
                if not event:
                    await query.answer("Event not found", show_alert=True)
                    return
                
                text = f"📊 {get_text('event_history', lang)}\n\n"
                text += f"🎉 {event['event_name']}\n"
                text += f"📅 {event['event_date']} {event['event_time']}\n\n"
                
                if not history:
                    text += "No history records yet."
                else:
                    # Group by alarm type
                    t2_history = [h for h in history if h[3] == 'T-2']
                    t1_history = [h for h in history if h[3] == 'T-1']
                    day_history = [h for h in history if h[3] == 'event_day']
                    
                    # T-2 Status
                    if t2_history:
                        text += "━━━ ⚠️ T-2 (2 days before) ━━━\n"
                        for h in t2_history:
                            from datetime import datetime
                            dept = h[2]
                            alarm_sent = h[4].strftime('%Y-%m-%d %H:%M') if isinstance(h[4], datetime) else (h[4][:16] if h[4] else "Not sent")
                            ack = "✅" if h[5] else "❌"
                            ack_time = h[7].strftime('%Y-%m-%d %H:%M') if isinstance(h[7], datetime) else (h[7][:16] if h[7] else "-")
                            
                            text += f"🏢 {dept}\n"
                            text += f"  📤 Sent: {alarm_sent}\n"
                            text += f"  {ack} Ack: {ack_time}\n"
                        text += "\n"
                    
                    # T-1 Status
                    if t1_history:
                        text += "━━━ 🔔 T-1 (1 day before) ━━━\n"
                        for h in t1_history:
                            from datetime import datetime
                            dept = h[2]
                            alarm_sent = h[4].strftime('%Y-%m-%d %H:%M') if isinstance(h[4], datetime) else (h[4][:16] if h[4] else "Not sent")
                            conf = "✅" if h[8] else "❌"
                            conf_time = h[10].strftime('%Y-%m-%d %H:%M') if isinstance(h[10], datetime) else (h[10][:16] if h[10] else "-")
                            
                            text += f"🏢 {dept}\n"
                            text += f"  📤 Sent: {alarm_sent}\n"
                            text += f"  {conf} Confirm: {conf_time}\n"
                        text += "\n"
                    
                    # Event Day Status
                    if day_history:
                        text += "━━━ 🚨 Event Day ━━━\n"
                        for h in day_history:
                            from datetime import datetime
                            dept = h[2]
                            alarm_sent = h[4].strftime('%Y-%m-%d %H:%M') if isinstance(h[4], datetime) else (h[4][:16] if h[4] else "Not sent")
                            ready = "✅" if h[11] else "❌"
                            ready_time = h[13].strftime('%Y-%m-%d %H:%M') if isinstance(h[13], datetime) else (h[13][:16] if h[13] else "-")
                            proof = "📸" if h[14] else ""
                            
                            text += f"🏢 {dept}\n"
                            text += f"  📤 Sent: {alarm_sent}\n"
                            text += f"  {ready} Ready: {ready_time} {proof}\n"
                        text += "\n"
                
                text += "\n📊 Legend:\n"
                text += "✅ = Confirmed | ❌ = Pending | 📸 = Proof attached"
                
                keyboard = [
                    [InlineKeyboardButton(get_text('refresh', lang), callback_data=f"admin_event_history_{event_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_event_view_{event_id}")]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
            
            # Admin Event - View Event Tasks with status
            elif query.data.startswith("admin_event_tasks_"):
                from database import get_event_tasks, get_event_by_id
                
                lang = get_user_language(telegram_user_id, self.db)
                event_id = int(query.data.replace("admin_event_tasks_", ""))
                event = get_event_by_id(self.db, event_id)
                tasks = get_event_tasks(self.db, event_id)
                
                if not tasks:
                    await query.edit_message_text(
                        f"📋 {get_text('event_tasks', lang)}\n\n"
                        f"🎉 {event['event_name'] if event else 'Event'}\n\n"
                        f"No tasks assigned yet.",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"➕ {get_text('manual_task_assign', lang)}", callback_data=f"event_manual_task_{event_id}")],
                            [InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_event_view_{event_id}")]
                        ])
                    )
                    return
                
                text = f"📋 {get_text('event_tasks', lang)}\n\n"
                text += f"🎉 {event['event_name'] if event else 'Event'}\n"
                text += f"📅 {event['event_date'] if event else ''}\n\n"
                text += "═══════════════════════════════\n"
                
                # Status legend
                status_icons = {
                    'pending': '⏳',
                    'accepted': '📥',
                    'in_progress': '🔄',
                    'completed': '✅',
                    'confirmed': '✔️',
                    'cancelled': '❌'
                }
                
                for task in tasks:
                    status_icon = status_icons.get(task['status'], '❓')
                    dept_emoji = get_dept_emoji(task['department'])
                    
                    text += f"{dept_emoji} {task['department']}\n"
                    text += f"  {status_icon} {task['status'].upper()}\n"
                    text += f"  👤 {task['assigned_name'] or 'Unassigned'}\n"
                    
                    # Show task description (truncated)
                    desc = task.get('description', '')
                    if desc:
                        # Remove event header lines if present
                        desc_lines = desc.split('\n')
                        task_desc = ''
                        for line in desc_lines:
                            if line.startswith('📋'):
                                task_desc = line.replace('📋 Task: ', '').replace('📋 ', '')
                                break
                        if not task_desc:
                            task_desc = desc_lines[-1] if desc_lines else desc
                        task_desc = task_desc[:50] + '...' if len(task_desc) > 50 else task_desc
                        text += f"  📋 {task_desc}\n"
                    
                    text += f"  📆 Due: {task['due_date']}\n"
                    
                    # Show timestamps based on status
                    if task['accepted_at']:
                        text += f"  📥 Accepted: {task['accepted_at'][:16]}\n"
                    if task['started_at']:
                        text += f"  🔄 Started: {task['started_at'][:16]}\n"
                    if task['completed_at']:
                        text += f"  ✅ Completed: {task['completed_at'][:16]}\n"
                    if task['proof_photo']:
                        text += f"  📸 Proof: Attached\n"
                    if task['report_notes']:
                        text += f"  📝 Notes: {task['report_notes'][:30]}...\n"
                    
                    text += "───────────────────────────────\n"
                
                text += "\n📊 Legend: ⏳Pending 📥Accepted 🔄InProgress ✅Done ✔️Confirmed"
                
                # Add per-task management buttons
                keyboard = []
                for task in tasks:
                    status_icon = status_icons.get(task['status'], '❓')
                    dept_emoji = get_dept_emoji(task['department'])
                    task_label = f"{dept_emoji} {task['department'][:10]} | {status_icon} | 👁️ View"
                    keyboard.append([InlineKeyboardButton(task_label, callback_data=f"event_task_view_{task['id']}")])
                
                keyboard.append([InlineKeyboardButton(f"➕ {get_text('manual_task_assign', lang)}", callback_data=f"event_manual_task_{event_id}")])
                keyboard.append([InlineKeyboardButton(get_text('refresh', lang), callback_data=f"admin_event_tasks_{event_id}")])
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_event_view_{event_id}")])
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
            
            # Admin Event - View Single Task Detail
            elif query.data.startswith("event_task_view_"):
                from database import get_event_task_by_id
                
                task_id = int(query.data.replace("event_task_view_", ""))
                lang = get_user_language(telegram_user_id, self.db)
                
                task = get_event_task_by_id(self.db, task_id)
                if not task:
                    await query.answer("Task not found!", show_alert=True)
                    return
                
                status_icons = {
                    'pending': '⏳',
                    'accepted': '📥',
                    'in_progress': '🔄',
                    'completed': '✅',
                    'confirmed': '✔️'
                }
                
                text = f"📋 **Task Details**\n"
                text += "═══════════════════════════════\n\n"
                text += f"🏢 Department: {task['department']}\n"
                text += f"📌 Status: {status_icons.get(task['status'], '❓')} {task['status'].upper()}\n"
                text += f"👤 Assigned: {task['assigned_name'] or 'Unassigned'}\n"
                text += f"📆 Due Date: {task['due_date']}\n\n"
                
                # Task description
                text += f"📝 Description:\n{task.get('description', 'No description')}\n\n"
                
                # Timeline
                text += "📊 **Timeline**\n"
                text += f"  📝 Created: {task['created_at'][:16] if task.get('created_at') else 'N/A'}\n"
                if task['accepted_at']:
                    text += f"  📥 Accepted: {task['accepted_at'][:16]} by {task.get('accepted_by', 'N/A')}\n"
                if task['started_at']:
                    text += f"  🔄 Started: {task['started_at'][:16]}\n"
                if task['completed_at']:
                    text += f"  ✅ Completed: {task['completed_at'][:16]} by {task.get('completed_by', 'N/A')}\n"
                if task.get('confirmed_at'):
                    text += f"  ✔️ Confirmed: {task['confirmed_at'][:16]} by {task.get('confirmed_by', 'N/A')}\n"
                
                # Proof and notes
                if task.get('proof_photo'):
                    text += f"\n📸 Proof Photo: Attached\n"
                if task.get('report_notes'):
                    text += f"\n📝 Report Notes:\n{task['report_notes']}\n"
                
                event_id = task['event_id']
                linked_task_id = task.get('task_id')
                
                # Check if linked task has attachments
                has_attachments = False
                if linked_task_id:
                    linked_task = self.db.get_task_by_id(linked_task_id)
                    if linked_task and linked_task[17]:  # report_attachment field
                        try:
                            import json
                            attachments = json.loads(linked_task[17])
                            if attachments:
                                has_attachments = True
                                text += f"\n📸 Attachments: {len(attachments)} file(s)\n"
                        except:
                            pass
                
                # Management buttons - only show confirm button for completed tasks
                keyboard = []
                
                # If task is completed (reported by employee), show confirm button
                if task['status'] == 'completed':
                    keyboard.append([InlineKeyboardButton("✅ Confirm & Approve", callback_data=f"event_task_confirm_{task_id}")])
                
                # Show proof photo button if has attachments or proof_photo
                if has_attachments or task.get('proof_photo'):
                    keyboard.append([InlineKeyboardButton("📸 View Proof Photo", callback_data=f"event_task_photo_{task_id}")])
                
                keyboard.append([InlineKeyboardButton("🗑️ Delete Task", callback_data=f"event_task_delete_{task_id}")])
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_event_tasks_{event_id}")])
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')
            
            # Admin Event - Confirm/Approve Completed Task
            elif query.data.startswith("event_task_confirm_"):
                from database import get_event_task_by_id
                
                task_id = int(query.data.replace("event_task_confirm_", ""))
                lang = get_user_language(telegram_user_id, self.db)
                
                task = get_event_task_by_id(self.db, task_id)
                if not task:
                    await query.answer("Task not found!", show_alert=True)
                    return
                
                # Update task as confirmed/approved
                cursor = self.db.cursor
                now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                cursor.execute("""
                    UPDATE tbl_hotel_event_tasks 
                    SET status = 'confirmed', confirmed_at = %s, confirmed_by = %s
                    WHERE id = %s
                """, (now, f"Admin ({telegram_user_id})", task_id))
                self.db.connection.commit()
                
                await query.answer("✅ Task confirmed and approved!", show_alert=True)
                
                # Return to task view
                query.data = f"event_task_view_{task_id}"
                await self.handle_callback(update, context)
            
            # Admin Event - View Proof Photo
            elif query.data.startswith("event_task_photo_"):
                from database import get_event_task_by_id
                
                task_id = int(query.data.replace("event_task_photo_", ""))
                lang = get_user_language(telegram_user_id, self.db)
                
                task = get_event_task_by_id(self.db, task_id)
                if not task:
                    await query.answer("Task not found!", show_alert=True)
                    return
                
                # Check for attachments from linked task
                linked_task_id = task.get('task_id')
                attachments = []
                if linked_task_id:
                    linked_task = self.db.get_task_by_id(linked_task_id)
                    if linked_task and linked_task[17]:  # report_attachment field
                        try:
                            import json
                            attachments = json.loads(linked_task[17])
                        except:
                            attachments = []
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data=f"event_task_view_{task_id}")]]
                
                if attachments:
                    # Send all attachments from linked task
                    for att in attachments:
                        file_id = att.get('file_id')
                        file_type = att.get('file_type', 'photo')
                        
                        caption = f"📸 Proof for task\n🏢 {task['department']}\n📝 {task.get('report_notes', 'No notes')}"
                        
                        try:
                            if file_type == 'photo':
                                await query.message.reply_photo(
                                    photo=file_id,
                                    caption=caption,
                                    reply_markup=InlineKeyboardMarkup(keyboard)
                                )
                            elif file_type == 'video':
                                await query.message.reply_video(
                                    video=file_id,
                                    caption=caption,
                                    reply_markup=InlineKeyboardMarkup(keyboard)
                                )
                            elif file_type == 'document':
                                await query.message.reply_document(
                                    document=file_id,
                                    caption=caption,
                                    reply_markup=InlineKeyboardMarkup(keyboard)
                                )
                        except Exception as e:
                            print(f"❌ Error sending attachment: {e}")
                elif task.get('proof_photo'):
                    # Fallback to proof_photo in event_tasks table
                    await query.message.reply_photo(
                        photo=task['proof_photo'],
                        caption=f"📸 Proof photo for task\n🏢 {task['department']}\n📝 {task.get('report_notes', 'No notes')}",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    await query.answer("No proof photo attached!", show_alert=True)
            
            # Admin Event - Delete Task Confirmation
            elif query.data.startswith("event_task_delete_") and not "_confirm" in query.data:
                from database import get_event_task_by_id
                
                task_id = int(query.data.replace("event_task_delete_", ""))
                lang = get_user_language(telegram_user_id, self.db)
                
                task = get_event_task_by_id(self.db, task_id)
                if not task:
                    await query.answer("Task not found!", show_alert=True)
                    return
                
                text = f"⚠️ **Delete Task Confirmation**\n\n"
                text += f"Are you sure you want to delete this task?\n\n"
                text += f"🏢 Department: {task['department']}\n"
                text += f"📌 Status: {task['status'].upper()}\n"
                text += f"👤 Assigned: {task['assigned_name'] or 'Unassigned'}\n\n"
                text += "⚠️ This action cannot be undone!"
                
                keyboard = [
                    [InlineKeyboardButton("🗑️ Yes, Delete", callback_data=f"event_task_delete_confirm_{task_id}")],
                    [InlineKeyboardButton("❌ Cancel", callback_data=f"event_task_view_{task_id}")]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')
            
            # Admin Event - Delete Task Execute
            elif query.data.startswith("event_task_delete_confirm_"):
                from database import get_event_task_by_id
                
                task_id = int(query.data.replace("event_task_delete_confirm_", ""))
                lang = get_user_language(telegram_user_id, self.db)
                
                task = get_event_task_by_id(self.db, task_id)
                if not task:
                    await query.answer("Task not found!", show_alert=True)
                    return
                
                event_id = task['event_id']
                
                # Delete task from database
                cursor = self.db.cursor
                cursor.execute("DELETE FROM tbl_hotel_event_tasks WHERE id = %s", (task_id,))
                self.db.connection.commit()
                
                await query.answer("Task deleted successfully!", show_alert=True)
                
                # Return to task list
                query.data = f"admin_event_tasks_{event_id}"
                await self.handle_callback(update, context)
            
            # Admin Event - Event Progress (Table view)
            elif query.data == "admin_event_progress":
                from database import get_upcoming_events, get_event_history
                
                lang = get_user_language(telegram_user_id, self.db)
                events = get_upcoming_events(self.db, 14)  # Next 2 weeks
                
                if not events:
                    await query.edit_message_text(
                        f"{get_text('event_progress', lang)}\n\n{get_text('no_events', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="admin_events")
                        ]])
                    )
                    return
                
                text = f"{get_text('event_progress', lang)}\n\n"
                text += "═══════════════════════════════\n"
                text += "📌 Event | 📅 Date | Dept Status\n"
                text += "═══════════════════════════════\n"
                
                departments = ['Reception', 'Kitchen', 'Housekeeping', 'Warehouse', 'Management']
                keyboard = []
                
                for e in events[:5]:
                    event_id = e[0]
                    event_name = e[1][:15] + "..." if len(e[1]) > 15 else e[1]
                    event_date = e[3]
                    
                    history = get_event_history(self.db, event_id)
                    
                    # Build department status
                    dept_icons = []
                    for dept in departments:
                        dept_history = [h for h in history if h[2] == dept]
                        if dept_history:
                            latest = dept_history[0]
                            if latest[11]:  # ready_confirmed
                                dept_icons.append("✅")
                            elif latest[8]:  # confirmed
                                dept_icons.append("🔶")
                            elif latest[5]:  # acknowledged
                                dept_icons.append("⚪")
                            else:
                                dept_icons.append("❌")
                        else:
                            dept_icons.append("⬜")
                    
                    status_str = "".join(dept_icons)
                    text += f"• {event_name}\n  {event_date} | {status_str}\n"
                    
                    # Add clickable button for each event
                    keyboard.append([InlineKeyboardButton(f"📋 {event_name}", callback_data=f"admin_event_view_{event_id}")])
                
                text += "\n═══════════════════════════════\n"
                text += "Legend: ✅=Ready 🔶=Confirmed ⚪=Ack ❌=No ⬜=N/A\n"
                text += f"Depts: R K H W M\n\n"
                text += "💡 Click an event to update status"
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_events")])
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
            
            # Event Manual Task Assignment - Select Department
            elif query.data.startswith("event_manual_task_"):
                from database import get_event_by_id
                
                lang = get_user_language(telegram_user_id, self.db)
                event_id = int(query.data.replace("event_manual_task_", ""))
                event = get_event_by_id(self.db, event_id)
                
                if not event:
                    await query.answer("Event not found", show_alert=True)
                    return
                
                # Get all departments for task assignment
                departments = self.db.get_departments(exclude_management=False)
                
                if not departments:
                    await query.edit_message_text(
                        f"⚠️ {get_text('no_departments', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_event_view_{event_id}")
                        ]])
                    )
                    return
                
                # Store event info for task creation
                context.user_data['event_task_creation'] = {
                    'event_id': event_id,
                    'event_name': event['event_name'],
                    'event_date': event['event_date'],
                    'event_time': event['event_time'],
                    'step': 'dept'
                }
                
                # Build department buttons
                keyboard = []
                for dept_id, dept_name, dept_content in departments:
                    emoji = get_dept_emoji(dept_name)
                    keyboard.append([InlineKeyboardButton(f"{emoji} {dept_name}", callback_data=f"event_task_dept_{event_id}_{dept_name}")])
                keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_event_view_{event_id}")])
                
                await query.edit_message_text(
                    f"📝 {get_text('manual_task_assign', lang)}\n\n"
                    f"🎉 Event: {event['event_name']}\n"
                    f"📅 Date: {event['event_date']} {event['event_time']}\n\n"
                    f"🏢 {get_text('select_dept_task', lang)}:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            
            # Event Manual Task - Select Employee
            elif query.data.startswith("event_task_dept_"):
                lang = get_user_language(telegram_user_id, self.db)
                parts = query.data.replace("event_task_dept_", "").split("_")
                event_id = int(parts[0])
                dept_name = "_".join(parts[1:]) if len(parts) > 2 else parts[1]
                
                # Get employees in department
                employees = self.db.get_employees_by_department(dept_name)
                
                if not employees:
                    await query.edit_message_text(
                        f"⚠️ {get_text('no_employees_in_dept', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data=f"event_manual_task_{event_id}")
                        ]])
                    )
                    return
                
                # Update context
                if context.user_data.get('event_task_creation'):
                    context.user_data['event_task_creation']['dept_name'] = dept_name
                    context.user_data['event_task_creation']['step'] = 'employee'
                
                # Build employee buttons
                keyboard = []
                for emp in employees:
                    emp_id = emp[0]
                    emp_telegram = emp[1] if len(emp) > 1 else None
                    emp_name = emp[2] if len(emp) > 2 else f"Employee {emp_id}"
                    keyboard.append([InlineKeyboardButton(f"👤 {emp_name}", callback_data=f"event_task_emp_{event_id}_{emp_telegram}")])
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data=f"event_manual_task_{event_id}")])
                
                event_data = context.user_data.get('event_task_creation', {})
                await query.edit_message_text(
                    f"📝 {get_text('manual_task_assign', lang)}\n\n"
                    f"🎉 Event: {event_data.get('event_name', '')}\n"
                    f"🏢 {get_text('department', lang)}: {dept_name}\n\n"
                    f"👤 {get_text('select_employee', lang)}:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            
            # Event Manual Task - Enter Description
            elif query.data.startswith("event_task_emp_"):
                lang = get_user_language(telegram_user_id, self.db)
                parts = query.data.replace("event_task_emp_", "").split("_")
                event_id = int(parts[0])
                emp_telegram = int(parts[1])
                
                # Get employee info
                emp_info = self.db.get_employee_info(emp_telegram)
                if not emp_info:
                    await query.answer("Employee not found", show_alert=True)
                    return
                
                emp_name = emp_info['name']
                
                # Update context
                if context.user_data.get('event_task_creation'):
                    context.user_data['event_task_creation']['emp_telegram'] = emp_telegram
                    context.user_data['event_task_creation']['emp_name'] = emp_name
                    context.user_data['event_task_creation']['step'] = 'description'
                
                event_data = context.user_data.get('event_task_creation', {})
                await query.edit_message_text(
                    f"📝 {get_text('manual_task_assign', lang)}\n\n"
                    f"🎉 Event: {event_data.get('event_name', '')}\n"
                    f"🏢 {get_text('department', lang)}: {event_data.get('dept_name', '')}\n"
                    f"👤 {get_text('assigned_to', lang)}: {emp_name}\n\n"
                    f"📋 {get_text('enter_task_description', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_event_view_{event_id}")
                    ]])
                )

            # Event creation - Skip buttons
            elif query.data == "event_skip_end_time":
                lang = get_user_language(telegram_user_id, self.db)
                if context.user_data.get('creating_event'):
                    context.user_data['creating_event']['end_time'] = None
                    context.user_data['creating_event']['step'] = 'seats'
                    await query.edit_message_text(
                        f"{get_text('enter_event_seats', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")
                        ]])
                    )
            
            elif query.data == "event_skip_location":
                from templates import get_event_input_step
                
                lang = get_user_language(telegram_user_id, self.db)
                if context.user_data.get('creating_event'):
                    context.user_data['creating_event']['location'] = None
                    context.user_data['creating_event']['step'] = 7
                    
                    step_info = get_event_input_step(lang, 7)
                    await query.edit_message_text(
                        f"✅ {get_event_input_step(lang, 6)['title']}: Skipped\n\n"
                        f"Step 7/7: {step_info['title']}\n\n{step_info['prompt']}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('skip', lang), callback_data="event_skip_notes"),
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")
                        ]])
                    )
            
            elif query.data == "event_skip_notes":
                from database import create_event, create_event_history, create_event_task
                from templates import auto_assign_event_tasks
                
                lang = get_user_language(telegram_user_id, self.db)
                if context.user_data.get('creating_event'):
                    event_data = context.user_data['creating_event']
                    event_data['notes'] = None
                    event_data['created_by'] = telegram_user_id
                    event_data['price'] = 0  # Default price
                    
                    template = event_data.get('template', {})
                    template_name = template.get('name', {}).get(lang, 'Event')
                    
                    # Create event in database
                    event_id = create_event(self.db, event_data)
                    
                    if event_id:
                        # Create event history records for each department in template
                        departments = template.get('departments', ['Reception', 'Kitchen', 'Housekeeping'])
                        for dept in departments:
                            create_event_history(self.db, event_id, dept, 'T-2')
                        
                        # Use AI-based task assignment
                        event_type = event_data.get('event_type', 'custom')
                        assigned_task_ids = auto_assign_event_tasks(self.db, event_id, event_type, event_data['event_date'])
                        
                        tasks_created = len(assigned_task_ids)
                        
                        context.user_data['creating_event'] = None
                        
                        # Log event creation
                        try:
                            event_logger = get_event_logger()
                            event_logger.log_event_created(
                                user_id=telegram_user_id,
                                user_name=query.from_user.full_name,
                                event_id=event_id,
                                event_name=event_data['event_name'],
                                event_type=template_name,
                                event_date=event_data['event_date']
                            )
                        except Exception as log_error:
                            print(f"Event logging error: {log_error}")
                        
                        await query.edit_message_text(
                            f"✅ {get_text('event_created', lang)}\n\n"
                            f"📌 {event_data['event_name']} ({template_name})\n"
                            f"📍 {event_data['hall']}\n"
                            f"📅 {event_data['event_date']} {event_data['event_time']}-{event_data.get('end_time', '')}\n"
                            f"👥 {event_data['seats']} guests\n"
                            f"🍽️ Menu: {event_data.get('menu', 'N/A')}\n\n"
                            f"🤖 AI assigned {tasks_created} tasks to departments",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('event_list', lang), callback_data="admin_event_list"),
                                InlineKeyboardButton(get_text('back', lang), callback_data="admin_events")
                            ]])
                        )
                    else:
                        await query.edit_message_text(
                            "❌ Error creating event",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="admin_events")
                            ]])
                        )
            
            # Event Acknowledge (T-2 day)
            elif query.data.startswith("event_ack_"):
                from database import get_event_history, acknowledge_event_alarm, get_event_by_id
                
                parts = query.data.replace("event_ack_", "").split("_")
                event_id = int(parts[0])
                department = "_".join(parts[1:]) if len(parts) > 1 else parts[1] if len(parts) > 1 else ""
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Find the history record for this event and department
                history = get_event_history(self.db, event_id)
                history_id = None
                for h in history:
                    if h[2] == department and h[3] == 'T-2' and not h[5]:
                        history_id = h[0]
                        break
                
                if history_id:
                    acknowledge_event_alarm(self.db, history_id, telegram_user_id)
                    event = get_event_by_id(self.db, event_id)
                    await query.edit_message_text(
                        f"✅ {get_text('acknowledged', lang)}\n\n"
                        f"📌 {event['event_name'] if event else 'Event'}\n"
                        f"📅 {event['event_date'] if event else ''} {event['event_time'] if event else ''}\n"
                        f"🏢 {department}"
                    )
                else:
                    await query.answer("Already acknowledged", show_alert=True)
            
            # Event Confirm Preparation (T-1 day)
            elif query.data.startswith("event_confirm_"):
                from database import get_event_history, confirm_event_preparation, get_event_by_id
                
                parts = query.data.replace("event_confirm_", "").split("_")
                event_id = int(parts[0])
                department = "_".join(parts[1:]) if len(parts) > 1 else parts[1] if len(parts) > 1 else ""
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Find the history record
                history = get_event_history(self.db, event_id)
                history_id = None
                for h in history:
                    if h[2] == department and h[3] == 'T-1' and not h[8]:
                        history_id = h[0]
                        break
                
                if history_id:
                    confirm_event_preparation(self.db, history_id, telegram_user_id)
                    event = get_event_by_id(self.db, event_id)
                    await query.edit_message_text(
                        f"✅ {get_text('confirmed', lang)}\n\n"
                        f"📌 {event['event_name'] if event else 'Event'}\n"
                        f"📅 {event['event_date'] if event else ''} {event['event_time'] if event else ''}\n"
                        f"🏢 {department} - {get_text('procurement_confirmed', lang)}"
                    )
                else:
                    await query.answer("Already confirmed", show_alert=True)
            
            # Event Confirm READY (Event day)
            elif query.data.startswith("event_ready_"):
                from database import get_event_history, get_event_by_id
                
                parts = query.data.replace("event_ready_", "").split("_")
                event_id = int(parts[0])
                department = "_".join(parts[1:]) if len(parts) > 1 else parts[1] if len(parts) > 1 else ""
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Check if already confirmed
                history = get_event_history(self.db, event_id)
                history_id = None
                for h in history:
                    if h[2] == department and h[3] == 'event_day' and not h[11]:
                        history_id = h[0]
                        break
                
                if history_id:
                    # Ask for proof photo
                    context.user_data['event_ready_confirmation'] = {
                        'event_id': event_id,
                        'department': department,
                        'history_id': history_id
                    }
                    await query.edit_message_text(
                        f"📸 {get_text('event_day_message', lang)}\n\n"
                        f"Please send a photo as proof of READY status.",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="cancel_event_ready")
                        ]])
                    )
                else:
                    await query.answer("Already confirmed READY", show_alert=True)
            
            # Cancel event ready confirmation
            elif query.data == "cancel_event_ready":
                context.user_data['event_ready_confirmation'] = None
                lang = get_user_language(telegram_user_id, self.db)
                await query.edit_message_text(
                    f"❌ {get_text('cancel', lang)}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('back', lang), callback_data="emp_start_menu")
                    ]])
                )
            
            # Admin Tool Management
            elif query.data == "admin_tools":
                from database import get_all_tools, get_open_tool_records
                
                lang = get_user_language(telegram_user_id, self.db)
                tools = get_all_tools(self.db)
                open_records = get_open_tool_records(self.db)
                
                # Calculate total and available
                total_tools = sum(t['total_quantity'] for t in tools) if tools else 0
                available_tools = sum(t['available_quantity'] for t in tools) if tools else 0
                borrowed = total_tools - available_tools
                
                text = f"🔧 {get_text('tool_management', lang)}\n\n"
                text += f"📊 {get_text('total', lang)}: {len(tools) if tools else 0}\n"
                text += f"📦 {get_text('total_items', lang)}: {total_tools}\n"
                text += f"✅ {get_text('available', lang)}: {available_tools} | 🔓 {get_text('borrowed', lang)}: {borrowed}\n"
                
                if open_records:
                    text += f"\n⚠️ {get_text('currently_borrowed', lang)}:\n"
                    for rec in open_records[:5]:
                        text += f"• {rec['tool_name']} x{rec['quantity']} - {rec['person_name']}\n"
                    if len(open_records) > 5:
                        text += f"... +{len(open_records) - 5}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"➕ {get_text('add_tool', lang)}", callback_data="admin_tool_add")],
                    [InlineKeyboardButton(f"📋 {get_text('tool_list', lang)}", callback_data="admin_tool_list")],
                    [InlineKeyboardButton(f"📜 {get_text('history', lang)}", callback_data="admin_tool_history")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="actions")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Tool - Add new tool
            elif query.data == "admin_tool_add":
                lang = get_user_language(telegram_user_id, self.db)
                context.user_data['awaiting_admin_tool_name'] = True
                await query.edit_message_text(
                    f"🔧 {get_text('add_new_tool', lang)}\n\n📝 {get_text('enter_tool_name', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_tools")
                    ]])
                )
            
            # Admin Tool - List all tools
            elif query.data == "admin_tool_list":
                from database import get_all_tools
                lang = get_user_language(telegram_user_id, self.db)
                tools = get_all_tools(self.db)
                
                if not tools:
                    text = f"🔧 {get_text('tool_list', lang)}\n\n{get_text('no_tools_registered', lang)}"
                else:
                    # Create table format
                    text = f"🔧 {get_text('tool_list', lang)}\n\n"
                    text += "```\n"
                    text += f"{'ID':<3} {'Name':<12} {'Desc':<10} {'Qty':<5} {'Avail':<5}\n"
                    text += "─" * 38 + "\n"
                    for tool in tools:
                        name = (tool['name'][:10] + '..') if len(tool['name']) > 12 else tool['name']
                        desc = tool['description'] or '-'
                        desc = (desc[:8] + '..') if len(desc) > 10 else desc
                        text += f"{tool['id']:<3} {name:<12} {desc:<10} {tool['total_quantity']:<5} {tool['available_quantity']:<5}\n"
                    text += "```"
                
                keyboard = []
                row = []
                for tool in tools:
                    avail = tool['available_quantity']
                    total = tool['total_quantity']
                    row.append(InlineKeyboardButton(
                        f"🔧 {tool['name']} ({avail}/{total})",
                        callback_data=f"admin_tool_detail_{tool['id']}"
                    ))
                    if len(row) == 2:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_tools")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="Markdown")
            
            # Admin Tool - Detail view
            elif query.data.startswith("admin_tool_detail_"):
                tool_id = int(query.data.replace("admin_tool_detail_", ""))
                from database import get_tool_by_id
                lang = get_user_language(telegram_user_id, self.db)
                
                tool = get_tool_by_id(self.db, tool_id)
                if not tool:
                    await query.answer(get_text('tool_not_found', lang), show_alert=True)
                    return
                
                avail = tool['available_quantity']
                total = tool['total_quantity']
                borrowed = total - avail
                status = f"✅ {get_text('available', lang)}" if avail > 0 else f"❌ {get_text('unavailable', lang)}"
                
                text = f"🔧 {tool['name']}\n\n"
                text += f"📋 {get_text('description', lang)}: {tool['description'] or get_text('no_description', lang)}\n\n"
                text += f"📦 {get_text('total', lang)}: {total}\n"
                text += f"✅ {get_text('available', lang)}: {avail}\n"
                text += f"🔓 {get_text('borrowed', lang)}: {borrowed}\n"
                text += f"📊 {get_text('status', lang)}: {status}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"✏️ {get_text('edit', lang)}", callback_data=f"admin_tool_edit_{tool_id}"),
                     InlineKeyboardButton(f"🗑️ {get_text('delete', lang)}", callback_data=f"admin_tool_delete_{tool_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="admin_tool_list")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Tool - Edit
            elif query.data.startswith("admin_tool_edit_"):
                tool_id = int(query.data.replace("admin_tool_edit_", ""))
                from database import get_tool_by_id
                lang = get_user_language(telegram_user_id, self.db)
                
                tool = get_tool_by_id(self.db, tool_id)
                if not tool:
                    await query.answer(get_text('tool_not_found', lang), show_alert=True)
                    return
                
                context.user_data['editing_admin_tool_id'] = tool_id
                context.user_data['awaiting_admin_tool_edit_name'] = True
                
                await query.edit_message_text(
                    f"✏️ {get_text('edit_tool', lang)}: {tool['name']}\n\n"
                    f"{get_text('current_name', lang)}: {tool['name']}\n"
                    f"{get_text('current_description', lang)}: {tool['description'] or get_text('none', lang)}\n"
                    f"{get_text('current_quantity', lang)}: {tool['total_quantity']}\n\n"
                    f"📝 {get_text('enter_new_name', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_tool_detail_{tool_id}")
                    ]])
                )
            
            # Admin Tool - Delete confirmation
            elif query.data.startswith("admin_tool_delete_"):
                tool_id = int(query.data.replace("admin_tool_delete_", ""))
                from database import get_tool_by_id
                lang = get_user_language(telegram_user_id, self.db)
                
                tool = get_tool_by_id(self.db, tool_id)
                if not tool:
                    await query.answer(get_text('tool_not_found', lang), show_alert=True)
                    return
                
                text = f"🗑️ {get_text('delete_tool', lang)}\n\n"
                text += f"🔧 {tool['name']}\n"
                text += f"📋 {tool['description'] or get_text('no_description', lang)}\n\n"
                text += f"⚠️ {get_text('are_you_sure', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(f"✅ {get_text('yes_delete', lang)}", callback_data=f"admin_tool_delete_confirm_{tool_id}")],
                    [InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_tool_detail_{tool_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Tool - Delete confirm
            elif query.data.startswith("admin_tool_delete_confirm_"):
                tool_id = int(query.data.replace("admin_tool_delete_confirm_", ""))
                from database import delete_tool, get_all_tools
                lang = get_user_language(telegram_user_id, self.db)
                
                if delete_tool(self.db, tool_id):
                    await query.answer(f"✅ {get_text('tool_deleted', lang)}", show_alert=True)
                    
                    # Show tool list
                    tools = get_all_tools(self.db)
                    
                    if not tools:
                        text = f"🔧 {get_text('tool_list', lang)}\n\n{get_text('no_tools_registered', lang)}"
                    else:
                        text = f"🔧 {get_text('tool_list', lang)}\n\n"
                        for tool in tools:
                            avail = tool['available_quantity']
                            total = tool['total_quantity']
                            status_icon = "✅" if avail > 0 else "❌"
                            text += f"{status_icon} {tool['name']}: {avail}/{total}\n"
                    
                    keyboard = []
                    row = []
                    for tool in tools:
                        avail = tool['available_quantity']
                        total = tool['total_quantity']
                        row.append(InlineKeyboardButton(
                            f"🔧 {tool['name']} ({avail}/{total})",
                            callback_data=f"admin_tool_detail_{tool['id']}"
                        ))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_tools")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('delete_error', lang), show_alert=True)
            
            # Admin Tool - History
            elif query.data == "admin_tool_history":
                lang = get_user_language(telegram_user_id, self.db)
                cursor = self.db.connection.cursor()
                cursor.execute("""
                    SELECT th.id, th.tool_name, th.person_name, th.quantity, th.status, th.taken_at, th.returned_at
                    FROM tbl_tool_history th
                    ORDER BY th.taken_at DESC
                    LIMIT 20
                """)
                records = cursor.fetchall()
                
                if not records:
                    text = f"📜 {get_text('history', lang)}\n\n{get_text('no_records', lang)}"
                else:
                    text = f"📜 {get_text('tool_history', lang)}\n\n"
                    for rec in records:
                        status_icon = "🔓" if rec[4] == "Opened" else "✅"
                        text += f"{status_icon} {rec[1]} x{rec[3]} - {rec[2]}\n"
                        text += f"   📅 {str(rec[5])[:10] if rec[5] else 'N/A'}\n"
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="admin_tools")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ==================== ADMIN TRANSPORTATION MANAGEMENT ====================
            
            # Admin Transportation - Main menu
            elif query.data == "admin_transport":
                from database import get_all_transportations
                
                lang = get_user_language(telegram_user_id, self.db)
                vehicles = get_all_transportations(self.db)
                
                text = f"🚗 {get_text('transportation_management', lang)}\n\n"
                text += f"📊 {get_text('total_vehicles', lang)}: {len(vehicles) if vehicles else 0}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"➕ {get_text('add_vehicle', lang)}", callback_data="admin_vehicle_add"),
                     InlineKeyboardButton(f"📋 {get_text('vehicle_list', lang)}", callback_data="admin_vehicle_list")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="actions")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Transportation - Add (ask for plate number)
            elif query.data == "admin_vehicle_add":
                lang = get_user_language(telegram_user_id, self.db)
                context.user_data['awaiting_vehicle_plate'] = True
                await query.edit_message_text(
                    f"🚗 {get_text('add_new_vehicle', lang)}\n\n📝 {get_text('enter_plate_number', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_transport")
                    ]])
                )
            
            # Admin Transportation - List all vehicles
            elif query.data == "admin_vehicle_list":
                from database import get_all_transportations
                lang = get_user_language(telegram_user_id, self.db)
                vehicles = get_all_transportations(self.db)
                
                if not vehicles:
                    text = f"🚗 {get_text('vehicle_list', lang)}\n\n{get_text('no_vehicles_registered', lang)}"
                else:
                    # Create table format
                    text = f"🚗 {get_text('vehicle_list', lang)}\n\n"
                    text += "```\n"
                    text += f"{'ID':<3} {'Plate':<12} {'Name':<12} {'Type':<10}\n"
                    text += "─" * 40 + "\n"
                    for v in vehicles:
                        plate = (v['plate_number'][:10] + '..') if len(v['plate_number']) > 12 else v['plate_number']
                        name = (v['name'][:10] + '..') if len(v['name']) > 12 else v['name']
                        vtype = v['vehicle_type'][:8] if len(v['vehicle_type']) > 10 else v['vehicle_type']
                        text += f"{v['id']:<3} {plate:<12} {name:<12} {vtype:<10}\n"
                    text += "```"
                
                keyboard = []
                row = []
                for v in vehicles:
                    type_emoji = {'Car': '🚗', 'Van': '🚐', 'Truck': '🚚', 'Bus': '🚌', 'Motorcycle': '🏍️', 'Other': '🚙'}.get(v['vehicle_type'], '🚗')
                    row.append(InlineKeyboardButton(
                        f"{type_emoji} {v['name']}",
                        callback_data=f"admin_vehicle_detail_{v['id']}"
                    ))
                    if len(row) == 2:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_transport")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="Markdown")
            
            # Admin Transportation - Detail view
            elif query.data.startswith("admin_vehicle_detail_"):
                vehicle_id = int(query.data.replace("admin_vehicle_detail_", ""))
                from database import get_transportation_by_id
                lang = get_user_language(telegram_user_id, self.db)
                
                vehicle = get_transportation_by_id(self.db, vehicle_id)
                if not vehicle:
                    await query.answer(get_text('vehicle_not_found', lang), show_alert=True)
                    return
                
                type_emoji = {'Car': '🚗', 'Van': '🚐', 'Truck': '🚚', 'Bus': '🚌', 'Motorcycle': '🏍️', 'Other': '🚙'}.get(vehicle['vehicle_type'], '🚗')
                type_name = get_text(vehicle['vehicle_type'].lower(), lang) if vehicle['vehicle_type'].lower() in ['car', 'van', 'truck', 'bus', 'motorcycle'] else get_text('other_vehicle', lang)
                
                text = f"{type_emoji} {vehicle['name']}\n\n"
                text += f"🔢 {get_text('plate_number', lang)}: {vehicle['plate_number']}\n"
                text += f"📋 {get_text('vehicle_type', lang)}: {type_name}\n"
                text += f"📝 {get_text('description', lang)}: {vehicle['description'] or get_text('no_description', lang)}\n"
                text += f"📅 {get_text('created', lang)}: {vehicle['created_at'][:10] if vehicle['created_at'] else 'N/A'}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"✏️ {get_text('edit', lang)}", callback_data=f"admin_vehicle_edit_{vehicle_id}"),
                     InlineKeyboardButton(f"🗑️ {get_text('delete', lang)}", callback_data=f"admin_vehicle_delete_{vehicle_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="admin_vehicle_list")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Transportation - Edit
            elif query.data.startswith("admin_vehicle_edit_"):
                vehicle_id = int(query.data.replace("admin_vehicle_edit_", ""))
                from database import get_transportation_by_id
                lang = get_user_language(telegram_user_id, self.db)
                
                vehicle = get_transportation_by_id(self.db, vehicle_id)
                if not vehicle:
                    await query.answer(get_text('vehicle_not_found', lang), show_alert=True)
                    return
                
                context.user_data['editing_vehicle_id'] = vehicle_id
                context.user_data['awaiting_vehicle_edit_plate'] = True
                
                await query.edit_message_text(
                    f"✏️ {get_text('edit_vehicle', lang)}: {vehicle['name']}\n\n"
                    f"{get_text('current_name', lang)}: {vehicle['name']}\n"
                    f"{get_text('plate_number', lang)}: {vehicle['plate_number']}\n"
                    f"{get_text('vehicle_type', lang)}: {vehicle['vehicle_type']}\n\n"
                    f"📝 {get_text('enter_plate_number', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_vehicle_detail_{vehicle_id}")
                    ]])
                )
            
            # Admin Transportation - Delete confirmation
            elif query.data.startswith("admin_vehicle_delete_"):
                vehicle_id = int(query.data.replace("admin_vehicle_delete_", ""))
                from database import get_transportation_by_id
                lang = get_user_language(telegram_user_id, self.db)
                
                vehicle = get_transportation_by_id(self.db, vehicle_id)
                if not vehicle:
                    await query.answer(get_text('vehicle_not_found', lang), show_alert=True)
                    return
                
                text = f"🗑️ {get_text('delete_vehicle', lang)}\n\n"
                text += f"🚗 {vehicle['name']}\n"
                text += f"🔢 {vehicle['plate_number']}\n\n"
                text += f"⚠️ {get_text('are_you_sure', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(f"✅ {get_text('yes_delete', lang)}", callback_data=f"admin_vehicle_delete_confirm_{vehicle_id}")],
                    [InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_vehicle_detail_{vehicle_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Transportation - Delete confirm
            elif query.data.startswith("admin_vehicle_delete_confirm_"):
                vehicle_id = int(query.data.replace("admin_vehicle_delete_confirm_", ""))
                from database import delete_transportation, get_all_transportations
                lang = get_user_language(telegram_user_id, self.db)
                
                if delete_transportation(self.db, vehicle_id):
                    await query.answer(f"✅ {get_text('vehicle_deleted', lang)}", show_alert=True)
                    
                    # Show vehicle list
                    vehicles = get_all_transportations(self.db)
                    
                    if not vehicles:
                        text = f"🚗 {get_text('vehicle_list', lang)}\n\n{get_text('no_vehicles_registered', lang)}"
                    else:
                        text = f"🚗 {get_text('vehicle_list', lang)}\n\n"
                        text += "```\n"
                        text += f"{'ID':<3} {'Plate':<12} {'Name':<12} {'Type':<10}\n"
                        text += "─" * 40 + "\n"
                        for v in vehicles:
                            plate = (v['plate_number'][:10] + '..') if len(v['plate_number']) > 12 else v['plate_number']
                            name = (v['name'][:10] + '..') if len(v['name']) > 12 else v['name']
                            vtype = v['vehicle_type'][:8] if len(v['vehicle_type']) > 10 else v['vehicle_type']
                            text += f"{v['id']:<3} {plate:<12} {name:<12} {vtype:<10}\n"
                        text += "```"
                    
                    keyboard = []
                    row = []
                    for v in vehicles:
                        type_emoji = {'Car': '🚗', 'Van': '🚐', 'Truck': '🚚', 'Bus': '🚌', 'Motorcycle': '🏍️', 'Other': '🚙'}.get(v['vehicle_type'], '🚗')
                        row.append(InlineKeyboardButton(
                            f"{type_emoji} {v['name']}",
                            callback_data=f"admin_vehicle_detail_{v['id']}"
                        ))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_transport")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="Markdown")
                else:
                    await query.answer(get_text('delete_error', lang), show_alert=True)
            
            # Admin Transportation - Select vehicle type
            elif query.data.startswith("admin_vehicle_type_"):
                vehicle_type = query.data.replace("admin_vehicle_type_", "")
                lang = get_user_language(telegram_user_id, self.db)
                
                context.user_data['new_vehicle_type'] = vehicle_type
                context.user_data['awaiting_vehicle_desc'] = True
                
                type_emoji = {'Car': '🚗', 'Van': '🚐', 'Truck': '🚚', 'Bus': '🚌', 'Motorcycle': '🏍️', 'Other': '🚙'}.get(vehicle_type, '🚗')
                
                await query.edit_message_text(
                    f"🚗 {get_text('add_new_vehicle', lang)}\n\n"
                    f"🔢 {get_text('plate_number', lang)}: {context.user_data.get('new_vehicle_plate')}\n"
                    f"📝 {get_text('vehicle_name', lang)}: {context.user_data.get('new_vehicle_name')}\n"
                    f"{type_emoji} {get_text('vehicle_type', lang)}: {vehicle_type}\n\n"
                    f"📋 {get_text('enter_vehicle_description', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_transport")
                    ]])
                )
            
            # ==================== ADMIN STORAGE MANAGEMENT ====================
            # Admin Storage Management Menu
            elif query.data == "admin_storage":
                from database import get_all_storages
                lang = get_user_language(telegram_user_id, self.db)
                storages = get_all_storages(self.db)
                
                text = f"📦 <b>{get_text('storage_management', lang)}</b>\n\n"
                text += f"📊 {get_text('total_storages', lang)}: {len(storages)}\n"
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"➕ {get_text('add_storage', lang)}", callback_data="admin_storage_add"),
                        InlineKeyboardButton(f"📋 {get_text('storage_list', lang)}", callback_data="admin_storage_list")
                    ],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="actions")]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="HTML")
            
            # Admin Storage - Add storage
            elif query.data == "admin_storage_add":
                lang = get_user_language(telegram_user_id, self.db)
                context.user_data['awaiting_storage_name'] = True
                
                await query.edit_message_text(
                    f"📦 {get_text('add_new_storage', lang)}\n\n"
                    f"📝 {get_text('enter_storage_name', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_storage")
                    ]])
                )
            
            # Admin Storage - List storages
            elif query.data == "admin_storage_list":
                from database import get_all_storages
                lang = get_user_language(telegram_user_id, self.db)
                storages = get_all_storages(self.db)
                
                if not storages:
                    await query.edit_message_text(
                        f"📦 {get_text('storage_list', lang)}\n\n"
                        f"❌ {get_text('no_storages_registered', lang)}",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"➕ {get_text('add_storage', lang)}", callback_data="admin_storage_add")],
                            [InlineKeyboardButton(get_text('back', lang), callback_data="admin_storage")]
                        ])
                    )
                else:
                    type_emojis = {'Food': '🍎', 'Chemicals': '🧪', 'ToolRoom': '🔧', 'Shop': '🛒', 'Other': '📦'}
                    
                    text = f"📦 {get_text('storage_list', lang)}\n\n"
                    text += f"📊 {get_text('total_storages', lang)}: {len(storages)}\n\n"
                    text += "```\n"
                    text += f"{'ID':<3} {'Name':<15} {'Type':<12}\n"
                    text += "─" * 32 + "\n"
                    for s in storages:
                        sname = (s['name'][:13] + '..') if len(s['name']) > 15 else s['name']
                        stype = s['storage_type'][:10] if len(s['storage_type']) > 12 else s['storage_type']
                        text += f"{s['id']:<3} {sname:<15} {stype:<12}\n"
                    text += "```"
                    
                    keyboard = []
                    row = []
                    for s in storages:
                        type_emoji = type_emojis.get(s['storage_type'], '📦')
                        row.append(InlineKeyboardButton(
                            f"{type_emoji} {s['name']}",
                            callback_data=f"admin_storage_detail_{s['id']}"
                        ))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_storage")])
                    
                    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")
            
            # Admin Storage - Storage detail
            elif query.data.startswith("admin_storage_detail_"):
                storage_id = int(query.data.replace("admin_storage_detail_", ""))
                from database import get_storage_by_id
                lang = get_user_language(telegram_user_id, self.db)
                storage = get_storage_by_id(self.db, storage_id)
                
                if not storage:
                    await query.answer(get_text('storage_not_found', lang), show_alert=True)
                    return
                
                type_emojis = {'Food': '🍎', 'Chemicals': '🧪', 'ToolRoom': '🔧', 'Shop': '🛒', 'Other': '📦'}
                type_emoji = type_emojis.get(storage['storage_type'], '📦')
                
                text = (
                    f"📦 <b>{get_text('storage_info', lang)}</b>\n\n"
                    f"{type_emoji} <b>{get_text('storage_name', lang)}:</b> {storage['name']}\n"
                    f"📋 <b>{get_text('storage_type', lang)}:</b> {storage['storage_type']}\n"
                    f"📝 <b>{get_text('description', lang)}:</b> {storage['description'] or get_text('no_description', lang)}\n"
                    f"📅 <b>{get_text('created_at', lang)}:</b> {storage['created_at'][:10] if storage['created_at'] else '-'}"
                )
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"✏️ {get_text('edit', lang)}", callback_data=f"admin_storage_edit_{storage_id}"),
                        InlineKeyboardButton(f"🗑️ {get_text('delete', lang)}", callback_data=f"admin_storage_delete_{storage_id}")
                    ],
                    [InlineKeyboardButton(f"⬅️ {get_text('back', lang)}", callback_data="admin_storage_list")]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="HTML")
            
            # Admin Storage - Delete storage
            elif query.data.startswith("admin_storage_delete_"):
                storage_id = int(query.data.replace("admin_storage_delete_", ""))
                from database import get_storage_by_id
                lang = get_user_language(telegram_user_id, self.db)
                storage = get_storage_by_id(self.db, storage_id)
                
                if not storage:
                    await query.answer(get_text('storage_not_found', lang), show_alert=True)
                    return
                
                text = (
                    f"🗑️ <b>{get_text('delete_storage', lang)}</b>\n\n"
                    f"📦 {storage['name']}\n"
                    f"📋 {storage['storage_type']}\n\n"
                    f"⚠️ {get_text('confirm_delete', lang)}"
                )
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"✅ {get_text('yes', lang)}", callback_data=f"admin_storage_delete_confirm_{storage_id}"),
                        InlineKeyboardButton(f"❌ {get_text('no', lang)}", callback_data=f"admin_storage_detail_{storage_id}")
                    ]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="HTML")
            
            # Admin Storage - Confirm delete
            elif query.data.startswith("admin_storage_delete_confirm_"):
                storage_id = int(query.data.replace("admin_storage_delete_confirm_", ""))
                from database import delete_storage, get_all_storages
                lang = get_user_language(telegram_user_id, self.db)
                
                if delete_storage(self.db, storage_id):
                    storages = get_all_storages(self.db)
                    type_emojis = {'Food': '🍎', 'Chemicals': '🧪', 'ToolRoom': '🔧', 'Shop': '🛒', 'Other': '📦'}
                    
                    text = f"✅ {get_text('storage_deleted', lang)}\n\n"
                    text += f"📦 {get_text('storage_list', lang)}\n"
                    text += f"📊 {get_text('total_storages', lang)}: {len(storages)}\n\n"
                    
                    if storages:
                        text += "```\n"
                        text += f"{'ID':<3} {'Name':<15} {'Type':<12}\n"
                        text += "─" * 32 + "\n"
                        for s in storages:
                            sname = (s['name'][:13] + '..') if len(s['name']) > 15 else s['name']
                            stype = s['storage_type'][:10] if len(s['storage_type']) > 12 else s['storage_type']
                            text += f"{s['id']:<3} {sname:<15} {stype:<12}\n"
                        text += "```"
                    
                    keyboard = []
                    row = []
                    for s in storages:
                        type_emoji = type_emojis.get(s['storage_type'], '📦')
                        row.append(InlineKeyboardButton(
                            f"{type_emoji} {s['name']}",
                            callback_data=f"admin_storage_detail_{s['id']}"
                        ))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_storage")])
                    
                    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")
                else:
                    await query.answer(get_text('delete_error', lang), show_alert=True)
            
            # Admin Storage - Edit storage
            elif query.data.startswith("admin_storage_edit_"):
                storage_id = int(query.data.replace("admin_storage_edit_", ""))
                from database import get_storage_by_id
                lang = get_user_language(telegram_user_id, self.db)
                storage = get_storage_by_id(self.db, storage_id)
                
                if not storage:
                    await query.answer(get_text('storage_not_found', lang), show_alert=True)
                    return
                
                context.user_data['editing_storage_id'] = storage_id
                context.user_data['awaiting_storage_edit_name'] = True
                
                await query.edit_message_text(
                    f"✏️ {get_text('edit_storage', lang)}\n\n"
                    f"📦 {get_text('storage_name', lang)}: {storage['name']}\n"
                    f"📋 {get_text('storage_type', lang)}: {storage['storage_type']}\n\n"
                    f"📝 {get_text('enter_storage_name', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_storage_detail_{storage_id}")
                    ]])
                )
            
            # Admin Storage - Select type for add
            elif query.data.startswith("admin_storage_type_"):
                storage_type = query.data.replace("admin_storage_type_", "")
                lang = get_user_language(telegram_user_id, self.db)
                
                context.user_data['new_storage_type'] = storage_type
                context.user_data['awaiting_storage_desc'] = True
                
                type_emojis = {'Food': '🍎', 'Chemicals': '🧪', 'ToolRoom': '🔧', 'Shop': '🛒', 'Other': '📦'}
                type_emoji = type_emojis.get(storage_type, '📦')
                
                await query.edit_message_text(
                    f"📦 {get_text('add_new_storage', lang)}\n\n"
                    f"📝 {get_text('storage_name', lang)}: {context.user_data.get('new_storage_name')}\n"
                    f"{type_emoji} {get_text('storage_type', lang)}: {storage_type}\n\n"
                    f"📋 {get_text('enter_storage_description', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_storage")
                    ]])
                )
            
            # ==================== ADMIN SERVICE CONTACTS MANAGEMENT ====================
            # Admin Service Contacts Management Menu
            elif query.data == "admin_contacts":
                from database import get_all_contacts
                lang = get_user_language(telegram_user_id, self.db)
                
                # Check if user is admin or reception
                employee_info = self.db.get_employee_info(telegram_user_id)
                is_admin = self.db.check_admin(telegram_user_id)
                is_reception = employee_info and employee_info.get('department') == 'Reception'
                
                if not is_admin and not is_reception:
                    await query.edit_message_text(get_text('command_not_available', lang))
                    return
                
                contacts = get_all_contacts(self.db)
                
                text = f"📞 <b>{get_text('service_contacts', lang)}</b>\n\n"
                text += f"📊 {get_text('total_contacts', lang)}: {len(contacts)}\n"
                
                # Back button based on user type
                back_callback = "back_to_admin" if is_admin else "back_to_employee_menu"
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"➕ {get_text('add_contact', lang)}", callback_data="admin_contact_add"),
                        InlineKeyboardButton(f"📋 {get_text('contact_list', lang)}", callback_data="admin_contact_list")
                    ],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=back_callback)]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="HTML")
            
            # Admin Contact - Add contact
            elif query.data == "admin_contact_add":
                lang = get_user_language(telegram_user_id, self.db)
                context.user_data['awaiting_contact_name'] = True
                
                await query.edit_message_text(
                    f"📞 {get_text('add_new_contact', lang)}\n\n"
                    f"📝 {get_text('enter_contact_name', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_contacts")
                    ]])
                )
            
            # Admin Contact - List contacts
            elif query.data == "admin_contact_list":
                from database import get_all_contacts
                lang = get_user_language(telegram_user_id, self.db)
                contacts = get_all_contacts(self.db)
                
                if not contacts:
                    await query.edit_message_text(
                        f"📞 {get_text('contact_list', lang)}\n\n"
                        f"❌ {get_text('no_contacts_registered', lang)}",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"➕ {get_text('add_contact', lang)}", callback_data="admin_contact_add")],
                            [InlineKeyboardButton(get_text('back', lang), callback_data="admin_contacts")]
                        ])
                    )
                else:
                    type_emojis = {'Electrician': '⚡', 'Heating': '🔥', 'Internet': '🌐', 'PPService': '🔧', 'PestControl': '🐛', 'Taxi': '🚕', 'Other': '📞'}
                    
                    text = f"📞 {get_text('contact_list', lang)}\n\n"
                    text += f"📊 {get_text('total_contacts', lang)}: {len(contacts)}\n\n"
                    text += "```\n"
                    text += f"{'ID':<3} {'Name':<12} {'Type':<12}\n"
                    text += "─" * 30 + "\n"
                    for c in contacts:
                        cname = (c['name'][:10] + '..') if len(c['name']) > 12 else c['name']
                        ctype = c['contact_type'][:10] if len(c['contact_type']) > 12 else c['contact_type']
                        text += f"{c['id']:<3} {cname:<12} {ctype:<12}\n"
                    text += "```"
                    
                    keyboard = []
                    row = []
                    for c in contacts:
                        type_emoji = type_emojis.get(c['contact_type'], '📞')
                        row.append(InlineKeyboardButton(
                            f"{type_emoji} {c['name']}",
                            callback_data=f"admin_contact_detail_{c['id']}"
                        ))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_contacts")])
                    
                    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")
            
            # Admin Contact - Contact detail
            elif query.data.startswith("admin_contact_detail_"):
                contact_id = int(query.data.replace("admin_contact_detail_", ""))
                from database import get_contact_by_id
                lang = get_user_language(telegram_user_id, self.db)
                contact = get_contact_by_id(self.db, contact_id)
                
                if not contact:
                    await query.answer(get_text('contact_not_found', lang), show_alert=True)
                    return
                
                type_emojis = {'Electrician': '⚡', 'Heating': '🔥', 'Internet': '🌐', 'PPService': '🔧', 'PestControl': '🐛', 'Taxi': '🚕', 'Other': '📞'}
                type_emoji = type_emojis.get(contact['contact_type'], '📞')
                
                # Format created_at datetime
                from datetime import datetime as dt
                created_at_str = '-'
                if contact['created_at']:
                    if isinstance(contact['created_at'], dt):
                        created_at_str = contact['created_at'].strftime('%Y-%m-%d')
                    else:
                        created_at_str = contact['created_at'][:10]
                
                text = (
                    f"📞 <b>{get_text('contact_info', lang)}</b>\n\n"
                    f"{type_emoji} <b>{get_text('contact_name', lang)}:</b> {contact['name']}\n"
                    f"📋 <b>{get_text('contact_type', lang)}:</b> {contact['contact_type']}\n"
                    f"📧 <b>{get_text('contact_email', lang)}:</b> {contact['email']}\n"
                    f"📱 <b>{get_text('contact_whatsapp', lang)}:</b> {contact['whatsapp']}\n"
                    f"📝 <b>{get_text('description', lang)}:</b> {contact['description'] or get_text('no_description', lang)}\n"
                    f"📅 <b>{get_text('created_at', lang)}:</b> {created_at_str}"
                )
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"✏️ {get_text('edit', lang)}", callback_data=f"admin_contact_edit_{contact_id}"),
                        InlineKeyboardButton(f"🗑️ {get_text('delete', lang)}", callback_data=f"admin_contact_delete_{contact_id}")
                    ],
                    [InlineKeyboardButton(f"⬅️ {get_text('back', lang)}", callback_data="admin_contact_list")]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="HTML")
            
            # Admin Contact - Delete contact
            elif query.data.startswith("admin_contact_delete_"):
                contact_id = int(query.data.replace("admin_contact_delete_", ""))
                from database import get_contact_by_id
                lang = get_user_language(telegram_user_id, self.db)
                contact = get_contact_by_id(self.db, contact_id)
                
                if not contact:
                    await query.answer(get_text('contact_not_found', lang), show_alert=True)
                    return
                
                text = (
                    f"🗑️ <b>{get_text('delete_contact', lang)}</b>\n\n"
                    f"📞 {contact['name']}\n"
                    f"📧 {contact['email']}\n"
                    f"📱 {contact['whatsapp']}\n\n"
                    f"⚠️ {get_text('confirm_delete', lang)}"
                )
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"✅ {get_text('yes', lang)}", callback_data=f"admin_contact_delete_confirm_{contact_id}"),
                        InlineKeyboardButton(f"❌ {get_text('no', lang)}", callback_data=f"admin_contact_detail_{contact_id}")
                    ]
                ]
                
                await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="HTML")
            
            # Admin Contact - Confirm delete
            elif query.data.startswith("admin_contact_delete_confirm_"):
                contact_id = int(query.data.replace("admin_contact_delete_confirm_", ""))
                from database import delete_contact, get_all_contacts
                lang = get_user_language(telegram_user_id, self.db)
                
                if delete_contact(self.db, contact_id):
                    contacts = get_all_contacts(self.db)
                    type_emojis = {'Electrician': '⚡', 'Heating': '🔥', 'Internet': '🌐', 'PPService': '🔧', 'PestControl': '🐛', 'Taxi': '🚕', 'Other': '📞'}
                    
                    text = f"✅ {get_text('contact_deleted', lang)}\n\n"
                    text += f"📞 {get_text('contact_list', lang)}\n"
                    text += f"📊 {get_text('total_contacts', lang)}: {len(contacts)}\n\n"
                    
                    if contacts:
                        text += "```\n"
                        text += f"{'ID':<3} {'Name':<12} {'Type':<12}\n"
                        text += "─" * 30 + "\n"
                        for c in contacts:
                            cname = (c['name'][:10] + '..') if len(c['name']) > 12 else c['name']
                            ctype = c['contact_type'][:10] if len(c['contact_type']) > 12 else c['contact_type']
                            text += f"{c['id']:<3} {cname:<12} {ctype:<12}\n"
                        text += "```"
                    
                    keyboard = []
                    row = []
                    for c in contacts:
                        type_emoji = type_emojis.get(c['contact_type'], '📞')
                        row.append(InlineKeyboardButton(
                            f"{type_emoji} {c['name']}",
                            callback_data=f"admin_contact_detail_{c['id']}"
                        ))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_contacts")])
                    
                    await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")
                else:
                    await query.answer(get_text('delete_error', lang), show_alert=True)
            
            # Admin Contact - Edit contact
            elif query.data.startswith("admin_contact_edit_"):
                contact_id = int(query.data.replace("admin_contact_edit_", ""))
                from database import get_contact_by_id
                lang = get_user_language(telegram_user_id, self.db)
                contact = get_contact_by_id(self.db, contact_id)
                
                if not contact:
                    await query.answer(get_text('contact_not_found', lang), show_alert=True)
                    return
                
                context.user_data['editing_contact_id'] = contact_id
                context.user_data['awaiting_contact_edit_name'] = True
                
                await query.edit_message_text(
                    f"✏️ {get_text('edit_contact', lang)}\n\n"
                    f"📞 {get_text('contact_name', lang)}: {contact['name']}\n"
                    f"📧 {get_text('contact_email', lang)}: {contact['email']}\n"
                    f"📱 {get_text('contact_whatsapp', lang)}: {contact['whatsapp']}\n\n"
                    f"📝 {get_text('enter_contact_name', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_contact_detail_{contact_id}")
                    ]])
                )
            
            # Admin Contact - Select type for add
            elif query.data.startswith("admin_contact_type_"):
                contact_type = query.data.replace("admin_contact_type_", "")
                lang = get_user_language(telegram_user_id, self.db)
                
                context.user_data['new_contact_type'] = contact_type
                context.user_data['awaiting_contact_email'] = True
                
                type_emojis = {'Electrician': '⚡', 'Heating': '🔥', 'Internet': '🌐', 'PPService': '🔧', 'PestControl': '🐛', 'Taxi': '🚕', 'Other': '📞'}
                type_emoji = type_emojis.get(contact_type, '📞')
                
                await query.edit_message_text(
                    f"📞 {get_text('add_new_contact', lang)}\n\n"
                    f"📝 {get_text('contact_name', lang)}: {context.user_data.get('new_contact_name')}\n"
                    f"{type_emoji} {get_text('contact_type', lang)}: {contact_type}\n\n"
                    f"📧 {get_text('enter_contact_email', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_contacts")
                    ]])
                )
            
            # Reports Management Menu
            elif query.data == "reports_menu":
                lang = get_user_language(telegram_user_id, self.db)
                keyboard = [
                    [InlineKeyboardButton(get_text('view_report', lang), callback_data="action_3")],
                    [InlineKeyboardButton(get_text('daily_report', lang), callback_data="action_4")],
                    [InlineKeyboardButton(get_text('weekly_report', lang), callback_data="action_5")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="actions")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(f"""📊 {get_text('reports', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('select_report', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('select_report_type', lang)}""", reply_markup=reply_markup)
            
            # Report handlers
            elif query.data == "action_3":
                # === VIEW REPORT (Overview) ===
                lang = get_user_language(telegram_user_id, self.db)
                report = self.db.get_overview_report()
                
                if not report:
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="reports_menu")]]
                    await query.edit_message_text(
                        f"❌ {get_text('no_data_available', lang)}",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    from datetime import datetime
                    rooms = report['rooms']
                    tasks = report['tasks']
                    emps = report['employees']
                    week = report['week']
                    
                    # Build progress bars
                    occ_bar = self._progress_bar(rooms['occupancy_rate'])
                    completion_rate = round((tasks['done'] / tasks['total'] * 100), 1) if tasks['total'] > 0 else 0
                    comp_bar = self._progress_bar(completion_rate)
                    
                    text = f"{get_text('report_overview_title', lang)}\n"
                    text += f"{get_text('report_generated', lang)}: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    
                    # Room Status
                    text += f"{get_text('room_statistics', lang)}\n"
                    text += f"  📊 {get_text('total_rooms', lang)}: {rooms['total']}\n"
                    text += f"  🔴 {get_text('occupied_rooms', lang)}: {rooms['occupied']}\n"
                    text += f"  🟢 {get_text('available_rooms', lang)}: {rooms['available']}\n"
                    text += f"  📈 {get_text('occupancy_rate', lang)}: {rooms['occupancy_rate']}%\n"
                    text += f"  {occ_bar}\n"
                    
                    if rooms['room_types']:
                        text += f"\n  📋 {get_text('room_type_breakdown', lang)}:\n"
                        for rt in rooms['room_types']:
                            text += f"    • {rt[0]}: {rt[2]}/{rt[1]}\n"
                    
                    text += "\n"
                    
                    # Task Status
                    text += f"{get_text('task_statistics', lang)}\n"
                    text += f"  📝 {get_text('tasks_created_today', lang)}: {tasks['today']}\n"
                    text += f"  ⏳ {get_text('tasks_pending', lang)}: {tasks['pending']}\n"
                    text += f"  ✅ {get_text('tasks_completed_today', lang)}: {tasks['completed_today']}\n"
                    text += f"  📊 {get_text('total_tasks', lang)}: {tasks['total']} | {get_text('confirmed_tasks', lang)}: {tasks['done']}\n"
                    text += f"  📈 {get_text('task_completion_rate', lang)}: {completion_rate}%\n"
                    text += f"  {comp_bar}\n"
                    
                    if tasks['dept_tasks']:
                        text += f"\n  🏢 {get_text('by_department', lang)}:\n"
                        for dt_row in tasks['dept_tasks']:
                            dept = dt_row[0] or 'N/A'
                            text += f"    • {dept}: {dt_row[2]}/{dt_row[1]} ✅\n"
                    
                    text += "\n"
                    
                    # Employees
                    text += f"{get_text('employee_statistics', lang)}\n"
                    text += f"  � {get_text('total_employees', lang)}: {emps['total']}\n"
                    
                    if emps['top_performers']:
                        text += f"\n  {get_text('top_performers', lang)}:\n"
                        for i, tp in enumerate(emps['top_performers'], 1):
                            medal = ['🥇', '🥈', '🥉', '4️⃣', '5️⃣'][i-1]
                            text += f"    {medal} {tp[0]}: {tp[1]} ✅\n"
                    
                    text += "\n"
                    
                    # Additional Info
                    text += f"📝 {get_text('shift_reports_today', lang)}: {report['shifts_today']}\n"
                    text += f"\n{get_text('weekly_activity', lang)}\n"
                    text += f"  📋 {get_text('tasks_this_week', lang)}: {week['tasks']}\n"
                    text += f"  ✅ {get_text('completed_this_week', lang)}: {week['completed']}\n"
                    text += f"\n{get_text('daily_revenue', lang)}: ${report['revenue_daily']:,.0f}\n"
                    
                    if report['complaints_pending'] > 0:
                        text += f"⚠️ {get_text('pending_complaints', lang)}: {report['complaints_pending']}\n"
                    
                    keyboard = [
                        [InlineKeyboardButton(f"📅 {get_text('daily_report', lang)}", callback_data="action_4"),
                         InlineKeyboardButton(f"📆 {get_text('weekly_report', lang)}", callback_data="action_5")],
                        [InlineKeyboardButton(f"🔄 Refresh", callback_data="action_3")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="reports_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
            
            elif query.data == "action_4":
                # === DAILY REPORT ===
                lang = get_user_language(telegram_user_id, self.db)
                stats = self.db.get_daily_task_statistics()
                
                if not stats:
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="reports_menu")]]
                    await query.edit_message_text(
                        f"❌ {get_text('no_data_available', lang)}",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    from datetime import date
                    today = date.today()
                    
                    text = f"{get_text('daily_report_title', lang)}\n"
                    text += f"📅 {today.strftime('%Y-%m-%d (%A)')}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    
                    text += f"📝 {get_text('tasks_created_today', lang)}: {stats['created_today']}\n"
                    text += f"📆 {get_text('tasks_due_today', lang)}: {stats['due_today']}\n"
                    text += f"✅ {get_text('tasks_completed_today', lang)}: {stats['completed_today']}\n\n"
                    
                    if stats['tasks']:
                        text += f"📋 {get_text('recent_tasks', lang)}:\n"
                        text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                        for task in stats['tasks'][:10]:
                            t_id = task[0]
                            dept = task[2] or 'N/A'
                            name = task[3] or 'N/A'
                            desc = (task[4] or 'N/A')[:30]
                            priority = task[5]
                            is_done = task[6]
                            confirmed = task[7]
                            
                            p_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "⚪")
                            
                            if confirmed:
                                status = "✅"
                            elif is_done:
                                status = "🔄"
                            else:
                                status = "⏳"
                            
                            text += f"  {status} #{t_id} {p_emoji} {name}\n"
                            text += f"     📋 {desc}{'...' if len(task[4] or '') > 30 else ''}\n"
                    else:
                        text += f"\n💤 {get_text('no_data_available', lang)}\n"
                    
                    keyboard = [
                        [InlineKeyboardButton(f"� {get_text('view_report', lang)}", callback_data="action_3"),
                         InlineKeyboardButton(f"📆 {get_text('weekly_report', lang)}", callback_data="action_5")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="reports_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
            
            elif query.data == "action_5":
                # === WEEKLY REPORT ===
                lang = get_user_language(telegram_user_id, self.db)
                stats = self.db.get_weekly_task_statistics()
                
                if not stats:
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="reports_menu")]]
                    await query.edit_message_text(
                        f"❌ {get_text('no_data_available', lang)}",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    text = f"{get_text('weekly_report_title', lang)}\n"
                    text += f"📅 {get_text('week_period', lang)}: {stats['week_start']} ~ {stats['week_end']}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    
                    text += f"📝 {get_text('tasks_created_week', lang)}: {stats['created_this_week']}\n"
                    text += f"✅ {get_text('tasks_completed_week', lang)}: {stats['completed_this_week']}\n"
                    text += f"📆 {get_text('tasks_due_week', lang)}: {stats['due_this_week']}\n\n"
                    
                    comp_rate = round((stats['completed_this_week'] / stats['created_this_week'] * 100), 1) if stats['created_this_week'] > 0 else 0
                    text += f"📈 {get_text('task_completion_rate', lang)}: {comp_rate}%\n"
                    text += f"{self._progress_bar(comp_rate)}\n\n"
                    
                    text += f"� {get_text('day_breakdown', lang)}:\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    
                    day_names_sr = {'Monday': 'Pon', 'Tuesday': 'Uto', 'Wednesday': 'Sre', 'Thursday': 'Čet', 'Friday': 'Pet', 'Saturday': 'Sub', 'Sunday': 'Ned'}
                    
                    for day in stats['daily_stats']:
                        day_name = day_names_sr.get(day['day_name'], day['day_name'][:3]) if lang == 'sr' else day['day_name'][:3]
                        created = day['created']
                        completed = day['completed']
                        bar = '█' * min(created, 10) + '░' * max(0, 10 - created)
                        text += f"  {day_name} {day['date'][5:]}: {bar} 📝{created} ✅{completed}\n"
                    
                    keyboard = [
                        [InlineKeyboardButton(f"📊 {get_text('view_report', lang)}", callback_data="action_3"),
                         InlineKeyboardButton(f"📅 {get_text('daily_report', lang)}", callback_data="action_4")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="reports_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Employees Management Menu
            elif query.data == "employees_menu":
                lang = get_user_language(telegram_user_id, self.db)
                keyboard = [
                    [InlineKeyboardButton(get_text('employee_list', lang), callback_data="emp_list"),
                     InlineKeyboardButton(get_text('work_roles', lang), callback_data="work_roles_menu")],
                    [InlineKeyboardButton(get_text('attendance', lang), callback_data="admin_attendance"),
                     InlineKeyboardButton(get_text('daily_shift', lang), callback_data="duty_check_menu")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="actions")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(f"""{get_text('employees', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('select_option_employees', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('select_option_manage_employees', lang)}""", reply_markup=reply_markup)
            
            # Admin - Hotel Rooms Management
            elif query.data == "admin_hotel_rooms" or query.data.startswith("admin_hotel_rooms_page_"):
                lang = get_user_language(telegram_user_id, self.db)
                from database import get_all_hotel_rooms
                rooms = get_all_hotel_rooms(self.db)
                
                page = 1
                if query.data.startswith("admin_hotel_rooms_page_"):
                    page = int(query.data.replace("admin_hotel_rooms_page_", ""))
                
                active_count = 0
                for r in rooms:
                    if isinstance(r, dict):
                        if r.get('state', 0) == 1:
                            active_count += 1
                    else:
                        if r[3] == 1:
                            active_count += 1
                
                items_per_page = 18
                total_pages = (len(rooms) + items_per_page - 1) // items_per_page
                page = max(1, min(page, total_pages))
                
                start_idx = (page - 1) * items_per_page
                end_idx = min(start_idx + items_per_page, len(rooms))
                page_rooms = rooms[start_idx:end_idx]
                
                text = f"{get_text('office_management', lang)}\n\n"
                text += get_text('total_offices', lang).format(len(rooms)) + "\n"
                text += get_text('active_offices', lang).format(active_count) + "\n"
                text += get_text('inactive_offices', lang).format(len(rooms) - active_count) + "\n\n"
                text += f"📄 {get_text('page', lang)} {page}/{total_pages}\n"
                text += f"{get_text('active', lang)} | {get_text('inactive', lang)}"
                
                keyboard = []
                
                if page_rooms:
                    for i in range(0, len(page_rooms), 3):
                        row = []
                        for j in range(i, min(i + 3, len(page_rooms))):
                            room = page_rooms[j]
                            if isinstance(room, dict):
                                room_id = room['id']
                                name = room['name']
                                state = room.get('state', 0)
                            else:
                                room_id, name, desc, state, created_at, updated_at = room
                            status_icon = "✅" if state == 1 else "❌"
                            short_name = name[:15] + "..." if len(name) > 15 else name
                            row.append(InlineKeyboardButton(
                                f"{status_icon} {short_name}",
                                callback_data=f"admin_hotel_room_{room_id}"
                            ))
                        keyboard.append(row)
                
                nav_row = []
                if page > 1:
                    nav_row.append(InlineKeyboardButton("◀️ " + get_text('previous', lang), callback_data=f"admin_hotel_rooms_page_{page-1}"))
                if page < total_pages:
                    nav_row.append(InlineKeyboardButton(get_text('next', lang) + " ▶️", callback_data=f"admin_hotel_rooms_page_{page+1}"))
                if nav_row:
                    keyboard.append(nav_row)
                
                keyboard.append([InlineKeyboardButton(get_text('add_new_office', lang), callback_data="admin_hotel_room_add")])
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="actions")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin - Keys Management (REMOVED - Only available in Reception)
            # elif query.data == "admin_keys":
            
            # Admin - Key Records (REMOVED - Only available in Reception)
            # elif query.data == "admin_key_records":
            
            # Admin - Add Hotel Room
            elif query.data == "admin_hotel_room_add":
                lang = get_user_language(telegram_user_id, self.db)
                await query.edit_message_text(
                    get_text('enter_room_name', lang),
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_hotel_rooms")
                    ]])
                )
                context.user_data['awaiting_admin_hotel_room_name'] = True
            
            # Admin - Hotel Room Detail
            elif query.data.startswith("admin_hotel_room_") and not query.data.endswith("_add") and not query.data.startswith("admin_hotel_room_toggle_") and not query.data.startswith("admin_hotel_room_edit_") and not query.data.startswith("admin_hotel_room_delete_"):
                from database import get_hotel_room_by_id
                
                room_id = int(query.data.replace("admin_hotel_room_", ""))
                room = get_hotel_room_by_id(self.db, room_id)
                
                if room:
                    lang = get_user_language(telegram_user_id, self.db)
                    state_text = f"✅ {get_text('room_active', lang)}" if room['state'] == 1 else f"❌ {get_text('room_inactive', lang)}"
                    toggle_text = f"❌ {get_text('deactivate_room', lang)}" if room['state'] == 1 else f"✅ {get_text('activate_room', lang)}"
                    
                    text = f"🏢 {room['name']}\n\n"
                    text += f"📋 {get_text('description_label', lang)}:\n{room['description'] or get_text('no_description', lang)}\n\n"
                    text += f"📊 {get_text('status_text', lang)}: {state_text}\n"
                    text += f"📅 {get_text('created_at', lang)}: {room['created_at']}\n"
                    text += f"🔄 {get_text('updated_at', lang)}: {room['updated_at']}"
                    
                    keyboard = [
                        [
                            InlineKeyboardButton(f"{toggle_text}", callback_data=f"admin_hotel_room_toggle_{room_id}"),
                            InlineKeyboardButton(f"✏️ {get_text('edit', lang)}", callback_data=f"admin_hotel_room_edit_{room_id}")
                        ],
                        [InlineKeyboardButton(f"🗑️ {get_text('delete', lang)}", callback_data=f"admin_hotel_room_delete_{room_id}")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="admin_hotel_rooms")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    lang = get_user_language(telegram_user_id, self.db)
                    await query.answer(f"❌ {get_text('room_not_found', lang)}", show_alert=True)
            
            # Admin - Toggle Hotel Room State
            elif query.data.startswith("admin_hotel_room_toggle_"):
                from database import toggle_hotel_room_state, get_hotel_room_by_id
                lang = get_user_language(telegram_user_id, self.db)
                room_id = int(query.data.replace("admin_hotel_room_toggle_", ""))
                
                if toggle_hotel_room_state(self.db, room_id):
                    await query.answer(f"✅ {get_text('status_changed', lang)}", show_alert=True)
                    
                    # Refresh view
                    room = get_hotel_room_by_id(self.db, room_id)
                    if room:
                        state_text = f"✅ {get_text('room_active', lang)}" if room['state'] == 1 else f"❌ {get_text('room_inactive', lang)}"
                        toggle_text = f"❌ {get_text('deactivate_room', lang)}" if room['state'] == 1 else f"✅ {get_text('activate_room', lang)}"
                        
                        text = f"🏢 {room['name']}\n\n"
                        text += f"📋 {get_text('description_label', lang)}:\n{room['description'] or get_text('no_description', lang)}\n\n"
                        text += f"📊 {get_text('status_text', lang)}: {state_text}\n"
                        text += f"📅 {get_text('created_at', lang)}: {room['created_at']}\n"
                        text += f"🔄 {get_text('updated_at', lang)}: {room['updated_at']}"
                        
                        keyboard = [
                            [
                                InlineKeyboardButton(f"{toggle_text}", callback_data=f"admin_hotel_room_toggle_{room_id}"),
                                InlineKeyboardButton(f"✏️ {get_text('edit', lang)}", callback_data=f"admin_hotel_room_edit_{room_id}")
                            ],
                            [InlineKeyboardButton(f"🗑️ {get_text('delete', lang)}", callback_data=f"admin_hotel_room_delete_{room_id}")],
                            [InlineKeyboardButton(get_text('back', lang), callback_data="admin_hotel_rooms")]
                        ]
                        
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("❌ Greška pri promeni statusa", show_alert=True)
            
            # Admin - Edit Hotel Room
            elif query.data.startswith("admin_hotel_room_edit_"):
                room_id = int(query.data.replace("admin_hotel_room_edit_", ""))
                context.user_data['editing_admin_hotel_room_id'] = room_id
                context.user_data['awaiting_admin_hotel_room_edit_name'] = True
                
                lang = get_user_language(telegram_user_id, self.db)
                await query.edit_message_text(
                    get_text('enter_new_room_name', lang),
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_hotel_room_{room_id}")
                    ]])
                )
            
            # Admin - Delete Hotel Room
            elif query.data.startswith("admin_hotel_room_delete_"):
                from database import delete_hotel_room, get_all_hotel_rooms
                room_id = int(query.data.replace("admin_hotel_room_delete_", ""))
                lang = get_user_language(telegram_user_id, self.db)
                
                if delete_hotel_room(self.db, room_id):
                    await query.answer("✅ Prostorija obrisana", show_alert=True)
                    
                    # Return to paginated room list (page 1)
                    rooms = get_all_hotel_rooms(self.db)
                    page = 1
                    
                    active_count = 0
                    for r in rooms:
                        if isinstance(r, dict):
                            if r.get('state', 0) == 1:
                                active_count += 1
                        else:
                            if r[3] == 1:
                                active_count += 1
                    
                    items_per_page = 18
                    total_pages = (len(rooms) + items_per_page - 1) // items_per_page
                    page = max(1, min(page, total_pages))
                    
                    start_idx = (page - 1) * items_per_page
                    end_idx = min(start_idx + items_per_page, len(rooms))
                    page_rooms = rooms[start_idx:end_idx]
                    
                    text = f"{get_text('office_management', lang)}\n\n"
                    text += get_text('total_offices', lang).format(len(rooms)) + "\n"
                    text += get_text('active_offices', lang).format(active_count) + "\n"
                    text += get_text('inactive_offices', lang).format(len(rooms) - active_count) + "\n\n"
                    text += f"📄 {get_text('page', lang)} {page}/{total_pages}\n"
                    text += f"{get_text('active', lang)} | {get_text('inactive', lang)}"
                    
                    keyboard = []
                    
                    if page_rooms:
                        for i in range(0, len(page_rooms), 3):
                            row = []
                            for j in range(i, min(i + 3, len(page_rooms))):
                                room = page_rooms[j]
                                if isinstance(room, dict):
                                    room_id = room['id']
                                    name = room['name']
                                    state = room.get('state', 0)
                                else:
                                    room_id, name, desc, state, created_at, updated_at = room
                                status_icon = "✅" if state == 1 else "❌"
                                short_name = name[:15] + "..." if len(name) > 15 else name
                                row.append(InlineKeyboardButton(
                                    f"{status_icon} {short_name}",
                                    callback_data=f"admin_hotel_room_{room_id}"
                                ))
                            keyboard.append(row)
                    
                    nav_row = []
                    if page > 1:
                        nav_row.append(InlineKeyboardButton("◀️ " + get_text('previous', lang), callback_data=f"admin_hotel_rooms_page_{page-1}"))
                    if page < total_pages:
                        nav_row.append(InlineKeyboardButton(get_text('next', lang) + " ▶️", callback_data=f"admin_hotel_rooms_page_{page+1}"))
                    if nav_row:
                        keyboard.append(nav_row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('add_new_office', lang), callback_data="admin_hotel_room_add")])
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="actions")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('delete_error', lang), show_alert=True)
            
            # Employees List - Show Departments first
            elif query.data == "emp_list":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get all employees to count per department
                employees = self.db.get_all_employees()
                
                # Count employees per department
                dept_counts = {}
                for emp in employees:
                    dept = emp[3]
                    dept_counts[dept] = dept_counts.get(dept, 0) + 1
                
                total_count = len(employees)
                
                text = f"""📋 {get_text('employee_list', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
👥 {get_text('all_employees', lang)}: {total_count}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

"""
                keyboard = []
                
                if dept_counts:
                    for dept_name, count in sorted(dept_counts.items()):
                        dept_emoji = get_dept_emoji(dept_name)
                        dept_display = get_dept_display(dept_name, lang)
                        text += f"{dept_emoji} {dept_display}: {count} 👤\n"
                        keyboard.append([InlineKeyboardButton(
                            f"{dept_emoji} {dept_display} ({count})",
                            callback_data=f"emp_dept_{dept_name}"
                        )])
                else:
                    text += f"{get_text('no_employees', lang)}\n"
                
                text += f"\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n{get_text('select_department_view', lang)}"
                
                keyboard.append([InlineKeyboardButton(f"➕ {get_text('add_new_employee', lang)}", callback_data="emp_add")])
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="employees_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Employees List - Show employees in selected department
            elif query.data.startswith("emp_dept_"):
                dept_name = query.data.replace("emp_dept_", "")
                lang = get_user_language(telegram_user_id, self.db)
                
                employees = self.db.get_employees_by_department(dept_name)
                dept_emoji = get_dept_emoji(dept_name)
                dept_display = get_dept_display(dept_name, lang)
                
                text = f"""{dept_emoji} {dept_display}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
👥 {get_text('employee_list', lang)}: {len(employees)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

"""
                keyboard = []
                
                if employees:
                    for emp in employees:
                        emp_id = emp[0]
                        name = emp[2]
                        work_role = emp[3] if len(emp) > 3 and emp[3] else ""
                        role_text = f" - {work_role}" if work_role else ""
                        text += f"  👤 {name}{role_text}\n"
                        btn_text = f"👤 {name}{role_text}" if work_role else f"👤 {name}"
                        keyboard.append([InlineKeyboardButton(btn_text, callback_data=f"emp_view_{emp_id}")])
                else:
                    text += f"{get_text('no_employees', lang)}\n"
                
                text += f"\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n{get_text('select_employee_manage', lang)}"
                
                keyboard.append([InlineKeyboardButton(f"➕ {get_text('add_new_employee', lang)}", callback_data="emp_add")])
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_list")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # View Employee Details
            elif query.data.startswith("emp_view_"):
                emp_id = query.data.replace("emp_view_", "")
                employee = self.db.get_employee_by_id(emp_id)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not employee:
                    await query.answer(get_text('employee_not_found', lang), show_alert=True)
                    return
                
                dept_display = get_dept_display(employee['department'], lang)
                work_role = employee.get('work_role') or get_text('not_assigned', lang)
                
                text = f"""{get_text('employee_details', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('employee_info_section', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🆔 ID: {employee['employee_id']}
👤 {get_text('name', lang)}: {employee['name']}
🏢 {get_text('department', lang)}: {dept_display}
💼 {get_text('role', lang)}: {work_role}
📱 Telegram ID: {employee['telegram_user_id']}
📅 {get_text('registered', lang)}: {employee['created_at'] or 'N/A'}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('employee_options', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━"""
                
                keyboard = [
                    [InlineKeyboardButton(get_text('edit_name', lang), callback_data=f"emp_edit_name_{emp_id}"),
                     InlineKeyboardButton(get_text('edit_dept', lang), callback_data=f"emp_edit_dept_{emp_id}")],
                    [InlineKeyboardButton(get_text('edit_role', lang), callback_data=f"emp_edit_role_{emp_id}"),
                     InlineKeyboardButton(get_text('delete_emp', lang), callback_data=f"emp_delete_{emp_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"emp_dept_{employee['department']}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Add Employee - Step 1: Enter Telegram ID
            elif query.data == "emp_add":
                context.user_data['emp_add_step'] = 'telegram_id'
                
                lang = get_user_language(telegram_user_id, self.db)
                text = f"""{get_text('add_employee_title', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('step_telegram_id', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('enter_telegram_id', lang)}

{get_text('telegram_id_hint', lang)}"""
                
                keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data="emp_list")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Edit Employee Name
            elif query.data.startswith("emp_edit_name_"):
                emp_id = query.data.replace("emp_edit_name_", "")
                context.user_data['emp_edit_id'] = emp_id
                context.user_data['emp_edit_step'] = 'name'
                
                lang = get_user_language(telegram_user_id, self.db)
                employee = self.db.get_employee_by_id(emp_id)
                
                text = f"""✏️ {get_text('edit_name', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 {get_text('current_name', lang)}: {employee['name'] if employee else 'N/A'}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('enter_new_employee_name', lang)}"""
                
                keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data=f"emp_view_{emp_id}")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Edit Employee Department
            elif query.data.startswith("emp_edit_dept_"):
                emp_id = query.data.replace("emp_edit_dept_", "")
                context.user_data['emp_edit_id'] = emp_id
                
                lang = get_user_language(telegram_user_id, self.db)
                employee = self.db.get_employee_by_id(emp_id)
                departments = self.db.get_departments(exclude_management=False)
                
                current_dept = get_dept_display(employee['department'], lang) if employee else 'N/A'
                
                text = f"""🏢 {get_text('edit_dept', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 {get_text('employee', lang)}: {employee['name'] if employee else 'N/A'}
🏢 {get_text('current', lang)}: {current_dept}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('select_new_department', lang)}"""
                
                keyboard = []
                for dept_id, dept_name, dept_content in departments:
                    emoji = get_dept_emoji(dept_name)
                    dept_display = get_dept_display(dept_name, lang)
                    keyboard.append([InlineKeyboardButton(f"{emoji} {dept_display}", callback_data=f"emp_set_dept_{emp_id}_{dept_name}")])
                
                keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data=f"emp_view_{emp_id}")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Set Employee Department
            elif query.data.startswith("emp_set_dept_"):
                parts = query.data.replace("emp_set_dept_", "").split("_", 1)
                emp_id = parts[0]
                new_dept = parts[1]
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if self.db.update_employee(emp_id, department=new_dept):
                    await query.answer(get_text('dept_changed_success', lang), show_alert=True)
                else:
                    await query.answer(get_text('dept_change_error', lang), show_alert=True)
                
                # Refresh employee view
                employee = self.db.get_employee_by_id(emp_id)
                if employee:
                    dept_display = get_dept_display(employee['department'], lang)
                    work_role = employee.get('work_role') or get_text('not_assigned', lang)
                    
                    text = f"""{get_text('employee_details', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('employee_info_section', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🆔 ID: {employee['employee_id']}
👤 {get_text('name', lang)}: {employee['name']}
🏢 {get_text('department', lang)}: {dept_display}
💼 {get_text('role', lang)}: {work_role}
📱 Telegram ID: {employee['telegram_user_id']}
📅 {get_text('registered', lang)}: {employee['created_at'] or 'N/A'}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('employee_options', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━"""
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('edit_name', lang), callback_data=f"emp_edit_name_{emp_id}")],
                        [InlineKeyboardButton(get_text('edit_dept', lang), callback_data=f"emp_edit_dept_{emp_id}")],
                        [InlineKeyboardButton(get_text('edit_role', lang), callback_data=f"emp_edit_role_{emp_id}")],
                        [InlineKeyboardButton(get_text('delete_emp', lang), callback_data=f"emp_delete_{emp_id}")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="emp_list")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Edit Employee Work Role
            elif query.data.startswith("emp_edit_role_"):
                from database import get_all_work_roles
                
                emp_id = query.data.replace("emp_edit_role_", "")
                employee = self.db.get_employee_by_id(emp_id)
                work_roles = get_all_work_roles(self.db)
                
                current_role = employee.get('work_role') or "Nije dodeljeno" if employee else 'N/A'
                
                lang = get_user_language(telegram_user_id, self.db)
                text = f"""💼 {get_text('change_work_role', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 {get_text('employee', lang)}: {employee['name'] if employee else 'N/A'}
💼 {get_text('current', lang)}: {current_role}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('select_new_work_role', lang)}:"""
                
                keyboard = []
                if work_roles:
                    for role_id, role_name, description, created_at in work_roles:
                        keyboard.append([InlineKeyboardButton(f"💼 {role_name}", callback_data=f"emp_set_role_{emp_id}_{role_id}")])
                else:
                    text += f"\n\n⚠️ {get_text('no_work_roles_available', lang)}"
                
                keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data=f"emp_view_{emp_id}")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Set Employee Work Role
            elif query.data.startswith("emp_set_role_"):
                from database import get_work_role_by_id
                
                parts = query.data.replace("emp_set_role_", "").split("_", 1)
                emp_id = parts[0]
                role_id = int(parts[1])
                
                lang = get_user_language(telegram_user_id, self.db)
                work_role = get_work_role_by_id(self.db, role_id)
                
                if work_role and self.db.update_employee(emp_id, work_role=work_role['role_name']):
                    await query.answer(get_text('role_changed_success', lang), show_alert=True)
                else:
                    await query.answer(get_text('role_change_error', lang), show_alert=True)
                
                # Refresh employee view
                employee = self.db.get_employee_by_id(emp_id)
                if employee:
                    dept_display = get_dept_display(employee['department'], lang)
                    work_role_name = employee.get('work_role') or get_text('not_assigned', lang)
                    
                    text = f"""{get_text('employee_details', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('employee_info_section', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🆔 ID: {employee['employee_id']}
👤 {get_text('name', lang)}: {employee['name']}
🏢 {get_text('department', lang)}: {dept_display}
💼 {get_text('role', lang)}: {work_role_name}
📱 Telegram ID: {employee['telegram_user_id']}
📅 {get_text('registered', lang)}: {employee['created_at'] or 'N/A'}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('employee_options', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━"""
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('edit_name', lang), callback_data=f"emp_edit_name_{emp_id}"),
                         InlineKeyboardButton(get_text('edit_dept', lang), callback_data=f"emp_edit_dept_{emp_id}")],
                        [InlineKeyboardButton(get_text('edit_role', lang), callback_data=f"emp_edit_role_{emp_id}"),
                         InlineKeyboardButton(get_text('delete_emp', lang), callback_data=f"emp_delete_{emp_id}")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="emp_list")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Delete Employee Confirmation
            elif query.data.startswith("emp_delete_"):
                emp_id = query.data.replace("emp_delete_", "")
                employee = self.db.get_employee_by_id(emp_id)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if employee:
                    text = f"""{get_text('confirm_delete', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('delete_employee_title', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('confirm_delete_question', lang)}

👤 {employee['name']}
🆔 {employee['employee_id']}
🏢 {get_dept_display(employee['department'], lang)}

{get_text('action_irreversible', lang)}"""
                    
                    keyboard = [
                        [
                            InlineKeyboardButton(get_text('yes_delete', lang), callback_data=f"emp_confirm_delete_{emp_id}"),
                            InlineKeyboardButton(get_text('no_cancel', lang), callback_data=f"emp_view_{emp_id}")
                        ]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Confirm Delete Employee
            elif query.data.startswith("emp_confirm_delete_"):
                emp_id = query.data.replace("emp_confirm_delete_", "")
                employee = self.db.get_employee_by_id(emp_id)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if employee and self.db.delete_employee(emp_id):
                    dept_name = employee['department']
                    await query.answer(get_text('delete_success', lang), show_alert=True)
                    
                    # Go back to department employee list
                    employees = self.db.get_employees_by_department(dept_name)
                    dept_emoji = get_dept_emoji(dept_name)
                    dept_display = get_dept_display(dept_name, lang)
                    
                    text = f"""{dept_emoji} {dept_display}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
👥 {get_text('employee_list', lang)}: {len(employees)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

"""
                    keyboard = []
                    
                    if employees:
                        for emp in employees:
                            e_id = emp[0]
                            name = emp[2]
                            work_role = emp[3] if len(emp) > 3 and emp[3] else ""
                            role_text = f" - {work_role}" if work_role else ""
                            text += f"  👤 {name}{role_text}\n"
                            btn_text = f"👤 {name}{role_text}" if work_role else f"👤 {name}"
                            keyboard.append([InlineKeyboardButton(btn_text, callback_data=f"emp_view_{e_id}")])
                    else:
                        text += get_text('no_employees', lang) + "\n"
                    
                    text += f"\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n{get_text('select_employee_manage', lang)}"
                    
                    keyboard.append([InlineKeyboardButton(f"➕ {get_text('add_new_employee', lang)}", callback_data="emp_add")])
                    keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_list")])
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('delete_error', lang), show_alert=True)
            
            # ========== WORK ROLES MANAGEMENT ==========
            # Work Roles Menu
            elif query.data == "work_roles_menu":
                from database import get_all_work_roles
                
                lang = get_user_language(telegram_user_id, self.db)
                work_roles = get_all_work_roles(self.db)
                
                text = f"""{get_text('work_roles_management', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('work_roles_list', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

"""
                keyboard = []
                
                if work_roles:
                    row = []
                    for role_id, role_name, description, created_at in work_roles:
                        desc_short = (description[:30] + "...") if description and len(description) > 30 else (description or get_text('no_desc', lang))
                        text += f"💼 {role_name}: {desc_short}\n"
                        emoji = get_role_emoji(role_name)
                        row.append(InlineKeyboardButton(f"{emoji} {role_name}", callback_data=f"role_view_{role_id}"))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                else:
                    text += f"{get_text('no_work_roles', lang)}\n"
                
                text += f"\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n{get_text('select_role_manage', lang)}"
                
                keyboard.append([InlineKeyboardButton(get_text('add_work_role', lang), callback_data="role_add")])
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="employees_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # View Work Role Details
            elif query.data.startswith("role_view_"):
                from database import get_work_role_by_id
                
                role_id = int(query.data.replace("role_view_", ""))
                role = get_work_role_by_id(self.db, role_id)
                
                lang = get_user_language(telegram_user_id, self.db)
                if not role:
                    await query.answer(get_text('role_not_found', lang), show_alert=True)
                    return
                
                text = f"""💼 {get_text('role_details', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 {get_text('information', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🆔 ID: {role['id']}
💼 {get_text('name', lang)}: {role['role_name']}
📝 {get_text('description', lang)}: {role['description'] or get_text('no_desc', lang)}
📅 {get_text('created_at', lang)}: {role['created_at'] or 'N/A'}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚙️ {get_text('options', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━"""
                
                keyboard = [
                    [InlineKeyboardButton(f"✏️ {get_text('name', lang)}", callback_data=f"role_edit_name_{role_id}"),
                     InlineKeyboardButton(f"📝 {get_text('description', lang)}", callback_data=f"role_edit_desc_{role_id}")],
                    [InlineKeyboardButton(get_text('delete', lang), callback_data=f"role_delete_{role_id}"),
                     InlineKeyboardButton(get_text('back', lang), callback_data="work_roles_menu")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Add Work Role
            elif query.data == "role_add":
                context.user_data['role_add_step'] = 'name'
                
                lang = get_user_language(telegram_user_id, self.db)
                text = f"""➕ {get_text('add_work_role', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📍 {get_text('step', lang)} 1/2: {get_text('name', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('enter_role_name', lang)}"""
                
                keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data="work_roles_menu")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Edit Work Role Name
            elif query.data.startswith("role_edit_name_"):
                from database import get_work_role_by_id
                
                role_id = int(query.data.replace("role_edit_name_", ""))
                role = get_work_role_by_id(self.db, role_id)
                
                context.user_data['role_edit_id'] = role_id
                context.user_data['role_edit_step'] = 'name'
                
                lang = get_user_language(telegram_user_id, self.db)
                text = f"""✏️ {get_text('edit_name', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
💼 {get_text('current_name', lang)}: {role['role_name'] if role else 'N/A'}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('enter_new_role_name', lang)}"""
                
                keyboard = [[InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data=f"role_view_{role_id}")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Edit Work Role Description
            elif query.data.startswith("role_edit_desc_"):
                from database import get_work_role_by_id
                
                role_id = int(query.data.replace("role_edit_desc_", ""))
                role = get_work_role_by_id(self.db, role_id)
                
                context.user_data['role_edit_id'] = role_id
                context.user_data['role_edit_step'] = 'description'
                
                lang = get_user_language(telegram_user_id, self.db)
                text = f"""📝 {get_text('edit_description', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
💼 {get_text('work_role', lang)}: {role['role_name'] if role else 'N/A'}
📝 {get_text('current_description', lang)}: {role['description'] or get_text('no_desc', lang) if role else 'N/A'}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('enter_new_role_description', lang)}"""
                
                keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data=f"role_view_{role_id}")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Delete Work Role Confirmation
            elif query.data.startswith("role_delete_"):
                from database import get_work_role_by_id
                
                role_id = int(query.data.replace("role_delete_", ""))
                role = get_work_role_by_id(self.db, role_id)
                
                lang = get_user_language(telegram_user_id, self.db)
                if role:
                    text = f"""⚠️ {get_text('delete_confirmation', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
🗑️ {get_text('delete_work_role', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('confirm_delete_message', lang)}

💼 {role['role_name']}

⚠️ {get_text('action_cannot_be_undone', lang)}"""
                    
                    keyboard = [
                        [
                            InlineKeyboardButton(get_text('yes_delete', lang), callback_data=f"role_confirm_delete_{role_id}"),
                            InlineKeyboardButton(get_text('no_cancel', lang), callback_data=f"role_view_{role_id}")
                        ]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Confirm Delete Work Role
            elif query.data.startswith("role_confirm_delete_"):
                from database import get_work_role_by_id, delete_work_role, get_all_work_roles
                
                role_id = int(query.data.replace("role_confirm_delete_", ""))
                role = get_work_role_by_id(self.db, role_id)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if role and delete_work_role(self.db, role_id):
                    await query.answer(f"{get_text('work_role', lang)} '{role['role_name']}' {get_text('deleted_successfully', lang)}", show_alert=True)
                    
                    # Go back to work roles list
                    work_roles = get_all_work_roles(self.db)
                    
                    text = f"""💼 {get_text('work_roles_management', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('work_roles_list', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

"""
                    keyboard = []
                    
                    if work_roles:
                        for r_id, role_name, description, created_at in work_roles:
                            desc_short = (description[:30] + "...") if description and len(description) > 30 else (description or get_text('no_desc', lang))
                            text += f"💼 {role_name}: {desc_short}\n"
                            keyboard.append([InlineKeyboardButton(f"💼 {role_name}", callback_data=f"role_view_{r_id}")])
                    else:
                        text += get_text('no_work_roles', lang) + "\n"
                    
                    text += f"\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n{get_text('select_role_manage', lang)}"
                    
                    keyboard.append([InlineKeyboardButton(get_text('add_work_role', lang), callback_data="role_add")])
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="employees_menu")])
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('delete_error', lang), show_alert=True)
            
            # Add Employee - Select Department
            elif query.data.startswith("emp_add_dept_"):
                dept_name = query.data.replace("emp_add_dept_", "")
                context.user_data['emp_add_dept'] = dept_name
                context.user_data['emp_add_step'] = 'name'
                
                lang = get_user_language(telegram_user_id, self.db)
                dept_display = get_dept_display(dept_name, lang)
                
                text = f"""{get_text('add_employee_title', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('step_employee_name', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

📱 Telegram ID: {context.user_data.get('emp_add_telegram_id', 'N/A')}
🏢 {get_text('department', lang)}: {dept_display}

{get_text('enter_employee_name', lang)}"""
                
                keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data="emp_list")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Attendance Management
            elif query.data == "admin_attendance":
                from datetime import datetime, timedelta
                today = datetime.now()
                
                lang = get_user_language(telegram_user_id, self.db)
                
                text = f"""{get_text('attendance_management', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('attendance_overview', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('select_date_attendance', lang)}"""
                
                # Create date buttons for last 7 days
                day_names_key = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']
                keyboard = []
                for i in range(7):
                    date = today - timedelta(days=i)
                    date_str = date.strftime("%Y-%m-%d")
                    day_name = get_text(day_names_key[date.weekday()], lang)
                    display = f"📅 {date_str} ({day_name})" if i == 0 else f"{date_str} ({day_name})"
                    keyboard.append([InlineKeyboardButton(display, callback_data=f"att_date_{date_str}")])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="employees_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # View attendance for specific date
            elif query.data.startswith("att_date_"):
                from datetime import datetime
                selected_date = query.data.replace("att_date_", "")
                current_time = datetime.now().strftime("%H:%M:%S")
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # First, ensure all employees have records for this date
                self.db.create_daily_attendance_for_all(selected_date)
                
                # Get attendance records for the date
                records = self.db.get_attendance_by_date(selected_date)
                
                status_icons = {0: "❌", 1: "✅", 2: "⚠️", 3: "🏖️"}
                status_names = {0: get_text('absent', lang), 1: get_text('present', lang), 2: get_text('late', lang), 3: get_text('vacation', lang)}
                
                if records:
                    # Group by department
                    dept_records = {}
                    for record in records:
                        dept = record['department']
                        if dept not in dept_records:
                            dept_records[dept] = []
                        dept_records[dept].append(record)
                    
                    # Count statistics
                    total = len(records)
                    present = sum(1 for r in records if r['status'] == 1)
                    late = sum(1 for r in records if r['status'] == 2)
                    absent = sum(1 for r in records if r['status'] == 0)
                    vacation = sum(1 for r in records if r['status'] == 3)
                    
                    # Calculate attendance rate
                    attendance_rate = ((present + late) / total * 100) if total > 0 else 0
                    
                    text = f"""<b>📊 {get_text('attendance_report', lang)}</b>
━━━━━━━━━━━━━━━━━━━━━━
📅 <b>{get_text('date_label', lang)}:</b> {selected_date}
🔄 <b>{get_text('updated_at', lang)}:</b> {current_time}

<b>{get_text('statistics', lang)}</b>
<code>┌──────────────────────┐
│ ✅ {get_text('present', lang)[:7].ljust(7)} │  {present:>3}    │
│ ⚠️ {get_text('late', lang)[:7].ljust(7)} │  {late:>3}    │
│ ❌ {get_text('absent', lang)[:7].ljust(7)} │  {absent:>3}    │
│ 🏖 {get_text('vacation', lang)[:7].ljust(7)} │  {vacation:>3}    │
├──────────────────────┤
│ 📊 {get_text('total', lang)[:7].ljust(7)} │  {total:>3}    │
│ 📈 {get_text('attendance_rate', lang)[:7].ljust(7)} │ {attendance_rate:>5.1f}%  │
└──────────────────────┘</code>

"""
                    
                    # Build department blocks, then pair them side by side
                    dept_list = list(dept_records.items())
                    
                    for di in range(0, len(dept_list), 2):
                        dept1_name, dept1_recs = dept_list[di]
                        dept1_emoji = get_dept_emoji(dept1_name)
                        dept1_display = get_dept_display(dept1_name, lang)
                        dept1_present = sum(1 for r in dept1_recs if r['status'] in [1, 2])
                        dept1_total = len(dept1_recs)
                        
                        has_dept2 = di + 1 < len(dept_list)
                        if has_dept2:
                            dept2_name, dept2_recs = dept_list[di + 1]
                            dept2_emoji = get_dept_emoji(dept2_name)
                            dept2_display = get_dept_display(dept2_name, lang)
                            dept2_present = sum(1 for r in dept2_recs if r['status'] in [1, 2])
                            dept2_total = len(dept2_recs)
                        
                        # Department headers side by side
                        hdr1 = f"{dept1_emoji} {dept1_display} ({dept1_present}/{dept1_total})"
                        if has_dept2:
                            hdr2 = f"{dept2_emoji} {dept2_display} ({dept2_present}/{dept2_total})"
                            text += f"<b>{hdr1}</b>    <b>{hdr2}</b>\n"
                        else:
                            text += f"<b>{hdr1}</b>\n"
                        
                        # Build rows for each department
                        def build_rows(emp_recs):
                            rows = []
                            for rec in emp_recs:
                                si = status_icons.get(rec['status'], "?")
                                # Use text chars for alignment: O=present X=absent !=late V=vacation
                                st_char = {0: "X", 1: "O", 2: "!", 3: "V"}.get(rec['status'], "?")
                                
                                # Handle time objects properly
                                t_in = rec['check_in_time']
                                if t_in:
                                    t_in = t_in.strftime('%H:%M') if hasattr(t_in, 'strftime') else str(t_in)[:5]
                                else:
                                    t_in = "--:--"
                                
                                t_out = rec.get('check_out_time', '')
                                if t_out:
                                    t_out = t_out.strftime('%H:%M') if hasattr(t_out, 'strftime') else str(t_out)[:5]
                                else:
                                    t_out = "--:--"
                                
                                nm = rec['name'][:6].ljust(6)
                                rows.append(f"{nm} {t_in} {t_out} {st_char}")
                            return rows
                        
                        rows1 = build_rows(dept1_recs)
                        rows2 = build_rows(dept2_recs) if has_dept2 else []
                        
                        max_rows = max(len(rows1), len(rows2) if has_dept2 else 0)
                        # Column width: "Name__ HH:MM HH:MM X" = 20 chars
                        col_w = 20
                        hdr_row = f"{'Name':<6} {'In':>5} {'Out':>5} {'S'}"
                        
                        if has_dept2:
                            text += f"<code>{hdr_row:<{col_w}}│{hdr_row}\n"
                            text += f"{'─'*col_w}┼{'─'*col_w}\n"
                            for ri in range(max_rows):
                                c1 = rows1[ri] if ri < len(rows1) else " " * col_w
                                c2 = rows2[ri] if ri < len(rows2) else ""
                                text += f"{c1:<{col_w}}│{c2}\n"
                            text += "</code>\n"
                        else:
                            text += f"<code>{hdr_row}\n"
                            text += f"{'─'*col_w}\n"
                            for ri in range(max_rows):
                                text += f"{rows1[ri]}\n"
                            text += "</code>\n"
                else:
                    text = f"""<b>📊 {get_text('attendance_report', lang)}</b>
━━━━━━━━━━━━━━━━━━━━━━
📅 <b>{get_text('date_label', lang)}:</b> {selected_date}
🔄 <b>{get_text('updated_at', lang)}:</b> {current_time}

⚠️ {get_text('no_attendance_records', lang)}
"""
                
                keyboard = [
                    [InlineKeyboardButton(get_text('refresh', lang), callback_data=f"att_date_{selected_date}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="admin_attendance")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="HTML")
            
            # Employee Attendance (deprecated - redirect to admin_attendance)
            elif query.data == "emp_attendance":
                # Redirect to admin attendance
                from datetime import datetime, timedelta
                today = datetime.now()
                
                lang = get_user_language(telegram_user_id, self.db)
                
                text = f"""{get_text('attendance_management', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('attendance_overview', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('select_date_attendance', lang)}:"""
                
                day_names = {
                    'en': ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
                    'sr': ["Pon", "Uto", "Sre", "Čet", "Pet", "Sub", "Ned"]
                }
                keyboard = []
                for i in range(7):
                    date = today - timedelta(days=i)
                    date_str = date.strftime("%Y-%m-%d")
                    day_name = day_names.get(lang, day_names['en'])[date.weekday()]
                    display = f"📅 {date_str} ({day_name})" if i == 0 else f"{date_str} ({day_name})"
                    keyboard.append([InlineKeyboardButton(display, callback_data=f"att_date_{date_str}")])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="employees_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Duty Check Menu
            elif query.data == "duty_check_menu":
                from datetime import datetime
                today = datetime.now().strftime("%Y-%m-%d")
                current_time = datetime.now().strftime("%H:%M")
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get latest duty check for today
                latest_check = self.db.get_latest_duty_check(today)
                
                status_text = ""
                if latest_check:
                    responses = self.db.get_duty_responses(latest_check['id'])
                    on_duty = [r for r in responses if r['response'] == 1]
                    not_duty = [r for r in responses if r['response'] == 2]
                    no_response = [r for r in responses if r['response'] in [0, 3]]
                    
                    status_text = f"""

📊 {get_text('todays_check', lang)} ({latest_check['created_at'][:16]}):
✅ {get_text('on_duty', lang)}: {len(on_duty)}
❌ {get_text('not_on_duty', lang)}: {len(not_duty)}
⏳ {get_text('no_response', lang)}: {len(no_response)}"""
                    
                    if on_duty:
                        status_text += f"\n\n👤 {get_text('on_duty_today', lang)}:"
                        for r in on_duty:
                            status_text += f"\n  • {r['name']}"
                
                text = f"""📅 {get_text('daily_shift_check', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 {get_text('daily_shift_reception', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

📆 {get_text('date', lang)}: {today}
🕐 {get_text('time', lang)}: {current_time}{status_text}

{get_text('duty_check_instruction', lang)}
⏱️ {get_text('response_deadline', lang)}: 5 {get_text('minutes', lang)}"""
                
                keyboard = [
                    [InlineKeyboardButton(f"📤 {get_text('send_query_employees', lang)}", callback_data="duty_send_check")],
                    [InlineKeyboardButton(f"📊 {get_text('view_responses', lang)}", callback_data="duty_view_responses")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="employees_menu")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Send Duty Check to Reception employees
            elif query.data == "duty_send_check":
                from datetime import datetime
                import asyncio
                admin_id = query.from_user.id
                lang = get_user_language(admin_id, self.db)
                today = datetime.now().strftime("%Y-%m-%d")
                current_time = datetime.now().strftime("%H:%M")
                
                # Create duty check record
                duty_check_id = self.db.create_duty_check(admin_id, expires_minutes=5)
                
                if not duty_check_id:
                    await query.answer(get_text('error_creating_check', lang), show_alert=True)
                    return
                
                # Get reception employees
                reception_employees = self.db.get_reception_employees()
                
                if not reception_employees:
                    await query.answer(get_text('no_reception_employees', lang), show_alert=True)
                    return
                
                # Add all employees to response list first
                for emp_telegram_id, emp_name in reception_employees:
                    self.db.add_duty_response(duty_check_id, emp_telegram_id, emp_name)
                
                # Show immediate response to admin
                text = f"""{get_text('daily_shift_check', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 {get_text('check_sent', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

📆 {get_text('date', lang)}: {today}
🕐 {get_text('time', lang)}: {current_time}

📤 {get_text('sending_to_reception', lang).replace('{count}', str(len(reception_employees)))}
⏱️ {get_text('please_wait', lang)}"""
                
                keyboard = [
                    [InlineKeyboardButton(f"📊 {get_text('view_responses', lang)}", callback_data="duty_view_responses")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="employees_menu")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Send notifications in background task
                asyncio.create_task(self.send_duty_check_notifications(duty_check_id, reception_employees, today, current_time, admin_id))
            
            # View Duty Check Responses
            elif query.data == "duty_view_responses":
                from datetime import datetime
                admin_id = query.from_user.id
                lang = get_user_language(admin_id, self.db)
                today = datetime.now().strftime("%Y-%m-%d")
                
                latest_check = self.db.get_latest_duty_check(today)
                
                if not latest_check:
                    text = f"""{get_text('daily_shift_check', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 {get_text('no_data', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('no_check_sent_today', lang)}"""
                else:
                    responses = self.db.get_duty_responses(latest_check['id'])
                    
                    on_duty = [r for r in responses if r['response'] == 1]
                    not_duty = [r for r in responses if r['response'] == 2]
                    no_response = [r for r in responses if r['response'] in [0, 3]]
                    
                    text = f"""{get_text('daily_shift_check', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 {get_text('check_results', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

📆 {get_text('date', lang)}: {today}
🕐 {get_text('date_time_of_query', lang)}: {latest_check['created_at'][:16]}
📋 {get_text('status', lang)}: {latest_check['status'].upper()}

"""
                    text += f"✅ {get_text('on_duty', lang).upper()} ({len(on_duty)}):\n"
                    if on_duty:
                        for r in on_duty:
                            text += f"  👤 {r['name']} ({r['responded_at'][:16] if r['responded_at'] else ''})\n"
                    else:
                        text += f"  ({get_text('none', lang)})\n"
                    
                    text += f"\n❌ {get_text('not_on_duty', lang).upper()} ({len(not_duty)}):\n"
                    if not_duty:
                        for r in not_duty:
                            text += f"  👤 {r['name']}\n"
                    else:
                        text += f"  ({get_text('none', lang)})\n"
                    
                    text += f"\n⏳ {get_text('no_response', lang).upper()} ({len(no_response)}):\n"
                    if no_response:
                        for r in no_response:
                            text += f"  👤 {r['name']}\n"
                    else:
                        text += f"  ({get_text('none', lang)})\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"📤 {get_text('send_new_query', lang)}", callback_data="duty_send_check")],
                    [InlineKeyboardButton(f"🔄 {get_text('refresh', lang)}", callback_data="duty_view_responses")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="duty_check_menu")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Employee responds YES to duty check
            elif query.data.startswith("duty_yes_"):
                duty_check_id = int(query.data.replace("duty_yes_", ""))
                telegram_user_id = query.from_user.id
                
                # Check if already expired
                duty_check = self.db.get_duty_check_by_id(duty_check_id)
                if duty_check and duty_check['status'] == 'expired':
                    await query.answer("⏰ Vreme za odgovor je isteklo.", show_alert=True)
                    return
                
                # Update response
                success = self.db.update_duty_response(duty_check_id, telegram_user_id, 1)
                
                if success:
                    # Notify admin
                    if duty_check:
                        try:
                            emp_info = self.db.get_employee_info(telegram_user_id)
                            emp_name = emp_info['name'] if emp_info else "Zaposleni"
                            admin_lang = get_user_language(duty_check['admin_id'], self.db)
                            
                            await self.application.bot.send_message(
                                chat_id=duty_check['admin_id'],
                                text=get_text('employee_confirmed_on_duty', admin_lang).format(emp_name=emp_name)
                            )
                        except:
                            pass
                    
                    emp_lang = get_user_language(telegram_user_id, self.db)
                    await query.edit_message_text(f"""✅ {get_text('response_received', emp_lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('your_response_recorded', emp_lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('confirmed_on_duty', emp_lang)}
{get_text('thank_you_for_response', emp_lang)}""")
                else:
                    emp_lang = get_user_language(telegram_user_id, self.db)
                    await query.answer(get_text('error_sending_response', emp_lang), show_alert=True)
            
            # Employee responds NO to duty check
            elif query.data.startswith("duty_no_"):
                duty_check_id = int(query.data.replace("duty_no_", ""))
                telegram_user_id = query.from_user.id
                emp_lang = get_user_language(telegram_user_id, self.db)
                
                # Check if already expired
                duty_check = self.db.get_duty_check_by_id(duty_check_id)
                if duty_check and duty_check['status'] == 'expired':
                    await query.answer(f"⏰ {get_text('time_expired', emp_lang)}", show_alert=True)
                    return
                
                # Update response
                success = self.db.update_duty_response(duty_check_id, telegram_user_id, 2)
                
                if success:
                    # Notify admin
                    if duty_check:
                        try:
                            emp_info = self.db.get_employee_info(telegram_user_id)
                            emp_name = emp_info['name'] if emp_info else "Zaposleni"
                            admin_lang = get_user_language(duty_check['admin_id'], self.db)
                            
                            await self.application.bot.send_message(
                                chat_id=duty_check['admin_id'],
                                text=f"❌ {get_text('employee_confirmed_not_on_duty', admin_lang).format(emp_name=emp_name)}"
                            )
                        except:
                            pass
                    
                    await query.edit_message_text(f"""❌ {get_text('response_received', emp_lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('your_response_recorded', emp_lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('confirmed_not_on_duty', emp_lang)}
{get_text('thank_you_for_response', emp_lang)}""")
                else:
                    await query.answer(get_text('error_sending_response', emp_lang), show_alert=True)
            
            # Employee Shifts Management (deprecated)
            elif query.data == "emp_shifts":
                # Redirect to duty check menu
                await query.answer("Ova funkcija je preseljena.", show_alert=True)
            
            # Employee Schedule Management Menu
            elif query.data == "emp_schedule_menu":
                from datetime import datetime
                today = datetime.now().strftime("%Y-%m-%d")
                current_time = datetime.now().strftime("%H:%M")
                
                # Get user's attendance status for today
                telegram_user_id = query.from_user.id
                attendance = self.db.get_attendance_by_user_and_date(telegram_user_id, today)
                
                status_text = ""
                lang = get_user_language(telegram_user_id, self.db)
                
                already_checked_in = False
                if attendance and attendance['status'] != 0:
                    already_checked_in = True
                    status_map = {
                        0: get_text('status_absent', lang), 
                        1: get_text('status_present', lang), 
                        2: get_text('status_late', lang), 
                        3: get_text('status_vacation', lang)
                    }
                    status_text = f"\n\n{get_text('today_status', lang)}: {status_map.get(attendance['status'], get_text('status_absent', lang))}"
                    if attendance['check_in_time']:
                        status_text += f"\n{get_text('arrival_time', lang)}: {attendance['check_in_time']}"
                else:
                    status_text = f"\n\n{get_text('today_status', lang)}: {get_text('status_absent', lang)}"
                
                text = f"""{get_text('schedule_management', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('schedule_attendance', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

📆 {get_text('date', lang)}: {today}
🕐 {get_text('time', lang)}: {current_time}{status_text}

{get_text('select_option_schedule', lang)}"""
                
                # Build keyboard based on check-in status
                keyboard = []
                if already_checked_in:
                    # Already checked in - show disabled button
                    keyboard.append([InlineKeyboardButton(get_text('already_checked_in_btn', lang), callback_data="schedule_already_checkedin")])
                else:
                    # Not checked in yet - show active check-in button
                    keyboard.append([InlineKeyboardButton(get_text('check_in', lang), callback_data="schedule_checkin")])
                
                # Work Report button hidden (feature in development)
                # keyboard.append([InlineKeyboardButton(get_text('work_report', lang), callback_data="schedule_work_report")])
                
                # Show checkout button only if already checked in
                if already_checked_in:
                    if attendance and attendance.get('check_out_time'):
                        keyboard.append([InlineKeyboardButton(get_text('already_ended_work', lang), callback_data="schedule_already_checkout")])
                    else:
                        keyboard.append([InlineKeyboardButton(get_text('end_work', lang), callback_data="schedule_checkout")])
                
                keyboard.extend([
                    [InlineKeyboardButton(get_text('my_records', lang), callback_data="schedule_my_history")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="back_to_employee_menu")]
                ])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Already checked out - show message
            elif query.data == "schedule_already_checkout":
                lang = get_user_language(query.from_user.id, self.db)
                await query.answer(get_text('already_ended_work_msg', lang), show_alert=True)
            
            # Already checked in - show message
            elif query.data == "schedule_already_checkedin":
                lang = get_user_language(query.from_user.id, self.db)
                await query.answer(get_text('already_checked_in_msg', lang), show_alert=True)
            
            # Back to employee menu
            elif query.data == "back_to_employee_menu":
                telegram_user_id = query.from_user.id
                employee_info = self.db.get_employee_info(telegram_user_id)
                
                if employee_info:
                    employee_id = employee_info['employee_id']
                    name = employee_info['name']
                    department = employee_info['department']
                    lang = get_user_language(telegram_user_id, self.db)
                    dept_display = get_dept_display(department, lang)
                    
                    # Get unread task count
                    tasks = self.db.get_employee_tasks(telegram_user_id)
                    unread_count = sum(1 for t in tasks if t[7] == 0)  # is_check column
                    notification_text = get_text('new_task_notification_count', lang).format(unread_count) if unread_count > 0 else get_text('new_task_notification', lang)
                    
                    # Get reportable tasks count
                    reportable_tasks = self.db.get_reportable_tasks(telegram_user_id, department)
                    report_count = len(reportable_tasks)
                    report_text = get_text('report_task_count', lang).format(report_count) if report_count > 0 else get_text('report_task', lang)
                    
                    welcome_text = f"""{get_text('welcome_back', lang).format(name)}

{get_text('your_info', lang)}
{get_text('employee_id_label', lang)}: {employee_id}
• {get_text('department', lang)}: {dept_display}

{get_text('select_option', lang)}"""
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('jobs', lang), callback_data="emp_work_menu"),
                         InlineKeyboardButton(report_text, callback_data="emp_report_task")],
                        [InlineKeyboardButton(notification_text, callback_data="emp_notifications")],
                        [InlineKeyboardButton(get_text('schedule', lang), callback_data="emp_schedule_menu"),
                         InlineKeyboardButton(get_text('complaint', lang), callback_data="emp_complaint")],
                        [InlineKeyboardButton(get_text('profile', lang), callback_data="emp_profile"),
                         InlineKeyboardButton(get_text('settings', lang), callback_data="emp_settings")]
                    ]
                    # Add Service Contacts button for Reception department
                    if department == 'Reception':
                        keyboard.insert(3, [InlineKeyboardButton(f"📞 {get_text('service_contacts', lang)}", callback_data="admin_contacts")])
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(welcome_text, reply_markup=reply_markup)
            
            # Schedule Check-in
            elif query.data == "schedule_checkin":
                from datetime import datetime
                telegram_user_id = query.from_user.id
                lang = get_user_language(telegram_user_id, self.db)
                today = datetime.now().strftime("%Y-%m-%d")
                current_time = datetime.now().strftime("%H:%M")
                current_hour = datetime.now().hour
                current_minute = datetime.now().minute
                
                # Check if already checked in
                attendance = self.db.get_attendance_by_user_and_date(telegram_user_id, today)
                
                if attendance and attendance['status'] != 0:
                    status_map = {
                        1: f"✅ {get_text('on_time', lang)}", 
                        2: f"⚠️ {get_text('late', lang)}", 
                        3: f"🏖️ {get_text('on_leave', lang)}"
                    }
                    await query.answer(f"{get_text('already_checked_in', lang)}: {status_map.get(attendance['status'], get_text('processed', lang))}", show_alert=True)
                    return
                
                # Determine status based on time (8:30 AM = 08:30)
                if current_hour < 8 or (current_hour == 8 and current_minute <= 30):
                    status = 1  # Present (on time)
                    status_text = f"✅ {get_text('on_time', lang)}"
                else:
                    status = 2  # Late
                    status_text = f"⚠️ {get_text('late', lang)}"
                
                # Update attendance
                success = self.db.update_attendance_status(telegram_user_id, today, status, current_time)
                
                if success:
                    text = f"""{get_text('checkin_success', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('attendance_record', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

📆 {get_text('date', lang)}: {today}
🕐 {get_text('checkin_time', lang)}: {current_time}
📊 {get_text('status', lang)}: {status_text}

{get_text('record_saved', lang)}"""
                    
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_schedule_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('processing_error', lang), show_alert=True)
            
            # Schedule Work Report
            elif query.data == "schedule_work_report":
                lang = get_user_language(telegram_user_id, self.db)
                
                text = f"""📝 {get_text('work_report', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('feature_title', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('feature_available_soon', lang)}

{get_text('planned_features', lang)}
{get_text('daily_report_entry', lang)}
{get_text('task_evidence', lang)}
{get_text('work_notes', lang)}"""
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_schedule_menu")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Schedule Checkout
            elif query.data == "schedule_checkout":
                from datetime import datetime
                telegram_user_id = query.from_user.id
                today = datetime.now().strftime("%Y-%m-%d")
                current_time = datetime.now().strftime("%H:%M")
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Check attendance status
                attendance = self.db.get_attendance_by_user_and_date(telegram_user_id, today)
                
                if not attendance or attendance['status'] == 0:
                    await query.answer(get_text('start_work_first', lang), show_alert=True)
                    return
                
                # Check if already checked out
                if attendance.get('check_out_time'):
                    await query.answer(get_text('already_checked_out', lang), show_alert=True)
                    return
                
                # Update checkout time in database
                self.db.update_checkout_time(telegram_user_id, today, current_time)
                
                # Log action using audit system
                employee = self.db.check_employee_exists(telegram_user_id)
                if employee:
                    employee_id, name, department, work_role, gmail, whatsapp = employee
                    # Use event_logger for check-out with before/after state
                    try:
                        event_logger = get_event_logger()
                        event_logger.log_shift_check_out(
                            user_id=telegram_user_id,
                            user_name=name,
                            department=department,
                            check_out_time=current_time,
                            employee_id=employee_id,
                            check_in_time=attendance.get('check_in_time')
                        )
                    except Exception as log_error:
                        print(f"Event logging error: {log_error}")
                
                # Get employee info for notification
                emp_info = self.db.get_employee_info(telegram_user_id)
                if emp_info:
                    emp_id = emp_info['employee_id']
                    name = emp_info['name']
                    dept = emp_info['department']
                    dept_display = get_dept_display(dept, lang)
                    
                    # Calculate work hours
                    try:
                        check_in = datetime.strptime(attendance['check_in_time'], "%H:%M")
                        check_out = datetime.strptime(current_time, "%H:%M")
                        work_duration = check_out - check_in
                        hours = work_duration.seconds // 3600
                        minutes = (work_duration.seconds % 3600) // 60
                        work_hours_str = f"{hours}h {minutes}m"
                    except:
                        work_hours_str = "—"
                    
                    # Notify admin
                    try:
                        admins = self.db.get_all_admins()
                        for admin in admins:
                            try:
                                notification_text = f"""{get_text('work_ended', lang)}

👤 {get_text('name', lang)}: {name}
🏢 {get_text('department', lang)}: {dept_display}
📆 {get_text('date_label', lang)}: {today}
🟢 {get_text('check_in_time', lang)}: {attendance['check_in_time']}
🔴 {get_text('check_out_time', lang)}: {current_time}
⏱️ {get_text('total_work_time', lang)}: {work_hours_str}"""
                                
                                await self.application.bot.send_message(
                                    chat_id=admin[0],
                                    text=notification_text
                                )
                            except:
                                pass
                    except:
                        pass
                
                text = f"""{get_text('work_ended', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 {get_text('work_ended', lang).upper()}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

📆 {get_text('date_label', lang)}: {today}
🟢 {get_text('check_in_time', lang)}: {attendance['check_in_time']}
🔴 {get_text('check_out_time', lang)}: {current_time}
⏱️ {get_text('total_work_time', lang)}: {work_hours_str if emp_info else '—'}
{get_text('work_completed', lang)}
"""
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_schedule_menu")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # My Attendance History
            elif query.data == "schedule_my_history":
                from datetime import datetime
                telegram_user_id = query.from_user.id
                
                # Get last 7 days history
                history = self.db.get_user_attendance_history(telegram_user_id, 7)
                
                text = """📊 Moja evidencija

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 POSLEDNJIH 7 DANA
━━━━━━━━━━━━━━━━━━━━━━━━━━━

"""
                status_map = {0: "❌", 1: "✅", 2: "⚠️", 3: "🏖️"}
                status_names = {0: "Odsutan", 1: "Prisutan", 2: "Kasni", 3: "Odmor"}
                
                if history:
                    text += "📆 Datum      | 🟢Dolaz | 🔴Odlaz | 📊\n"
                    text += "─────────────────────────────────────\n"
                    for record in history:
                        in_time = record['check_in_time'] if record['check_in_time'] else "——"
                        out_time = record.get('check_out_time') if record.get('check_out_time') else "——"
                        status_icon = status_map.get(record['status'], "❓")
                        text += f"{record['work_date']} | {in_time:^5} | {out_time:^5} | {status_icon}\n"
                else:
                    text += "Nema podataka o prisutnosti."
                
                keyboard = [[InlineKeyboardButton("🔙 Nazad", callback_data="emp_schedule_menu")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            elif query.data.startswith("action_") and not query.data.startswith("action_history") and not query.data.startswith("action_date_") and not query.data.startswith("action_dept"):
                # Handle action selection (not action_history/action_date/action_dept)
                action_id = query.data.replace("action_", "")
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Create Task (action_id=1)
                if action_id == "1":
                    # Initialize task creation data
                    context.user_data['task_creation'] = {
                        'step': 'department',
                        'department_id': None,
                        'department_name': None,
                        'employee_id': None,
                        'employee_name': None,
                        'description': None,
                        'priority': 'Normal',
                        'due_date': None,
                        'requires_materials': False
                    }
                    
                    # Show department list
                    departments = self.db.get_departments(exclude_management=True)
                    
                    if not departments:
                        await query.edit_message_text(f"{get_text('create_task_title', lang)}\n\n{get_text('no_departments', lang)}")
                        return
                    
                    keyboard = []
                    row = []
                    for dept_id, dept_name, dept_content in departments:
                        emoji = get_dept_emoji(dept_name)
                        dept_display = get_dept_display(dept_name, lang)
                        row.append(InlineKeyboardButton(f"{emoji} {dept_display}", callback_data=f"task_dept_{dept_id}"))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(
                        f"{get_text('create_task_step', lang)} 1/6\n\n{get_text('select_dept_task', lang)}\n\n{get_text('select_dept_hint', lang)}",
                        reply_markup=reply_markup
                    )
                
                # Room Management (action_id=2)
                elif action_id == "2":
                    # Import room management functions
                    from database import get_room_count_by_floor
                    
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    # Get floor statistics
                    floor_stats = get_room_count_by_floor(self.db)
                    
                    # Get overall room summary
                    room_summary = self.db.get_customer_rooms_summary()
                    
                    # Get hotel settings
                    hotel_settings = self.db.get_hotel_settings()
                    total_configured = hotel_settings['total_rooms']
                    
                    text = f"""{get_text('room_management_title', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('overall_statistics', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

"""
                    if room_summary:
                        text += f"""{get_text('configured_capacity', lang)}: {total_configured} {get_text('rooms', lang)}
{get_text('currently_registered_rooms', lang)}: {room_summary['total']} {get_text('rooms', lang)}
   {get_text('active_label', lang)}: {room_summary['active']}
   └─ ⚫ {get_text('inactive', lang)}: {room_summary['inactive']}

📋 {get_text('occupancy_status_label', lang)}:
   {get_text('occupied_label', lang)}: {room_summary['checked_in']}
   {get_text('available_label', lang)}: {room_summary['available']}

🛠️ {get_text('equipment_status', lang)} ({get_text('active_rooms', lang)}):
   ├─ ❄️ {get_text('ac', lang)}: {room_summary['ac_working']}/{room_summary['active']}
   ├─ 📺 TV: {room_summary['tv_working']}/{room_summary['active']}
   ├─ 🚽 {get_text('toilet', lang)}: {room_summary['toilet_working']}/{room_summary['active']}
   └─ 🎮 {get_text('remote', lang)}: {room_summary['remote_working']}/{room_summary['active']}

"""
                    
                    text += f"""━━━━━━━━━━━━━━━━━━━━━━━━━━━
👇 **{get_text('select_floor_manage', lang)}**
━━━━━━━━━━━━━━━━━━━━━━━━━━━

"""
                    keyboard = []
                    
                    if floor_stats:
                        # Create floor buttons - 3 floors per row
                        floor_row = []
                        for floor, total, active, inactive in floor_stats:
                            # Status indicator
                            if inactive == 0 and active > 0:
                                status_emoji = "🟢"  # All good
                            elif inactive > 0 and active > 0:
                                status_emoji = "🟡"  # Some inactive
                            else:
                                status_emoji = "⚫"  # All inactive
                            
                            floor_row.append(InlineKeyboardButton(
                                f"{status_emoji} {floor}F", 
                                callback_data=f"room_floor_{floor}"
                            ))
                            
                            # 3 floors per row
                            if len(floor_row) == 3:
                                keyboard.append(floor_row)
                                floor_row = []
                        
                        if floor_row:
                            keyboard.append(floor_row)
                    else:
                        text += f"{get_text('no_rooms_found', lang)}\n"
                    
                    keyboard.append([InlineKeyboardButton(f"➕ {get_text('add_new_room', lang)}", callback_data="room_create_new")])
                    keyboard.append([InlineKeyboardButton("🔙 Back", callback_data="actions")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
                
            # Room Management: Floor rooms list (Admin) - WITH PAGINATION
            elif query.data.startswith("room_floor_"):
                from database import get_rooms_by_floor
                
                # Parse floor and page from callback data
                parts = query.data.replace("room_floor_", "").split("_page_")
                floor = parts[0]
                page = int(parts[1]) if len(parts) > 1 else 1
                
                lang = get_user_language(telegram_user_id, self.db)
                
                rooms = get_rooms_by_floor(self.db, floor)
                
                # Pagination settings - 5 rooms per row, 4 rows per page = 20 rooms per page
                items_per_row = 5
                rows_per_page = 4
                items_per_page = items_per_row * rows_per_page  # 20 items per page
                
                total_pages = (len(rooms) + items_per_page - 1) // items_per_page if rooms else 1
                page = max(1, min(page, total_pages))
                
                start_idx = (page - 1) * items_per_page
                end_idx = min(start_idx + items_per_page, len(rooms))
                page_rooms = rooms[start_idx:end_idx]
                
                # Count room statistics on this floor
                total_rooms = len(rooms)
                active_rooms = sum(1 for r in rooms if r[7] == 1)
                occupied_rooms = sum(1 for r in rooms if r[8] > 0)  # rooms with guests
                
                text = f"""🏢 **Floor {floor}** (Page {page}/{total_pages})

📊 Total: {total_rooms} | ✅ Active: {active_rooms} | ⚫ Inactive: {total_rooms - active_rooms}
🛏️ Occupied: {occupied_rooms} | 🆓 Available: {active_rooms - occupied_rooms}

🟢=OK  🔴=Issue  ⚫=Off  🛏️=Used
━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
                keyboard = []
                
                if page_rooms:
                    # Add rooms in rows of 5 buttons
                    for i in range(0, len(page_rooms), items_per_row):
                        row = []
                        for j in range(i, min(i + items_per_row, len(page_rooms))):
                            room_id, id_room, is_check, ac, tv, toilet, remote, is_active, capacity, guests = page_rooms[j]
                            
                            # Determine room status icon
                            if is_active == 0:
                                status_icon = "⚫"  # Inactive
                            elif guests > 0:
                                status_icon = "🛏️"  # Occupied
                            elif str(ac) == "1" and str(tv) == "1" and str(toilet) == "1" and str(remote) == "1":
                                status_icon = "🟢"  # All equipment working
                            else:
                                status_icon = "🔴"  # Equipment issues
                            
                            # Show only room number (last 2 digits)
                            room_num = id_room[-2:] if len(id_room) > 2 else id_room
                            row.append(InlineKeyboardButton(
                                f"{status_icon} {room_num}",
                                callback_data=f"room_manage_{room_id}"
                            ))
                        keyboard.append(row)
                else:
                    text += f"No rooms found on this floor.\n"
                
                # Navigation buttons for pagination
                nav_row = []
                if page > 1:
                    nav_row.append(InlineKeyboardButton("⬅️ Prev", callback_data=f"room_floor_{floor}_page_{page-1}"))
                nav_row.append(InlineKeyboardButton(f"📄 {page}/{total_pages}", callback_data="noop"))
                if page < total_pages:
                    nav_row.append(InlineKeyboardButton("Next ➡️", callback_data=f"room_floor_{floor}_page_{page+1}"))
                if total_pages > 1:
                    keyboard.append(nav_row)
                
                # Add operation buttons for this floor
                keyboard.append([InlineKeyboardButton("❄️ AC", callback_data=f"room_floor_ac_{floor}"),
                                InlineKeyboardButton("📺 TV", callback_data=f"room_floor_tv_{floor}"),
                                InlineKeyboardButton("🚽 Toilet", callback_data=f"room_floor_toilet_{floor}"),
                                InlineKeyboardButton("🎮 Remote", callback_data=f"room_floor_remote_{floor}")])
                keyboard.append([InlineKeyboardButton("➕ Add Room", callback_data="room_create_new"),
                                InlineKeyboardButton("🔙 Back", callback_data="action_2")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
            # Floor-level equipment operations
            elif query.data.startswith("room_floor_ac_") or query.data.startswith("room_floor_tv_") or \
                 query.data.startswith("room_floor_toilet_") or query.data.startswith("room_floor_remote_"):
                from database import get_rooms_by_floor, update_room_equipment
                
                # Parse operation and floor
                if query.data.startswith("room_floor_ac_"):
                    equipment = "AC"
                    floor = query.data.replace("room_floor_ac_", "")
                    equip_display = "❄️ AC"
                elif query.data.startswith("room_floor_tv_"):
                    equipment = "TV"
                    floor = query.data.replace("room_floor_tv_", "")
                    equip_display = "📺 TV"
                elif query.data.startswith("room_floor_toilet_"):
                    equipment = "Toilet"
                    floor = query.data.replace("room_floor_toilet_", "")
                    equip_display = "🚽 Toilet"
                else:  # remote
                    equipment = "Remote_Control"
                    floor = query.data.replace("room_floor_remote_", "")
                    equip_display = "🎮 Remote"
                
                lang = get_user_language(telegram_user_id, self.db)
                rooms = get_rooms_by_floor(self.db, floor)
                
                if not rooms:
                    await query.answer(f"No rooms found on floor {floor}", show_alert=True)
                    return
                
                # Pagination for room selection - 3 rooms per row, 5 rows per page = 15 rooms per page
                items_per_row = 3
                rows_per_page = 5
                items_per_page = items_per_row * rows_per_page
                
                text = f"""🏢 **Floor {floor}** - {equip_display} Status

━━━━━━━━━━━━━━━━━━━━━━━━━━━
Select rooms to toggle {equip_display}:

✅ = Working
❌ = Not Working

Tap a room to toggle its {equip_display} status
"""
                
                keyboard = []
                
                # Add room buttons with current equipment status
                for i in range(0, len(rooms), items_per_row):
                    row = []
                    for j in range(i, min(i + items_per_row, len(rooms))):
                        room_id, id_room, is_check, ac, tv, toilet, remote, is_active, capacity, guests = rooms[j]
                        
                        # Determine current equipment status
                        if equipment == "AC":
                            status = "✅" if str(ac) == "1" else "❌"
                        elif equipment == "TV":
                            status = "✅" if str(tv) == "1" else "❌"
                        elif equipment == "Toilet":
                            status = "✅" if str(toilet) == "1" else "❌"
                        else:  # Remote_Control
                            status = "✅" if str(remote) == "1" else "❌"
                        
                        row.append(InlineKeyboardButton(
                            f"{status} {id_room}",
                            callback_data=f"toggle_equip_{room_id}_{equipment}_{floor}"
                        ))
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton("🔙 Back to Floor", callback_data=f"room_floor_{floor}")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
            # Toggle equipment for a specific room from floor view
            elif query.data.startswith("toggle_equip_"):
                from database import update_room_equipment, get_room_by_id
                
                parts = query.data.replace("toggle_equip_", "").split("_")
                room_id = int(parts[0])
                equipment = parts[1]
                floor = parts[2]
                
                lang = get_user_language(telegram_user_id, self.db)
                
                room = get_room_by_id(self.db, room_id)
                if room:
                    current_value = str(room.get(equipment, "1"))
                    new_value = "0" if current_value == "1" else "1"
                    
                    if update_room_equipment(self.db, room_id, equipment, new_value):
                        status = "✅ Working" if new_value == "1" else "❌ Not Working"
                        await query.answer(f"Room {room['id_room']}: {status}", show_alert=False)
                        
                        # Refresh the equipment status page
                        if equipment == "AC":
                            callback = f"room_floor_ac_{floor}"
                        elif equipment == "TV":
                            callback = f"room_floor_tv_{floor}"
                        elif equipment == "Toilet":
                            callback = f"room_floor_toilet_{floor}"
                        else:  # Remote_Control
                            callback = f"room_floor_remote_{floor}"
                        
                        # Simulate the callback to refresh the page
                        query.data = callback
                        await self.button_handler(update, context)
                    else:
                        await query.answer("Error updating equipment status", show_alert=True)
                else:
                    await query.answer("Room not found", show_alert=True)
                return
                
            # Room Management: Room detail and management
            elif query.data.startswith("room_manage_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("room_manage_", ""))
                room = get_room_by_id(self.db, room_id)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not room:
                    await query.edit_message_text(f"❌ {get_text('room_not_found', lang)}")
                    return
                
                # Status text mapping
                active_status = f"✅ {get_text('active', lang)}" if room['is_active'] == 1 else f"❌ {get_text('inactive', lang)}"
                check_status = f"🔴 {get_text('occupied', lang)}" if str(room['is_check']) == "1" else f"� {get_text('available', lang)}"
                ac_status = "✅" if str(room['AC']) == "1" else "❌"
                tv_status = "✅" if str(room['TV']) == "1" else "❌"
                toilet_status = "✅" if str(room['Toilet']) == "1" else "❌"
                remote_status = "✅" if str(room['Remote_Control']) == "1" else "❌"
                
                floor = room['id_room'][:-2] if len(room['id_room']) > 2 else "1"
                
                room_info = f"""🚪 {get_text('room_management_single', lang)} {room['id_room']}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 {get_text('status', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

📍 {get_text('state', lang)}: {active_status}
🏠 {get_text('occupancy', lang)}: {check_status}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
🛠️ {get_text('equipment', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

❄️ {get_text('ac', lang)}: {ac_status}
📺 TV: {tv_status}
🚽 {get_text('toilet', lang)}: {toilet_status}
🎮 {get_text('remote', lang)}: {remote_status}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚙️ {get_text('options', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━"""
                
                toggle_text = f"❌ {get_text('deactivate_room', lang)}" if room['is_active'] == 1 else f"✅ {get_text('activate_room', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(toggle_text, callback_data=f"room_toggle_{room_id}")],
                    [InlineKeyboardButton(f"❄️ {get_text('ac', lang)}", callback_data=f"room_equip_{room_id}_AC"),
                     InlineKeyboardButton("📺 TV", callback_data=f"room_equip_{room_id}_TV")],
                    [InlineKeyboardButton(f"🚽 {get_text('toilet', lang)}", callback_data=f"room_equip_{room_id}_Toilet"),
                     InlineKeyboardButton(f"🎮 {get_text('remote', lang)}", callback_data=f"room_equip_{room_id}_Remote_Control")],
                    [InlineKeyboardButton(f"🗑️ {get_text('delete_room', lang)}", callback_data=f"room_delete_{room_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"room_floor_{floor}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(room_info, reply_markup=reply_markup)
            
            # Room Management: Toggle room active status
            elif query.data.startswith("room_toggle_"):
                from database import toggle_room_active, get_room_by_id
                
                room_id = int(query.data.replace("room_toggle_", ""))
                lang = get_user_language(query.from_user.id, self.db)
                
                if toggle_room_active(self.db, room_id):
                    room = get_room_by_id(self.db, room_id)
                    status_msg = get_text('room_activated', lang) if room and room['is_active'] == 1 else get_text('room_deactivated', lang)
                    await query.answer(status_msg, show_alert=True)
                    
                    # Refresh room management page directly
                    await self._show_room_manage(query, room_id)
                else:
                    await query.answer(get_text('room_status_toggle_error', lang), show_alert=True)
            
            # Room Management: Toggle equipment status
            elif query.data.startswith("room_equip_"):
                from database import update_room_equipment, get_room_by_id
                
                parts = query.data.replace("room_equip_", "").split("_", 1)
                room_id = int(parts[0])
                equipment = parts[1]
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_room_by_id(self.db, room_id)
                if room:
                    current_value = str(room.get(equipment, "1"))
                    new_value = "0" if current_value == "1" else "1"
                    
                    if update_room_equipment(self.db, room_id, equipment, new_value):
                        status = get_text('equipment_working', lang) if new_value == "1" else get_text('equipment_not_working', lang)
                        equip_names = {
                            "AC": get_text('climate', lang),
                            "TV": get_text('tv', lang),
                            "Toilet": get_text('toilet', lang),
                            "Remote_Control": get_text('remote', lang)
                        }
                        equip_name = equip_names.get(equipment, equipment)
                        await query.answer(get_text('equipment_updated', lang).format(equipment=equip_name, status=status), show_alert=True)
                        
                        # Refresh room management page directly
                        await self._show_room_manage(query, room_id)
                    else:
                        await query.answer(get_text('room_equipment_error', lang), show_alert=True)
                else:
                    await query.answer(get_text('room_not_found', lang), show_alert=True)
            
            # Room Management: Delete room confirmation
            elif query.data.startswith("room_delete_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("room_delete_", ""))
                room = get_room_by_id(self.db, room_id)
                
                if room:
                    floor = room['id_room'][:-2] if len(room['id_room']) > 2 else "1"
                    
                    text = f"""⚠️ Potvrda brisanja

Da li ste sigurni da želite da obrišete sobu {room['id_room']}?

Ova akcija se ne može poništiti!"""
                    
                    keyboard = [
                        [
                            InlineKeyboardButton("✅ Da, obriši", callback_data=f"room_confirm_delete_{room_id}"),
                            InlineKeyboardButton("❌ Ne, otkaži", callback_data=f"room_manage_{room_id}")
                        ]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("Soba nije pronađena.", show_alert=True)
            
            # Room Management: Confirm delete room
            elif query.data.startswith("room_confirm_delete_"):
                from database import delete_room, get_room_by_id
                
                room_id = int(query.data.replace("room_confirm_delete_", ""))
                room = get_room_by_id(self.db, room_id)
                lang = get_user_language(query.from_user.id, self.db)
                
                if room:
                    floor = room['id_room'][:-2] if len(room['id_room']) > 2 else "1"
                    room_number = room['id_room']
                    
                    if delete_room(self.db, room_id):
                        await query.answer(get_text('room_deleted', lang).format(room_number=room_number), show_alert=True)
                        
                        # Go back to floor view directly
                        await self._show_floor_rooms(query, floor)
                    else:
                        await query.answer(get_text('room_delete_error', lang), show_alert=True)
                else:
                    await query.answer(get_text('room_not_found', lang), show_alert=True)
            
            # Room Management: Set check-in number (MUST BE BEFORE room_checkin_)
            elif query.data.startswith("room_checkin_set_"):
                from database import get_room_by_id
                
                parts = query.data.replace("room_checkin_set_", "").split("_")
                room_id = int(parts[0])
                num_guests = int(parts[1])
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_room_by_id(self.db, room_id)
                if room:
                    current_guests = room.get('current_guests', 0)
                    new_total = current_guests + num_guests
                    
                    if self.db.update_room_guests(room_id, new_total):
                        if new_total > 0:
                            self.db.execute_query("UPDATE tbl_customer_rooms SET is_check = 1 WHERE id = %s", (room_id,))
                        
                        await query.answer(get_text('guests_checked_in_count', lang).format(num_guests=num_guests), show_alert=True)
                        await self._show_room_manage(query, room_id)
                    else:
                        await query.answer(get_text('guests_checkin_error', lang), show_alert=True)
            
            # Room Management: Check-in guests
            elif query.data.startswith("room_checkin_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("room_checkin_", ""))
                room = get_room_by_id(self.db, room_id)
                lang = get_user_language(query.from_user.id, self.db)
                
                if room:
                    current_guests = room.get('current_guests', 0)
                    total_capacity = room.get('total_capacity', 2)
                    available = total_capacity - current_guests
                    
                    text = f"""{get_text('checkin_guests_title', lang).format(room_id=room['id_room'])}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 TRENUTNO STANJE
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('current_guests', lang)}: {current_guests}
🏨 {get_text('capacity_label', lang).replace('👥 ', '')}: {total_capacity}
{get_text('available_spaces', lang)}: {available}

{get_text('how_many_checkin', lang)}"""
                    
                    keyboard = []
                    row = []
                    # Generate buttons for available capacity
                    for i in range(1, min(available + 1, 6)):
                        row.append(InlineKeyboardButton(f"{i}", callback_data=f"room_checkin_set_{room_id}_{i}"))
                        if len(row) == 5:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data=f"room_manage_{room_id}")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    lang = get_user_language(query.from_user.id, self.db)
                    await query.answer(get_text('room_not_found', lang), show_alert=True)
            
            # Room Management: Set check-out number (MUST BE BEFORE room_checkout_)
            elif query.data.startswith("room_checkout_set_"):
                from database import get_room_by_id
                
                parts = query.data.replace("room_checkout_set_", "").split("_")
                room_id = int(parts[0])
                num_guests = int(parts[1])
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_room_by_id(self.db, room_id)
                if room:
                    current_guests = room.get('current_guests', 0)
                    new_total = max(0, current_guests - num_guests)
                    
                    if self.db.update_room_guests(room_id, new_total):
                        if new_total == 0:
                            self.db.execute_query("UPDATE tbl_customer_rooms SET is_check = 0 WHERE id = %s", (room_id,))
                        
                        await query.answer(get_text('guests_checked_out_count', lang).format(num_guests=num_guests), show_alert=True)
                        await self._show_room_manage(query, room_id)
                    else:
                        await query.answer(get_text('guests_checkout_error', lang), show_alert=True)
            
            # Room Management: Check-out guests
            elif query.data.startswith("room_checkout_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("room_checkout_", ""))
                room = get_room_by_id(self.db, room_id)
                lang = get_user_language(query.from_user.id, self.db)
                
                if room:
                    current_guests = room.get('current_guests', 0)
                    
                    if current_guests == 0:
                        await query.answer(get_text('no_guests_in_room', lang), show_alert=True)
                        return
                    
                    text = f"""{get_text('checkout_guests_title', lang).format(room_id=room['id_room'])}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 TRENUTNO STANJE
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('current_guests', lang)}: {current_guests}

{get_text('how_many_checkout', lang)}"""
                    
                    keyboard = []
                    row = []
                    # Generate buttons for current guests
                    for i in range(1, min(current_guests + 1, 6)):
                        row.append(InlineKeyboardButton(f"{i}", callback_data=f"room_checkout_set_{room_id}_{i}"))
                        if len(row) == 5:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton("🚪 Odjavi sve", callback_data=f"room_checkout_set_{room_id}_{current_guests}")])
                    keyboard.append([InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data=f"room_manage_{room_id}")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("Soba nije pronađena.", show_alert=True)
            
            # Room Management: Set room capacity
            elif query.data.startswith("room_set_capacity_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("room_set_capacity_", ""))
                room = get_room_by_id(self.db, room_id)
                lang = get_user_language(query.from_user.id, self.db)
                
                if room:
                    current_capacity = room.get('total_capacity', 2)
                    
                    text = f"""{get_text('capacity_settings_title', lang).format(room_id=room['id_room'])}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 TRENUTNO STANJE
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('current_capacity_label', lang)}: {current_capacity} osoba

{get_text('select_new_capacity_prompt', lang)}"""
                    
                    keyboard = []
                    row = []
                    # Create buttons for 1-20 capacity, 5 buttons per row
                    for i in range(1, 21):
                        emoji = "✅" if i == current_capacity else ""
                        row.append(InlineKeyboardButton(f"{emoji}{i}", callback_data=f"room_capacity_set_{room_id}_{i}"))
                        if len(row) == 5:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data=f"room_manage_{room_id}")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('room_not_found', lang), show_alert=True)
            
            # Room Management: Confirm capacity change
            elif query.data.startswith("room_capacity_set_"):
                parts = query.data.replace("room_capacity_set_", "").split("_")
                room_id = int(parts[0])
                new_capacity = int(parts[1])
                lang = get_user_language(query.from_user.id, self.db)
                
                if self.db.update_room_capacity(room_id, new_capacity):
                    await query.answer(get_text('capacity_set_success', lang).format(capacity=new_capacity), show_alert=True)
                    await self._show_room_manage(query, room_id)
                else:
                    await query.answer(get_text('capacity_set_error', lang), show_alert=True)
            
            # Room View: Set check-in number (MUST BE BEFORE room_view_checkin_)
            elif query.data.startswith("room_view_checkin_set_"):
                from database import get_room_by_id
                
                parts = query.data.replace("room_view_checkin_set_", "").split("_")
                room_id = int(parts[0])
                num_guests = int(parts[1])
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_room_by_id(self.db, room_id)
                if room:
                    current_guests = room.get('current_guests', 0)
                    new_total = current_guests + num_guests
                    
                    if self.db.update_room_guests(room_id, new_total):
                        if new_total > 0:
                            self.db.execute_query("UPDATE tbl_customer_rooms SET is_check = 1 WHERE id = %s", (room_id,))
                        
                        await query.answer(get_text('guests_checked_in_count', lang).format(num_guests=num_guests), show_alert=True)
                        # Refresh room detail view
                        await self._show_room_detail(query, room_id, telegram_user_id)
                    else:
                        await query.answer(get_text('guests_checkin_error', lang), show_alert=True)
            
            # Room View (Reception): Check-in guests
            elif query.data.startswith("room_view_checkin_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("room_view_checkin_", ""))
                room = get_room_by_id(self.db, room_id)
                lang = get_user_language(query.from_user.id, self.db)

                
                if room:
                    current_guests = room.get('current_guests', 0)
                    total_capacity = room.get('total_capacity', 2)
                    available = total_capacity - current_guests
                    
                    text = f"""{get_text('checkin_guests_title', lang).format(room_id=room['id_room'])}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 TRENUTNO STANJE
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('current_guests', lang)}: {current_guests}
🏨 {get_text('capacity_label', lang).replace('👥 ', '')}: {total_capacity}
{get_text('available_spaces', lang)}: {available}

{get_text('how_many_checkin', lang)}"""
                    
                    keyboard = []
                    row = []
                    # Generate buttons up to available capacity (max 20)
                    max_checkin = min(available, 20)
                    for i in range(1, max_checkin + 1):
                        row.append(InlineKeyboardButton(f"{i}", callback_data=f"room_view_checkin_set_{room_id}_{i}"))
                        if len(row) == 5:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data=f"room_{room_id}")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("Soba nije pronađena.", show_alert=True)
            
            # Room View: Set check-out number (MUST BE BEFORE room_view_checkout_)
            elif query.data.startswith("room_view_checkout_set_"):
                from database import get_room_by_id
                
                parts = query.data.replace("room_view_checkout_set_", "").split("_")
                room_id = int(parts[0])
                num_guests = int(parts[1])
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_room_by_id(self.db, room_id)
                if room:
                    current_guests = room.get('current_guests', 0)
                    new_total = max(0, current_guests - num_guests)
                    
                    if self.db.update_room_guests(room_id, new_total):
                        if new_total == 0:
                            self.db.execute_query("UPDATE tbl_customer_rooms SET is_check = 0 WHERE id = %s", (room_id,))
                        
                        await query.answer(get_text('guests_checked_out_count', lang).format(num_guests=num_guests), show_alert=True)
                        # Refresh room detail view
                        await self._show_room_detail(query, room_id, telegram_user_id)
                    else:
                        await query.answer(get_text('guests_checkout_error', lang), show_alert=True)
            
            # Room View: Check-out guests
            elif query.data.startswith("room_view_checkout_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("room_view_checkout_", ""))
                room = get_room_by_id(self.db, room_id)
                lang = get_user_language(query.from_user.id, self.db)
                
                if room:
                    current_guests = room.get('current_guests', 0)
                    
                    if current_guests == 0:
                        await query.answer(get_text('no_guests_in_room', lang), show_alert=True)
                        return
                    
                    text = f"""{get_text('checkout_guests_title', lang).format(room_id=room['id_room'])}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 TRENUTNO STANJE
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('current_guests', lang)}: {current_guests}

{get_text('how_many_checkout', lang)}"""
                    
                    keyboard = []
                    row = []
                    # Generate buttons for current guests (max 20)
                    max_checkout = min(current_guests, 20)
                    for i in range(1, max_checkout + 1):
                        row.append(InlineKeyboardButton(f"{i}", callback_data=f"room_view_checkout_set_{room_id}_{i}"))
                        if len(row) == 5:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    # Add "Check out all" button if there are more guests
                    if current_guests > 0:
                        keyboard.append([InlineKeyboardButton("🚪 Odjavi sve", callback_data=f"room_view_checkout_set_{room_id}_{current_guests}")])
                    keyboard.append([InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data=f"room_{room_id}")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("Soba nije pronađena.", show_alert=True)
            
            # Room View: Confirm capacity change (MUST BE BEFORE room_view_capacity_)
            elif query.data.startswith("room_view_capacity_set_"):
                parts = query.data.replace("room_view_capacity_set_", "").split("_")
                room_id = int(parts[0])
                new_capacity = int(parts[1])
                
                if self.db.update_room_capacity(room_id, new_capacity):
                    await query.answer(f"✅ Kapacitet postavljen na {new_capacity} osoba!", show_alert=True)
                    # Refresh room detail view
                    await self._show_room_detail(query, room_id, telegram_user_id)
                else:
                    await query.answer("❌ Greška pri postavljanju kapaciteta.", show_alert=True)
            
            # Room View: Set room capacity
            elif query.data.startswith("room_view_capacity_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("room_view_capacity_", ""))
                room = get_room_by_id(self.db, room_id)
                lang = get_user_language(telegram_user_id, self.db)
                
                if room:
                    current_capacity = room.get('total_capacity', 2)
                    
                    text = f"""👥 Podešavanje kapaciteta - Soba {room['id_room']}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 TRENUTNO STANJE
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🏨 Trenutni kapacitet: {current_capacity} osoba

Izaberite novi kapacitet (1-20):"""
                    
                    keyboard = []
                    row = []
                    # Create buttons for 1-20 capacity, 5 buttons per row
                    for i in range(1, 21):
                        emoji = "✅" if i == current_capacity else ""
                        row.append(InlineKeyboardButton(f"{emoji}{i}", callback_data=f"room_view_capacity_set_{room_id}_{i}"))
                        if len(row) == 5:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data=f"room_{room_id}")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("Soba nije pronađena.", show_alert=True)
            
            # Room Management: Create new room - Step 1: Select floor
            elif query.data == "room_create_new":
                await self._show_room_create_floor_select(query)
            
            # Hotel Settings: Edit hotel capacity
            elif query.data == "hotel_settings_edit":
                lang = get_user_language(telegram_user_id, self.db)
                hotel_settings = self.db.get_hotel_settings()
                room_summary = self.db.get_customer_rooms_summary()
                
                text = f"""{get_text('hotel_settings_edit_title', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('current_settings_header', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('hotel_name_label', lang)}: {hotel_settings['hotel_name']}
{get_text('set_capacity_label', lang)}: {hotel_settings['total_rooms']} {get_text('rooms_label', lang)}
{get_text('currently_registered_label', lang)}: {room_summary['total']} {get_text('rooms_label', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('information_header', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('capacity_info_text', lang)}

Trenutno registrovanih soba u sistemu: {room_summary['total']}

{get_text('enter_new_room_count_prompt', lang)}"""
                
                keyboard = [
                    [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="action_2")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Set state to wait for total_rooms input
                context.user_data['awaiting_hotel_capacity'] = True
            
            # Room Management: Create new room - Step 2: Select room number
            elif query.data.startswith("room_new_floor_"):
                floor = query.data.replace("room_new_floor_", "")
                await self._show_room_create_num_select(query, floor)
            
            # Room Management: Room already exists notification
            elif query.data.startswith("room_exists_"):
                parts = query.data.replace("room_exists_", "").split("_")
                floor = parts[0]
                room_num = parts[1]
                room_id = f"{floor}{room_num.zfill(2)}" if int(room_num) < 10 else f"{floor}{room_num}"
                await query.answer(f"Soba {room_id} već postoji!", show_alert=True)
            
            # Handle room selection - show detail (only when room_<number>) - MUST BE LAST
            elif query.data.startswith("room_") and query.data.replace("room_", "").isdigit():
                room_id = int(query.data.replace("room_", ""))
                lang = get_user_language(telegram_user_id, self.db)
                room = self.db.get_room_detail(room_id)
                
                if not room:
                    await query.edit_message_text("❌ Soba nije pronađena.")
                    return
                
                room_id, id_room, is_check, ac, tv, toilet, remote, total_capacity, current_guests = room
                
                # Status text mapping (handles both string/integer)
                check_status = "🔴 Zauzeto" if str(is_check) == "1" else "🟢 Slobodno"
                ac_status = "✅ Dobro" if str(ac) == "1" else "❌ Loše"
                tv_status = "✅ Dobro" if str(tv) == "1" else "❌ Loše"
                toilet_status = "✅ Dobro" if str(toilet) == "1" else "❌ Loše"
                remote_status = "✅ Dobro" if str(remote) == "1" else "❌ Loše"
                
                # Check if user is admin or reception
                employee_info = self.db.get_employee_info(telegram_user_id)
                is_admin_or_reception = False
                if employee_info:
                    dept = employee_info['department']
                    is_admin_or_reception = (dept == 'Management' or dept == 'Reception')
                
                room_info = f"""🚪 Soba {id_room} - Detalji

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 STATUS
━━━━━━━━━━━━━━━━━━━━━━━━━━━

📍 Zauzetost: {check_status}
👥 Gosti: {current_guests}/{total_capacity} osoba

━━━━━━━━━━━━━━━━━━━━━━━━━━━
🛠️ OPREMA
━━━━━━━━━━━━━━━━━━━━━━━━━━━

❄️ Klima: {ac_status}
📺 TV: {tv_status}
🚽 Toalet: {toilet_status}
🎮 Daljinski: {remote_status}"""
                
                keyboard = []
                
                # Add management buttons for admin/reception
                if is_admin_or_reception:
                    keyboard.append([
                        InlineKeyboardButton("➕ Prijavi goste", callback_data=f"room_view_checkin_{room_id}"),
                        InlineKeyboardButton("➖ Odjavi goste", callback_data=f"room_view_checkout_{room_id}")
                    ])
                    keyboard.append([
                        InlineKeyboardButton(f"👥 {get_text('set_capacity', lang)}", callback_data=f"room_view_capacity_{room_id}")
                    ])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back_to_rooms', lang)}", callback_data="dept_2")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(room_info, reply_markup=reply_markup)
            
            # Room Management: Create room with selected floor and number
            elif query.data.startswith("room_new_num_"):
                from database import create_room_inactive
                
                parts = query.data.replace("room_new_num_", "").split("_")
                floor = parts[0]
                room_num = parts[1]
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Generate room ID (e.g., floor=1, num=5 -> "105", floor=1, num=12 -> "112")
                room_id = f"{floor}{room_num.zfill(2)}" if int(room_num) < 10 else f"{floor}{room_num}"
                
                if create_room_inactive(self.db, room_id):
                    text = f"""✅ {get_text('room_created_success', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 {get_text('new_room_details', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🚪 {get_text('room_number', lang)}: {room_id}
🏢 {get_text('floor', lang)}: {floor}
📍 {get_text('status', lang)}: ⚫ {get_text('inactive', lang)} ({get_text('awaiting_approval', lang)})

⚠️ {get_text('room_created_inactive_notice', lang)}"""
                    
                    keyboard = [
                        [InlineKeyboardButton(f"➕ {get_text('create_another_room', lang)}", callback_data="room_create_new")],
                        [InlineKeyboardButton(f"🔙 {get_text('back_to_room_management', lang)}", callback_data="action_2")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('room_creation_error', lang), show_alert=True)
            
            # Task Creation: Step 2 - Select Employee
            elif query.data.startswith("task_dept_"):
                dept_id = query.data.replace("task_dept_", "")
                
                # Save department info
                departments = self.db.get_departments()
                dept_name = None
                for d_id, d_name, d_content in departments:
                    if str(d_id) == dept_id:
                        dept_name = d_name
                        break
                
                if 'task_creation' not in context.user_data:
                    context.user_data['task_creation'] = {}
                
                context.user_data['task_creation']['department_id'] = dept_id
                context.user_data['task_creation']['department_name'] = dept_name
                context.user_data['task_creation']['step'] = 'employee'
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get employee list for this department (employee_id, telegram_user_id, name, work_role)
                employees = self.db.get_employees_by_department(dept_name)
                
                keyboard = []
                if employees:
                    for emp_id, emp_telegram_id, emp_name, emp_work_role in employees:
                        # Display work role next to employee name
                        role_display = f" ({emp_work_role})" if emp_work_role else ""
                        keyboard.append([InlineKeyboardButton(f"👤 {emp_name}{role_display}", callback_data=f"task_emp_{emp_telegram_id}")])
                
                keyboard.append([
                    InlineKeyboardButton(get_text('back', lang), callback_data="action_1"),
                    InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")
                ])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                emp_count = len(employees) if employees else 0
                
                if emp_count == 0:
                    await query.edit_message_text(
                        f"📝 {get_text('create_task_step', lang)} 2/6\n\n🏢 {get_text('department', lang)}: {dept_name}\n\n⚠️ {get_text('no_employees_in_dept', lang)}\n\n{get_text('please_add_employees_first', lang)}",
                        reply_markup=reply_markup
                    )
                else:
                    await query.edit_message_text(
                        f"📝 {get_text('create_task_step', lang)} 2/6\n\n🏢 {get_text('department', lang)}: {dept_name}\n\n👤 {get_text('select_employee', lang)} ({emp_count} {get_text('available_count', lang)}):\n\n{get_text('select_assignee_hint', lang)}",
                        reply_markup=reply_markup
                    )
            
            # Task Creation: Step 3 - Employee selected, ask for description
            elif query.data.startswith("task_emp_"):
                emp_id = query.data.replace("task_emp_", "")
                
                # Initialize task_creation if not exists
                if 'task_creation' not in context.user_data:
                    context.user_data['task_creation'] = {}
                
                # Get employee info (employee_id, telegram_user_id, name, department, work_role)
                emp_info = self.db.get_employee_info_by_telegram_id(int(emp_id))
                if emp_info:
                    context.user_data['task_creation']['employee_id'] = int(emp_id)
                    context.user_data['task_creation']['employee_name'] = emp_info.get('name', 'Unknown')
                    context.user_data['task_creation']['employee_work_role'] = emp_info.get('work_role', '')
                
                context.user_data['task_creation']['step'] = 'description'
                
                lang = get_user_language(telegram_user_id, self.db)
                dept_name = context.user_data['task_creation'].get('department_name', 'Unknown')
                emp_name = context.user_data['task_creation'].get('employee_name', 'Unknown')
                emp_work_role = context.user_data['task_creation'].get('employee_work_role', '')
                # Display employee name and work role
                emp_name_display = f"{emp_name} ({emp_work_role})" if emp_work_role else emp_name
                
                keyboard = [
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"task_dept_{context.user_data['task_creation']['department_id']}")],
                    [InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(
                    f"📝 {get_text('create_task_step', lang)} 3/6\n\n🏢 {get_text('department', lang)}: {dept_name}\n👤 {get_text('assigned_to', lang)}: {emp_name_display}\n\n📋 {get_text('enter_task_description', lang)}:\n\n{get_text('type_and_send_description', lang)}",
                    reply_markup=reply_markup
                )
            
            # Task Creation: Step 4 - Priority Selection (just toggle, don't proceed)
            elif query.data.startswith("task_priority_"):
                priority = query.data.replace("task_priority_", "")
                
                # Initialize task_creation if not exists
                if 'task_creation' not in context.user_data:
                    context.user_data['task_creation'] = {}
                
                context.user_data['task_creation']['priority'] = priority
                
                # Refresh the priority screen directly
                lang = get_user_language(telegram_user_id, self.db)
                dept_name = context.user_data['task_creation'].get('department_name', 'Unknown')
                emp_name = context.user_data['task_creation'].get('employee_name', 'Unassigned')
                emp_name_display = get_text('not_assigned', lang) if emp_name == "Unassigned" else emp_name
                description = context.user_data['task_creation'].get('description', 'N/A')
                current_priority = context.user_data['task_creation'].get('priority', 'Normal')
                proof_required = context.user_data['task_creation'].get('proof_required', False)
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Low' else '⬜'} 🟢 {get_text('priority_low', lang)}", callback_data="task_priority_Low"),
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Normal' else '⬜'} 🟡 {get_text('priority_normal', lang)}", callback_data="task_priority_Normal"),
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Urgent' else '⬜'} 🔴 {get_text('priority_urgent', lang)}", callback_data="task_priority_Urgent")
                    ],
                    [
                        InlineKeyboardButton(f"{'✅' if proof_required else '⬜'} 📸 {get_text('proof_required', lang)}", callback_data="task_toggle_proof")
                    ],
                    [
                        InlineKeyboardButton(f"➡️ {get_text('next', lang)}", callback_data="task_proceed_duedate")
                    ],
                    [
                        InlineKeyboardButton(get_text('back', lang), callback_data=f"task_emp_{context.user_data['task_creation'].get('employee_id', 'skip')}" if context.user_data['task_creation'].get('employee_id') else "task_skip_emp"),
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(current_priority, "🟡")
                priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(current_priority, current_priority)
                proof_status = get_text('proof_required_yes', lang) if proof_required else get_text('proof_required_no', lang)
                
                await query.edit_message_text(
                    f"📝 {get_text('create_task_step', lang)} 4/6\n\n🏢 {get_text('department', lang)}: {dept_name}\n👤 {get_text('assigned_to', lang)}: {emp_name_display}\n📋 {get_text('description', lang)}: {description[:50]}{'...' if len(description) > 50 else ''}\n{priority_emoji} {get_text('priority', lang)}: {priority_display}\n📸 {get_text('proof_required', lang)}: {proof_status}\n\n⚡ {get_text('select_priority_and_proof', lang)}:",
                    reply_markup=reply_markup
                )
            
            # Task Creation: Proceed to due date after priority & proof selection
            elif query.data == "task_proceed_duedate":
                from datetime import datetime as dt
                
                lang = get_user_language(telegram_user_id, self.db)
                context.user_data['task_creation']['step'] = 'due_date'
                
                dept_name = context.user_data['task_creation'].get('department_name') or get_text('unknown', lang)
                emp_name = context.user_data['task_creation'].get('employee_name') or get_text('not_assigned', lang)
                description = context.user_data['task_creation'].get('description', 'N/A')
                priority = context.user_data['task_creation'].get('priority', 'Normal')
                proof_required = context.user_data['task_creation'].get('proof_required', False)
                
                # Create calendar keyboard
                today = dt.now()
                keyboard = create_calendar(today.year, today.month, lang)
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="task_show_priority")])
                keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "🟡")
                priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(priority, priority)
                proof_display = get_text('proof_required_yes', lang) if proof_required else get_text('proof_required_no', lang)
                
                await query.edit_message_text(
                    f"📝 {get_text('create_task_step', lang)} 5/6\n\n🏢 {get_text('department', lang)}: {dept_name}\n👤 {get_text('assigned_to', lang)}: {emp_name}\n📋 {get_text('description', lang)}: {description[:50]}{'...' if len(description) > 50 else ''}\n{priority_emoji} {get_text('priority', lang)}: {priority_display}\n📸 {get_text('proof_required', lang)}: {proof_display}\n\n📆 {get_text('select_due_date', lang)}:",
                    reply_markup=reply_markup
                )
            
            # Calendar navigation - Previous month
            elif query.data.startswith("cal_prev_"):
                from datetime import datetime as dt
                parts = query.data.split("_")
                year, month = int(parts[2]), int(parts[3])
                
                # Go to previous month
                if month == 1:
                    year -= 1
                    month = 12
                else:
                    month -= 1
                
                # Don't go before current month
                today = dt.now()
                if year < today.year or (year == today.year and month < today.month):
                    year, month = today.year, today.month
                
                lang = get_user_language(telegram_user_id, self.db)
                dept_name = context.user_data['task_creation'].get('department_name', get_text('unknown', lang))
                emp_name = context.user_data['task_creation'].get('employee_name', get_text('not_assigned', lang))
                description = context.user_data['task_creation'].get('description', 'N/A')
                priority = context.user_data['task_creation'].get('priority', 'Normal')
                
                keyboard = create_calendar(year, month, lang)
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="task_show_priority")])
                keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "🟡")
                priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(priority, priority)
                
                await query.edit_message_text(
                    f"📝 {get_text('create_task_step', lang)} 5/6\n\n🏢 {get_text('department', lang)}: {dept_name}\n👤 {get_text('assigned_to', lang)}: {emp_name}\n📋 {get_text('description', lang)}: {description[:50]}{'...' if len(description) > 50 else ''}\n{priority_emoji} {get_text('priority', lang)}: {priority_display}\n\n📆 {get_text('select_due_date', lang)}:",
                    reply_markup=reply_markup
                )
            
            # Calendar navigation - Next month
            elif query.data.startswith("cal_next_"):
                parts = query.data.split("_")
                year, month = int(parts[2]), int(parts[3])
                
                # Go to next month
                if month == 12:
                    year += 1
                    month = 1
                else:
                    month += 1
                
                lang = get_user_language(telegram_user_id, self.db)
                dept_name = context.user_data['task_creation'].get('department_name', get_text('unknown', lang))
                emp_name = context.user_data['task_creation'].get('employee_name', get_text('not_assigned', lang))
                description = context.user_data['task_creation'].get('description', 'N/A')
                priority = context.user_data['task_creation'].get('priority', 'Normal')
                
                keyboard = create_calendar(year, month, lang)
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="task_show_priority")])
                keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "🟡")
                priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(priority, priority)
                
                await query.edit_message_text(
                    f"📝 {get_text('create_task_step', lang)} 5/6\n\n🏢 {get_text('department', lang)}: {dept_name}\n👤 {get_text('assigned_to', lang)}: {emp_name}\n📋 {get_text('description', lang)}: {description[:50]}{'...' if len(description) > 50 else ''}\n{priority_emoji} {get_text('priority', lang)}: {priority_display}\n\n📆 {get_text('select_due_date', lang)}:",
                    reply_markup=reply_markup
                )
            
            # Calendar ignore (for headers and disabled dates)
            elif query.data == "cal_ignore":
                await query.answer()  # Do nothing, just acknowledge
            
            # Back to priority selection
            elif query.data == "task_show_priority":
                context.user_data['task_creation']['step'] = 'priority'
                
                lang = get_user_language(telegram_user_id, self.db)
                dept_name = context.user_data['task_creation'].get('department_name', 'Unknown')
                emp_name = context.user_data['task_creation'].get('employee_name', 'Unassigned')
                emp_name_display = get_text('not_assigned', lang) if emp_name == "Unassigned" else emp_name
                description = context.user_data['task_creation'].get('description', 'N/A')
                current_priority = context.user_data['task_creation'].get('priority', 'Normal')
                proof_required = context.user_data['task_creation'].get('proof_required', False)
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Low' else '⬜'} 🟢 {get_text('priority_low', lang)}", callback_data="task_priority_Low"),
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Normal' else '⬜'} 🟡 {get_text('priority_normal', lang)}", callback_data="task_priority_Normal"),
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Urgent' else '⬜'} 🔴 {get_text('priority_urgent', lang)}", callback_data="task_priority_Urgent")
                    ],
                    [
                        InlineKeyboardButton(f"{'✅' if proof_required else '⬜'} 📸 {get_text('proof_required', lang)}", callback_data="task_toggle_proof")
                    ],
                    [
                        InlineKeyboardButton(f"➡️ {get_text('next', lang)}", callback_data="task_proceed_duedate")
                    ],
                    [
                        InlineKeyboardButton(get_text('back', lang), callback_data=f"task_emp_{context.user_data['task_creation'].get('employee_id', 'skip')}" if context.user_data['task_creation'].get('employee_id') else "task_skip_emp"),
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(current_priority, "🟡")
                priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(current_priority, current_priority)
                proof_status = get_text('proof_required_yes', lang) if proof_required else get_text('proof_required_no', lang)
                
                await query.edit_message_text(
                    f"📝 {get_text('create_task_step', lang)} 4/6\n\n🏢 {get_text('department', lang)}: {dept_name}\n👤 {get_text('assigned_to', lang)}: {emp_name_display}\n📋 {get_text('description', lang)}: {description[:50]}{'...' if len(description) > 50 else ''}\n{priority_emoji} {get_text('priority', lang)}: {priority_display}\n📸 {get_text('proof_required', lang)}: {proof_status}\n\n⚡ {get_text('select_priority_and_proof', lang)}:",
                    reply_markup=reply_markup
                )
            
            # Toggle proof required
            elif query.data == "task_toggle_proof":
                context.user_data['task_creation']['proof_required'] = not context.user_data['task_creation'].get('proof_required', False)
                
                # Refresh the priority screen directly
                lang = get_user_language(telegram_user_id, self.db)
                dept_name = context.user_data['task_creation'].get('department_name', 'Unknown')
                emp_name = context.user_data['task_creation'].get('employee_name', 'Unassigned')
                emp_name_display = get_text('not_assigned', lang) if emp_name == "Unassigned" else emp_name
                description = context.user_data['task_creation'].get('description', 'N/A')
                current_priority = context.user_data['task_creation'].get('priority', 'Normal')
                proof_required = context.user_data['task_creation'].get('proof_required', False)
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Low' else '⬜'} 🟢 {get_text('priority_low', lang)}", callback_data="task_priority_Low"),
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Normal' else '⬜'} 🟡 {get_text('priority_normal', lang)}", callback_data="task_priority_Normal"),
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Urgent' else '⬜'} 🔴 {get_text('priority_urgent', lang)}", callback_data="task_priority_Urgent")
                    ],
                    [
                        InlineKeyboardButton(f"{'✅' if proof_required else '⬜'} 📸 {get_text('proof_required', lang)}", callback_data="task_toggle_proof")
                    ],
                    [
                        InlineKeyboardButton(f"➡️ {get_text('next', lang)}", callback_data="task_proceed_duedate")
                    ],
                    [
                        InlineKeyboardButton(get_text('back', lang), callback_data=f"task_emp_{context.user_data['task_creation'].get('employee_id', 'skip')}" if context.user_data['task_creation'].get('employee_id') else "task_skip_emp"),
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(current_priority, "🟡")
                priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(current_priority, current_priority)
                proof_status = get_text('proof_required_yes', lang) if proof_required else get_text('proof_required_no', lang)
                
                await query.edit_message_text(
                    f"📝 {get_text('create_task_step', lang)} 4/6\n\n🏢 {get_text('department', lang)}: {dept_name}\n👤 {get_text('assigned_to', lang)}: {emp_name_display}\n📋 {get_text('description', lang)}: {description[:50]}{'...' if len(description) > 50 else ''}\n{priority_emoji} {get_text('priority', lang)}: {priority_display}\n📸 {get_text('proof_required', lang)}: {proof_status}\n\n⚡ {get_text('select_priority_and_proof', lang)}:",
                    reply_markup=reply_markup
                )
            
            # Task Creation: Step 5 - Due Date Selected -> Ask for attachment
            elif query.data.startswith("task_date_"):
                due_date = query.data.replace("task_date_", "")
                
                # Initialize task_creation if not exists
                if 'task_creation' not in context.user_data:
                    context.user_data['task_creation'] = {}
                
                context.user_data['task_creation']['due_date'] = due_date
                context.user_data['task_creation']['step'] = 'attachment'
                
                lang = get_user_language(telegram_user_id, self.db)
                dept_name = context.user_data['task_creation'].get('department_name', get_text('unknown', lang))
                emp_name = context.user_data['task_creation'].get('employee_name', get_text('not_assigned', lang))
                emp_name_display = get_text('not_assigned', lang) if emp_name == "Unassigned" else emp_name
                description = context.user_data['task_creation'].get('description', 'N/A')
                priority = context.user_data['task_creation'].get('priority', 'Normal')
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "🟡")
                priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(priority, priority)
                
                text = f"📝 {get_text('create_task_step', lang)} 6/6\n\n"
                text += f"🏢 {get_text('department', lang)}: {dept_name}\n"
                text += f"👤 {get_text('assigned_to', lang)}: {emp_name_display}\n"
                text += f"📋 {get_text('description', lang)}:\n{description}\n"
                text += f"{priority_emoji} {get_text('priority', lang)}: {priority_display}\n"
                text += f"📆 {get_text('due_date', lang)}: {due_date}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"📎 {get_text('attach_document', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('send_photo_or_document', lang)}\n"
                text += f"{get_text('or_press_skip', lang)}:"
                
                context.user_data['awaiting_task_attachment'] = True
                
                keyboard = [
                    [InlineKeyboardButton(f"⏭️ {get_text('skip_attachment', lang)}", callback_data="task_skip_attachment")],
                    [InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Task Creation: Skip Attachment -> Show Confirmation
            elif query.data == "task_skip_attachment":
                context.user_data.pop('awaiting_task_attachment', None)
                # Clear attachments if user chooses to skip
                if 'task_creation' in context.user_data:
                    context.user_data['task_creation']['attachments'] = []
                
                # Show confirmation
                task_data = context.user_data['task_creation']
                dept_name = task_data.get('department_name', 'Nepoznato')
                emp_name = task_data.get('employee_name', 'Nedodeljeno')
                emp_name_display = "Nedodeljeno" if emp_name == "Unassigned" else emp_name
                description = task_data.get('description', 'N/A')
                priority = task_data.get('priority', 'Normal')
                due_date = task_data.get('due_date', 'N/A')
                proof_required = task_data.get('proof_required', False)
                
                lang = get_user_language(telegram_user_id, self.db)
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "🟡")
                priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(priority, priority)
                proof_display = get_text('proof_required_yes', lang) if proof_required else get_text('proof_required_no', lang)
                
                text = f"📝 {get_text('task_confirmation_title', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"🏢 {get_text('department', lang)}: {dept_name}\n"
                text += f"👤 {get_text('assigned_to', lang)}: {emp_name_display}\n"
                text += f"📋 {get_text('description', lang)}:\n{description}\n"
                text += f"{priority_emoji} {get_text('priority', lang)}: {priority_display}\n"
                text += f"📆 {get_text('due_date', lang)}: {due_date}\n"
                text += f"📸 {get_text('proof_required', lang)}: {proof_display}\n"
                text += f"📎 {get_text('attachment', lang)}: {get_text('not_attached', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('confirm_task_creation', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"✅ {get_text('confirm', lang)}", callback_data="task_confirm"),
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Task Creation: Final - Confirm and Create
            elif query.data == "task_confirm":
                task_data = context.user_data.get('task_creation', {})
                lang = get_user_language(telegram_user_id, self.db)
                
                # Add created_by (current user's telegram_user_id)
                task_data['created_by'] = update.effective_user.id
                
                # Get attachments info
                attachments = task_data.get('attachments', [])
                attachment_count = len(attachments) if attachments else 0
                
                # Convert to JSON for storage (legacy compatibility)
                import json
                if attachments:
                    task_data['attachment'] = json.dumps(attachments)
                    task_data['attachment_type'] = f"📎 {attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}"
                else:
                    task_data['attachment'] = None
                    task_data['attachment_type'] = ''
                
                proof_required = task_data.get('proof_required', False)
                
                # Create task
                result = self.db.create_task(task_data)
                
                if result is not None:
                    context.user_data.pop('awaiting_task_attachment', None)
                    dept_name = task_data.get('department_name', get_text('unknown', lang))
                    emp_name = task_data.get('employee_name', 'Unassigned')
                    emp_name_display = get_text('not_assigned', lang) if emp_name == "Unassigned" else emp_name
                    emp_id = task_data.get('employee_id')
                    description = task_data.get('description', 'N/A')
                    priority = task_data.get('priority', 'Normal')
                    due_date = task_data.get('due_date', 'N/A')
                    
                    priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "🟡")
                    priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(priority, priority)
                    proof_display = get_text('proof_required_yes', lang) if proof_required else get_text('proof_required_no', lang)
                    
                    print(f"📤 Task created: ID={result}, emp_id={emp_id}, emp_name={emp_name}, proof_required={proof_required}, attachments={attachment_count}")
                    
                    # Send notification to assignee if assigned
                    if emp_id:
                        print(f"📤 Sending notification to employee: {emp_id}")
                        try:
                            # Get recipient's language preference
                            emp_lang = get_user_language(emp_id, self.db)
                            emp_priority_display = {"Low": get_text('priority_low', emp_lang), "Normal": get_text('priority_normal', emp_lang), "Urgent": get_text('priority_urgent', emp_lang)}.get(priority, priority)
                            emp_proof_display = get_text('proof_required_yes', emp_lang) if proof_required else get_text('proof_required_no', emp_lang)
                            
                            attachment_text = f"{attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}" if attachment_count > 0 else get_text('not_attached', emp_lang)
                            
                            notification_text = f"""{get_text('task_notification_title', emp_lang)}

🏢 {get_text('department', emp_lang)}: {dept_name}
📝 {get_text('task_order', emp_lang)}:
{description}
{priority_emoji} {get_text('priority', emp_lang)}: {emp_priority_display}
📆 {get_text('due_date', emp_lang)}: {due_date}
📸 {get_text('proof_required', emp_lang)}: {emp_proof_display}
📎 {get_text('attachment', emp_lang)}: {attachment_text}"""
                            
                            # Create accept/reject buttons
                            notification_keyboard = InlineKeyboardMarkup([
                                [
                                    InlineKeyboardButton(get_text('task_accept', emp_lang), callback_data=f"task_accept_{result}"),
                                    InlineKeyboardButton(get_text('task_reject', emp_lang), callback_data=f"task_reject_{result}")
                                ]
                            ])
                            
                            # Send main notification
                            await self.application.bot.send_message(
                                chat_id=emp_id,
                                text=notification_text,
                                reply_markup=notification_keyboard
                            )
                            
                            # Send attachments as media group
                            if attachments:
                                from telegram import InputMediaPhoto, InputMediaVideo
                                
                                media_group = []
                                documents = []
                                
                                for idx, attachment in enumerate(attachments):
                                    file_id = attachment.get('file_id')
                                    file_type = attachment.get('type', 'photo')
                                    
                                    # Add caption only to the first media item
                                    caption = f"📎 {attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}" if idx == 0 else None
                                    
                                    if file_type == 'photo':
                                        media_group.append(InputMediaPhoto(media=file_id, caption=caption))
                                    elif file_type == 'video':
                                        media_group.append(InputMediaVideo(media=file_id, caption=caption))
                                    elif file_type == 'document':
                                        documents.append(file_id)
                                
                                # Send media group (photos/videos together)
                                if media_group:
                                    try:
                                        await self.application.bot.send_media_group(
                                            chat_id=emp_id,
                                            media=media_group
                                        )
                                    except Exception as e:
                                        print(f"❌ Failed to send media group: {e}")
                                
                                # Send documents individually
                                for idx, doc_id in enumerate(documents, 1):
                                    try:
                                        await self.application.bot.send_document(
                                            chat_id=emp_id,
                                            document=doc_id,
                                            caption=f"📎 Dokument {idx}/{len(documents)}"
                                        )
                                    except Exception as e:
                                        print(f"❌ Failed to send document {idx}: {e}")
                            
                            notification_sent = True
                            
                            # Record notification sent time
                            if notification_sent:
                                self.db.mark_task_notification_sent(result)
                                print(f"✅ Notification sent successfully to {emp_id}")
                        except Exception as e:
                            print(f"❌ Failed to send task notification to {emp_id}: {e}")
                    else:
                        print(f"⚠️ No employee assigned (emp_id is None or empty)")
                    
                    # Show attachment count in success message
                    if attachment_count > 0:
                        attachment_text = f"📎 {attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}"
                    else:
                        attachment_text = get_text('not_attached', lang)
                    
                    success_text = f"""✅ {get_text('task_created_success', lang)}

📋 {get_text('task_details', lang)}:
━━━━━━━━━━━━━━━━━━
🏢 {get_text('department', lang)}: {dept_name}
👤 {get_text('assigned_to', lang)}: {emp_name_display}
📝 {get_text('task_order', lang)}: {description}
{priority_emoji} {get_text('priority', lang)}: {priority_display}
📆 {get_text('due_date', lang)}: {due_date}
📸 {get_text('proof_required', lang)}: {proof_display}
📎 {get_text('attachment', lang)}: {attachment_text}
━━━━━━━━━━━━━━━━━━

{get_text('task_id', lang)}: #{result}"""
                    
                    # Log task creation event
                    try:
                        event_logger = get_event_logger()
                        event_logger.log_task_created(
                            user_id=telegram_user_id,
                            user_name=query.from_user.full_name,
                            task_id=result,
                            task_description=description[:100] if description else "",
                            assignee=emp_name,
                            department=dept_name,
                            priority=priority
                        )
                    except Exception as log_error:
                        print(f"Event logging error: {log_error}")
                    
                    # Clear task creation data
                    context.user_data.pop('task_creation', None)
                    context.user_data.pop('awaiting_task_attachment', None)
                    
                    keyboard = [
                        [InlineKeyboardButton(f"📝 {get_text('create_another_task', lang)}", callback_data="action_1")],
                        [InlineKeyboardButton(f"🔙 {get_text('back_to_actions', lang)}", callback_data="actions")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await query.edit_message_text(success_text, reply_markup=reply_markup)
                else:
                    await query.edit_message_text(f"❌ {get_text('task_creation_failed', lang)}")
                    context.user_data.pop('task_creation', None)
                    context.user_data.pop('awaiting_task_attachment', None)
            
            # Task Accept/Reject by Employee
            elif query.data.startswith("task_accept_"):
                task_id = int(query.data.replace("task_accept_", ""))
                lang = get_user_language(telegram_user_id, self.db)
                
                # Mark task as read/accepted
                self.db.mark_task_notification_read(task_id)
                
                try:
                    await query.edit_message_reply_markup(reply_markup=None)
                except:
                    pass
                
                await query.answer(get_text('task_accepted_msg', lang), show_alert=True)
                
            elif query.data.startswith("task_reject_"):
                task_id = int(query.data.replace("task_reject_", ""))
                lang = get_user_language(telegram_user_id, self.db)
                
                try:
                    await query.edit_message_reply_markup(reply_markup=None)
                except:
                    pass
                
                await query.answer(get_text('task_rejected_msg', lang), show_alert=True)
            
            # ========== Employee Registration Process ==========
            # Step 1: Department Selection -> Step 2: Work Role Selection
            # Registration - Language Selection
            elif query.data.startswith("reg_lang_"):
                new_lang = query.data.replace("reg_lang_", "")
                set_user_language(telegram_user_id, new_lang, self.db)
                
                if 'registration' not in context.user_data:
                    context.user_data['registration'] = {}
                
                context.user_data['registration']['step'] = 'department'
                context.user_data['registration']['language'] = new_lang
                
                # Get department list (excluding Management)
                departments = self.db.get_departments(exclude_management=True)
                
                if not departments:
                    await query.edit_message_text(get_text('no_departments', new_lang))
                    return
                
                keyboard = []
                for dept_id, dept_name, dept_content in departments:
                    emoji = get_dept_emoji(dept_name)
                    dept_display = get_dept_display(dept_name, new_lang)
                    keyboard.append([InlineKeyboardButton(f"{emoji} {dept_display}", callback_data=f"reg_dept_{dept_name}")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                username = context.user_data['registration'].get('username', 'Unknown')
                step_text = get_text('step_x_of_y', new_lang).format(current=1, total=3)
                welcome_text = f"""{get_text('registration_welcome', new_lang)}

{get_text('welcome', new_lang)} @{username}! 👋

📍 {step_text}: {get_text('registration_select_department', new_lang)}"""
                
                await query.edit_message_text(welcome_text, reply_markup=reply_markup)
            
            # Registration - Department Selection
            elif query.data.startswith("reg_dept_"):
                from database import get_all_work_roles
                
                dept_name = query.data.replace("reg_dept_", "")
                lang = get_user_language(telegram_user_id, self.db)
                
                if 'registration' not in context.user_data:
                    context.user_data['registration'] = {}
                
                context.user_data['registration']['department'] = dept_name
                
                # Get available work roles
                work_roles = get_all_work_roles(self.db)
                
                emoji = get_dept_emoji(dept_name)
                dept_display = get_dept_display(dept_name)
                
                if work_roles:
                    # Show work role selection
                    context.user_data['registration']['step'] = 'work_role'
                    
                    step_text = get_text('step_x_of_y', lang).format(current=2, total=3)
                    text = f"""🏨 {get_text('employee_registration', lang)}

{emoji} {get_text('department', lang)}: {dept_display}

📍 {step_text}: {get_text('select_work_role', lang)}

{get_text('select_position_hint', lang)}"""
                    
                    keyboard = []
                    row = []
                    for role_id, role_name, description, created_at in work_roles:
                        role_emoji = get_role_emoji(role_name)
                        role_display = get_work_role_display(role_name, lang)
                        row.append(InlineKeyboardButton(f"{role_emoji} {role_display}", callback_data=f"reg_role_{role_id}"))
                        if len(row) == 3:
                            keyboard.append(row)
                            row = []
                    if row:  # Add remaining buttons
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reg_back_to_dept")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    # No work roles available, skip to name input
                    context.user_data['registration']['step'] = 'name'
                    context.user_data['registration']['work_role'] = None
                    
                    step_text = get_text('step_x_of_y', lang).format(current=2, total=2)
                    await query.edit_message_text(
                        f"""🏨 {get_text('employee_registration', lang)}

{emoji} {get_text('department', lang)}: {dept_display}

📍 {step_text}: {get_text('enter_full_name', lang)}

{get_text('type_and_send_name', lang)}"""
                    )
            
            # Registration: Back to department selection
            elif query.data == "reg_back_to_dept":
                # Clear registration data except telegram_user_id
                telegram_user_id = update.effective_user.id
                username = update.effective_user.username or "Unknown"
                
                context.user_data['registration'] = {
                    'step': 'department',
                    'telegram_user_id': telegram_user_id,
                    'username': username
                }
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get department list (excluding Management)
                departments = self.db.get_departments(exclude_management=True)
                
                keyboard = []
                for dept_id, dept_name, dept_content in departments:
                    emoji = get_dept_emoji(dept_name)
                    dept_display = get_dept_display(dept_name)
                    keyboard.append([InlineKeyboardButton(f"{emoji} {dept_display}", callback_data=f"reg_dept_{dept_name}")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                step_text = get_text('step_x_of_y', lang).format(current=1, total=3)
                await query.edit_message_text(
                    f"""🏨 {get_text('registration_welcome', lang)}

{get_text('hello', lang) if 'hello' in TRANSLATIONS.get(lang, {}) else 'Hello'} @{username}! 👋

📍 {step_text}: {get_text('registration_select_department', lang)}""", reply_markup=reply_markup
                )
            
            # Step 2: Work Role Selection -> Step 3: Name Input
            elif query.data.startswith("reg_role_"):
                from database import get_work_role_by_id
                
                role_id = int(query.data.replace("reg_role_", ""))
                role = get_work_role_by_id(self.db, role_id)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if role:
                    context.user_data['registration']['work_role'] = role['role_name']
                else:
                    context.user_data['registration']['work_role'] = None
                
                context.user_data['registration']['step'] = 'name'
                
                dept_name = context.user_data['registration'].get('department', 'Unknown')
                emoji = get_dept_emoji(dept_name)
                dept_display = get_dept_display(dept_name)
                role_name = role['role_name'] if role else None
                role_display = get_work_role_display(role_name, lang) if role_name else get_text('not_selected', lang)
                
                step_text = get_text('step_x_of_y', lang).format(current=3, total=3)
                await query.edit_message_text(
                    f"""🏨 {get_text('employee_registration', lang)}

{emoji} {get_text('department', lang)}: {dept_display}
💼 {get_text('work_role', lang)}: {role_display}

📍 {step_text}: {get_text('enter_full_name', lang)}

{get_text('type_and_send_name', lang)}"""
                )
            
            # ========== Work Menu ==========
            elif query.data == "emp_work_menu":
                telegram_user_id = update.effective_user.id
                employee = self.db.check_employee_exists(telegram_user_id)
                
                if not employee:
                    await query.edit_message_text("❌ Molimo koristite /start da se prvo registrujete.")
                    return
                
                employee_id, name, department, work_role, gmail, whatsapp = employee
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get employee's work role
                emp_info = self.db.get_employee_info(telegram_user_id)
                work_role = emp_info.get('work_role', '') if emp_info else ''
                role_emoji = get_role_emoji(work_role)
                
                text = f"""💼 {get_text('jobs', lang)} - {name}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 {role_emoji} {work_role if work_role else get_text('no_role_assigned', lang)}
🏢 {get_dept_emoji(department)} {get_dept_display(department, lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('select_option', lang)}"""
                
                # Build menu based on work role
                keyboard = [
                    [InlineKeyboardButton(get_text('receive_task', lang), callback_data="emp_my_tasks")]
]                # Add role-specific buttons based on work_role
                if work_role == "Рецепционар" or work_role == "Receptionist":
                    keyboard.append([
                        InlineKeyboardButton(get_text('reception_btn', lang), callback_data="emp_work_reception"),
                        InlineKeyboardButton(get_text('rooms_btn', lang), callback_data="emp_work_rooms")
                    ])
                    keyboard.append([
                        InlineKeyboardButton(get_text('assign_laundry', lang), callback_data="emp_assign_laundry"),
                        InlineKeyboardButton(get_text('assign_kitchen', lang), callback_data="emp_assign_kitchen")
                    ])
                    keyboard.append([
                        InlineKeyboardButton(get_text('assign_driver', lang), callback_data="emp_assign_driver"),
                        InlineKeyboardButton(get_text('assign_accounting', lang), callback_data="emp_assign_accounting")
                    ])
                    keyboard.append([
                        InlineKeyboardButton(get_text('assign_technician', lang), callback_data="emp_assign_repair")
                    ])
                elif work_role == "Спремачица" or work_role == "Cleaner" or work_role == "Домаћица" or work_role == "Housekeeper":
                    keyboard.append([
                        InlineKeyboardButton(get_text('cleaning', lang), callback_data="emp_work_cleaning"),
                        InlineKeyboardButton(get_text('my_laundry_tasks', lang), callback_data="my_laundry_tasks")
                    ])
                elif work_role == "Кувар" or work_role == "Cook" or work_role == "Waiter" or work_role == "Kelner" or work_role == "Келнер":
                    keyboard.append([
                        InlineKeyboardButton(get_text('kitchen_btn', lang), callback_data="emp_work_kitchen"),
                        InlineKeyboardButton(get_text('inventory', lang), callback_data="emp_work_inventory")
                    ])
                    keyboard.append([
                        InlineKeyboardButton(get_text('my_kitchen_tasks', lang), callback_data="my_restaurant_tasks")
                    ])
                elif work_role == "Мајстор" or work_role == "Technician" or work_role == "Техничар":
                    keyboard.append([
                        InlineKeyboardButton("🔧 Popravke", callback_data="emp_work_repairs"),
                        InlineKeyboardButton("⚡ Održavanje", callback_data="emp_work_maintenance")
                    ])
                    keyboard.append([
                        InlineKeyboardButton("🔧 Moji zadaci za popravke", callback_data="my_repair_tasks")
                    ])
                elif work_role == "Возач" or work_role == "Driver":
                    keyboard.append([
                        InlineKeyboardButton("🚗 Transport", callback_data="emp_work_transport"),
                        InlineKeyboardButton("📋 Rute", callback_data="emp_work_routes")
                    ])
                    keyboard.append([
                        InlineKeyboardButton("🚗 Moji zadaci za vožnju", callback_data="my_delivery_tasks")
                    ])
                elif work_role == "Рачуновођа" or work_role == "Accountant" or work_role == "Касир" or work_role == "Cashier":
                    keyboard.append([
                        InlineKeyboardButton(get_text('finances', lang), callback_data="emp_work_finance"),
                        InlineKeyboardButton(get_text('reports', lang), callback_data="emp_work_reports")
                    ])
                    keyboard.append([
                        InlineKeyboardButton(get_text('my_accounting_tasks', lang), callback_data="my_accounting_tasks")
                    ])
                elif work_role == "Вођа тима" or work_role == "Team Leader" or work_role == "Менаџер" or work_role == "Manager":
                    keyboard.append([
                        InlineKeyboardButton(get_text('team', lang), callback_data="emp_work_team"),
                        InlineKeyboardButton(get_text('overview', lang), callback_data="emp_work_overview")
                    ])
                
                # Add tool management for all employees
                # keyboard.append([InlineKeyboardButton("🔧 Upravljanje alatima", callback_data="reception_tools")])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="back_to_employee_menu")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ========== Work Sub-menus ==========
            elif query.data.startswith("emp_work_"):
                work_type = query.data.replace("emp_work_", "")
                lang = get_user_language(query.from_user.id, self.db)
                
                # Special handling for "reception" - show keys management only
                if work_type == "reception":
                    text = f"{get_text('reception_select_option', lang)}\n\n"
                    text += get_text('key_management', lang)
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('key_management', lang), callback_data="reception_keys")],
                        [InlineKeyboardButton(f"🔧 {get_text('tool_management', lang)}", callback_data="reception_tools")],
                        [InlineKeyboardButton(f"🚗 {get_text('vehicle_usage', lang)}", callback_data="reception_vehicles")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Special handling for "rooms" - show floor selection
                elif work_type == "rooms":
                    # Get only floors that have rooms
                    from database import get_floors_with_rooms
                    floors_with_rooms = get_floors_with_rooms(self.db)
                    
                    if not floors_with_rooms:
                        text = f"""🚪 {get_text('room_management', lang)}

⚠️ {get_text('no_active_rooms', lang)}"""
                        keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await query.edit_message_text(text, reply_markup=reply_markup)
                        return
                    
                    text = f"""🚪 {get_text('room_management', lang)}

{get_text('select_floor', lang)}:"""
                    
                    keyboard = []
                    row = []
                    for floor in floors_with_rooms:
                        row.append(InlineKeyboardButton(f"🏢 {floor}", callback_data=f"emp_room_floor_{floor}"))
                        if len(row) == 5:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")])
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Special handling for "cleaning" - show cleaning menu
                elif work_type == "cleaning":
                    from database import get_today_clean_records, get_cleaner_stats
                    
                    telegram_user_id = update.effective_user.id
                    today_records = get_today_clean_records(self.db)
                    my_stats = get_cleaner_stats(self.db, telegram_user_id, days=1)
                    
                    text = f"{get_text('cleaning_daily_report', lang)}\n\n"
                    text += f"{get_text('today_cleaned', lang)} {my_stats.get('total', 0)} {get_text('spaces', lang)}\n"
                    text += f"{get_text('guest_rooms_cleaned', lang)} {my_stats.get('guest_room', {}).get('total', 0)}\n"
                    text += f"{get_text('staff_rooms_cleaned', lang)} {my_stats.get('staff_room', {}).get('total', 0)}\n\n"
                    text += f"{get_text('select_cleaning_type', lang)}"
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('clean_guest_rooms', lang), callback_data="clean_guest_rooms")],
                        [InlineKeyboardButton(get_text('clean_staff_rooms', lang), callback_data="clean_staff_rooms")],
                        [InlineKeyboardButton(get_text('my_cleaning_report', lang), callback_data="clean_my_stats")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Special handling for "finance" - show finance menu for accountants
                elif work_type == "finance":
                    from database import get_finance_daily_report, get_financial_transactions
                    
                    telegram_user_id = update.effective_user.id
                    
                    # Get daily report
                    daily_report = get_finance_daily_report(self.db)
                    
                    text = f"💰 {get_text('finances', lang)}\n\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"📅 {get_text('today_summary', lang)}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    
                    if daily_report:
                        income = daily_report.get('total_income', 0)
                        expense = daily_report.get('total_expense', 0)
                        net = daily_report.get('net', 0)
                        
                        text += f"📈 {get_text('income', lang)}: {income:,.2f} RSD\n"
                        text += f"📉 {get_text('expense', lang)}: {expense:,.2f} RSD\n"
                        text += f"💵 {get_text('net', lang)}: {net:,.2f} RSD\n\n"
                        text += f"📊 {get_text('transactions', lang)}: "
                        text += f"{daily_report.get('income_count', 0)} {get_text('incomes', lang)}, "
                        text += f"{daily_report.get('expense_count', 0)} {get_text('expenses', lang)}\n"
                    else:
                        text += f"ℹ️ {get_text('no_transactions_today', lang)}\n"
                    
                    text += "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"{get_text('select_option', lang)}"
                    
                    keyboard = [
                        [InlineKeyboardButton(f"📝 {get_text('record_transaction', lang)}", callback_data="finance_record")],
                        [InlineKeyboardButton(f"📊 {get_text('view_transactions', lang)}", callback_data="finance_view_today")],
                        [InlineKeyboardButton(f"📅 {get_text('weekly_report', lang)}", callback_data="finance_report_week")],
                        [InlineKeyboardButton(f"📆 {get_text('monthly_report', lang)}", callback_data="finance_report_month")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Kitchen feature - for restaurant cooks/chefs
                elif work_type == "kitchen":
                    from database import get_kitchen_menu_items
                    
                    menu_items = get_kitchen_menu_items(self.db)
                    
                    text = f"🍳 {get_text('work_kitchen', lang)}\n\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"📋 Today's Menu Items\n\n"
                    
                    if menu_items:
                        # Group by category
                        categories = {}
                        for item in menu_items:
                            cat = item['category']
                            if cat not in categories:
                                categories[cat] = []
                            categories[cat].append(item)
                        
                        for category, items in categories.items():
                            text += f"▫️ {category}\n"
                            for item in items:
                                status_icon = "✅" if item['status'] == 'Ready' else "🔄" if item['status'] == 'Cooking' else "⏳"
                                text += f"  {status_icon} {item['name']}\n"
                                text += f"     Qty: {item['quantity']} | {item['status']}\n"
                            text += "\n"
                    else:
                        text += "ℹ️ No menu items for today\n\n"
                    
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    
                    keyboard = [
                        [InlineKeyboardButton("➕ Add Item", callback_data="kitchen_add"),
                         InlineKeyboardButton("✏️ Update Status", callback_data="kitchen_update")],
                        [InlineKeyboardButton("🔄 Refresh", callback_data="emp_work_kitchen")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                
                # Inventory feature - for restaurant staff
                elif work_type == "inventory":
                    from database import get_inventory_items, get_inventory_summary
                    
                    items = get_inventory_items(self.db)
                    summary = get_inventory_summary(self.db)
                    
                    text = f"📦 {get_text('work_inventory', lang)}\n\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"📊 Stock Summary\n"
                    text += f"   ✅ OK: {summary['ok']} items\n"
                    text += f"   ⚠️ Low: {summary['low']} items\n"
                    text += f"   🚨 Critical: {summary['critical']} items\n"
                    text += f"   📈 Total: {summary['total']} items\n\n"
                    
                    # Show critical and low stock items first
                    critical_items = [i for i in items if i['status'] == 'Critical']
                    low_items = [i for i in items if i['status'] == 'Low']
                    ok_items = [i for i in items if i['status'] == 'OK']
                    
                    if critical_items:
                        text += "🚨 Critical Stock:\n"
                        for item in critical_items:
                            text += f"  ❗ {item['name']}\n"
                            text += f"     {item['stock']}/{item['min_stock']} {item['unit']}\n"
                        text += "\n"
                    
                    if low_items:
                        text += "⚠️ Low Stock:\n"
                        for item in low_items:
                            text += f"  ⚠️ {item['name']}\n"
                            text += f"     {item['stock']}/{item['min_stock']} {item['unit']}\n"
                        text += "\n"
                    
                    if ok_items:
                        text += "✅ OK Stock (showing first 3):\n"
                        for item in ok_items[:3]:
                            text += f"  ✅ {item['name']}: {item['stock']} {item['unit']}\n"
                        if len(ok_items) > 3:
                            text += f"  ... and {len(ok_items) - 3} more\n"
                        text += "\n"
                    
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    
                    keyboard = [
                        [InlineKeyboardButton("➕ Add Item", callback_data="inventory_add"),
                         InlineKeyboardButton("✏️ Update Stock", callback_data="inventory_update")],
                        [InlineKeyboardButton("📋 All Items", callback_data="inventory_all")],
                        [InlineKeyboardButton("🔄 Refresh", callback_data="emp_work_inventory")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                
                else:
                    # Placeholder for other role-specific features
                    work_titles = {
                        "reception": get_text('work_reception', lang),
                        "cleaning": get_text('work_cleaning', lang),
                        "repairs": get_text('work_repairs', lang),
                        "maintenance": get_text('work_maintenance', lang),
                        "transport": get_text('work_transport', lang),
                        "routes": get_text('work_routes', lang),
                        "reports": get_text('work_reports', lang),
                        "team": get_text('work_team', lang),
                        "overview": get_text('work_overview', lang)
                    }
                    
                    title = work_titles.get(work_type, get_text('work_default', lang))
                    
                    text = f"""{title}

━━━━━━━━━━━━━━━━━━━━━━━━━━━

{get_text('feature_in_development', lang)}

{get_text('coming_soon', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━"""
                    
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ========== Kitchen Menu Management ==========
            # Update menu item status
            elif query.data == "kitchen_update":
                from database import get_kitchen_menu_items
                
                lang = get_user_language(telegram_user_id, self.db)
                menu_items = get_kitchen_menu_items(self.db)
                
                text = "✏️ Update Menu Item Status\n\n"
                text += "Select an item to update:\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                keyboard = []
                for item in menu_items:
                    status_icon = "✅" if item['status'] == 'Ready' else "🔄" if item['status'] == 'Cooking' else "⏳"
                    keyboard.append([InlineKeyboardButton(
                        f"{status_icon} {item['name']} ({item['status']})",
                        callback_data=f"kitchen_item_{item['id']}"
                    )])
                
                keyboard.append([InlineKeyboardButton("🔙 Back", callback_data="emp_work_kitchen")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Select menu item to update status
            elif query.data.startswith("kitchen_item_"):
                item_id = query.data.replace("kitchen_item_", "")
                lang = get_user_language(telegram_user_id, self.db)
                
                text = f"Select new status for item #{item_id}:\n\n"
                
                keyboard = [
                    [InlineKeyboardButton("⏳ Pending", callback_data=f"kitchen_status_{item_id}_Pending")],
                    [InlineKeyboardButton("🔄 Cooking", callback_data=f"kitchen_status_{item_id}_Cooking")],
                    [InlineKeyboardButton("✅ Ready", callback_data=f"kitchen_status_{item_id}_Ready")],
                    [InlineKeyboardButton("🔙 Back", callback_data="kitchen_update")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Update menu item status
            elif query.data.startswith("kitchen_status_"):
                from database import update_menu_item_status, get_menu_item_by_id
                
                parts = query.data.replace("kitchen_status_", "").split("_")
                item_id = int(parts[0])
                new_status = parts[1]
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get current state before update
                old_item = get_menu_item_by_id(self.db, item_id) if hasattr(self.db, 'cursor') else None
                old_status = old_item.get('status') if old_item else None
                item_name = old_item.get('name') if old_item else f"Item #{item_id}"
                
                if update_menu_item_status(self.db, item_id, new_status):
                    # Log action with before/after state
                    employee = self.db.check_employee_exists(telegram_user_id)
                    if employee:
                        employee_id, name, department, work_role, gmail, whatsapp = employee
                        try:
                            event_logger = get_event_logger()
                            event_logger.log_menu_status_change(
                                user_id=telegram_user_id,
                                user_name=name,
                                item_id=item_id,
                                item_name=item_name,
                                old_status=old_status,
                                new_status=new_status,
                                department=department,
                                employee_id=employee_id
                            )
                        except Exception as log_error:
                            print(f"Event logging error: {log_error}")
                    
                    await query.answer(f"✅ Status updated to {new_status}", show_alert=True)
                    # Return to kitchen menu
                    context.user_data['callback_query_data'] = 'emp_work_kitchen'
                    await self.button_handler(update, context)
                else:
                    await query.answer("❌ Error updating status", show_alert=True)
            
            # ========== Inventory Management ==========
            # Update inventory stock
            elif query.data == "inventory_update":
                from database import get_inventory_items
                
                lang = get_user_language(telegram_user_id, self.db)
                items = get_inventory_items(self.db)
                
                text = "✏️ Update Inventory Stock\n\n"
                text += "Select an item to update:\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                keyboard = []
                for item in items:
                    status_icon = "🚨" if item['status'] == 'Critical' else "⚠️" if item['status'] == 'Low' else "✅"
                    keyboard.append([InlineKeyboardButton(
                        f"{status_icon} {item['name']} ({item['stock']} {item['unit']})",
                        callback_data=f"inventory_item_{item['id']}"
                    )])
                
                keyboard.append([InlineKeyboardButton("🔙 Back", callback_data="emp_work_inventory")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Show all inventory items
            elif query.data == "inventory_all":
                from database import get_inventory_items
                
                lang = get_user_language(telegram_user_id, self.db)
                items = get_inventory_items(self.db)
                
                text = "📦 All Inventory Items\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                # Group by category
                categories = {}
                for item in items:
                    cat = item['category']
                    if cat not in categories:
                        categories[cat] = []
                    categories[cat].append(item)
                
                for category, cat_items in categories.items():
                    text += f"▫️ {category}\n"
                    for item in cat_items:
                        status_icon = "🚨" if item['status'] == 'Critical' else "⚠️" if item['status'] == 'Low' else "✅"
                        text += f"  {status_icon} {item['name']}: {item['stock']} {item['unit']}\n"
                    text += "\n"
                
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                
                keyboard = [[InlineKeyboardButton("🔙 Back", callback_data="emp_work_inventory")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Select inventory item to update
            elif query.data.startswith("inventory_item_"):
                item_id = int(query.data.replace("inventory_item_", ""))
                from database import get_inventory_items
                
                lang = get_user_language(telegram_user_id, self.db)
                items = get_inventory_items(self.db)
                item = next((i for i in items if i['id'] == item_id), None)
                
                if item:
                    text = f"📦 {item['name']}\n\n"
                    text += f"Current Stock: {item['stock']} {item['unit']}\n"
                    text += f"Minimum: {item['min_stock']} {item['unit']}\n"
                    text += f"Status: {item['status']}\n\n"
                    text += "Enter new stock amount:\n"
                    text += "(Send a number, e.g., 25.5)"
                    
                    # Store item info in context
                    context.user_data['updating_inventory_item'] = item_id
                    context.user_data['inventory_item_unit'] = item['unit']
                    context.user_data['callback_query_data'] = 'inventory_update'
                    
                    keyboard = [[InlineKeyboardButton("❌ Cancel", callback_data="inventory_update")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("❌ Item not found", show_alert=True)
            
            # ========== Employee Room Management ==========
            # Floor selection for employee
            elif query.data.startswith("emp_room_floor_"):
                floor = query.data.replace("emp_room_floor_", "")
                await self._show_floor_rooms(query, floor, back_callback="emp_work_rooms", room_callback_prefix="emp_room_")
            
            # Employee Room Equipment Toggle - MUST be before general emp_room_
            elif query.data.startswith("emp_room_equip_"):
                from database import update_room_equipment, get_room_by_id
                
                # Format: emp_room_equip_AC_123 or emp_room_equip_Remote_Control_123
                data = query.data.replace("emp_room_equip_", "")
                # Split from the right to get room_id (last part after last underscore)
                parts = data.rsplit("_", 1)
                equipment = parts[0]
                room_id = int(parts[1])
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_room_by_id(self.db, room_id)
                if room:
                    current_value = str(room.get(equipment, "1"))
                    new_value = "0" if current_value == "1" else "1"
                    
                    if update_room_equipment(self.db, room_id, equipment, new_value):
                        status = get_text('equipment_working', lang) if new_value == "1" else get_text('equipment_not_working', lang)
                        equip_names = {
                            "AC": get_text('climate', lang),
                            "TV": get_text('tv', lang),
                            "Toilet": get_text('toilet', lang),
                            "Remote_Control": get_text('remote', lang)
                        }
                        equip_name = equip_names.get(equipment, equipment)
                        await query.answer(get_text('equipment_updated', lang).format(equipment=equip_name, status=status), show_alert=True)
                        
                        # Refresh employee room view
                        room = get_room_by_id(self.db, room_id)
                        
                        # Status icons
                        active_icon = "✅" if room['is_active'] == 1 else "❌"
                        check_icon = "🔴" if str(room['is_check']) == "1" else "🟢"
                        ac_icon = "✅" if str(room['AC']) == "1" else "❌"
                        tv_icon = "✅" if str(room['TV']) == "1" else "❌"
                        toilet_icon = "✅" if str(room['Toilet']) == "1" else "❌"
                        remote_icon = "✅" if str(room['Remote_Control']) == "1" else "❌"
                        
                        total_capacity = room.get('total_capacity', 2)
                        current_guests = room.get('current_guests', 0)
                        available = total_capacity - current_guests
                        percent = int((current_guests / total_capacity * 100)) if total_capacity > 0 else 0
                        
                        floor = room['id_room'][:-2] if len(room['id_room']) > 2 else "1"
                        
                        lang = get_user_language(query.from_user.id, self.db)
                        
                        room_info = f"""🚪 Soba {room['id_room']}

📊 STATUS
{get_text('status_label', lang)}: {active_icon} | {get_text('occupancy_label', lang)}: {check_icon}

{get_text('capacity_label', lang)}
{get_text('capacity_info', lang).format(total_capacity=total_capacity, current_guests=current_guests, available=available)}
{get_text('occupancy_percentage', lang).format(percentage=percent)}

{get_text('equipment_label', lang)}
❄️ {get_text('climate', lang)}: {ac_icon} | 📺 {get_text('tv', lang)}: {tv_icon}
🚽 {get_text('toilet', lang)}: {toilet_icon} | 🎮 {get_text('remote', lang)}: {remote_icon}"""
                        
                        toggle_text = get_text('deactivate', lang) if room['is_active'] == 1 else get_text('activate', lang)
                        
                        keyboard = [
                            [InlineKeyboardButton(toggle_text, callback_data=f"emp_room_toggle_{room_id}")],
                            [InlineKeyboardButton(get_text('check_in_guests', lang), callback_data=f"emp_room_checkin_{room_id}"),
                             InlineKeyboardButton(get_text('check_out_guests', lang), callback_data=f"emp_room_checkout_{room_id}")],
                            [InlineKeyboardButton(get_text('set_capacity', lang), callback_data=f"emp_room_capacity_{room_id}")],
                            [InlineKeyboardButton(f"❄️ {get_text('climate', lang)} {ac_icon}", callback_data=f"emp_room_equip_AC_{room_id}"),
                             InlineKeyboardButton(f"📺 {get_text('tv', lang)} {tv_icon}", callback_data=f"emp_room_equip_TV_{room_id}")],
                            [InlineKeyboardButton(f"🚽 {get_text('toilet', lang)} {toilet_icon}", callback_data=f"emp_room_equip_Toilet_{room_id}"),
                             InlineKeyboardButton(f"🎮 {get_text('remote', lang)} {remote_icon}", callback_data=f"emp_room_equip_Remote_Control_{room_id}")],
                            [InlineKeyboardButton(get_text('back_to_rooms', lang), callback_data=f"emp_room_floor_{floor}")]
                        ]
                        
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await query.edit_message_text(room_info, reply_markup=reply_markup)
                    else:
                        await query.answer(get_text('room_equipment_error', lang), show_alert=True)
                else:
                    await query.answer(get_text('room_not_found', lang), show_alert=True)
            
            # Employee Room Toggle Active/Inactive
            elif query.data.startswith("emp_room_toggle_"):
                from database import toggle_room_active, get_room_by_id
                
                room_id = int(query.data.replace("emp_room_toggle_", ""))
                room = get_room_by_id(self.db, room_id)
                lang = get_user_language(query.from_user.id, self.db)
                
                if room:
                    new_status = 0 if room['is_active'] == 1 else 1
                    if toggle_room_active(self.db, room_id, new_status):
                        status_msg = get_text('room_activated', lang) if new_status == 1 else get_text('room_deactivated', lang)
                        await query.answer(status_msg, show_alert=True)
                        
                        # Refresh employee room view
                        room = get_room_by_id(self.db, room_id)
                        
                        active_icon = "✅" if room['is_active'] == 1 else "❌"
                        check_icon = "🔴" if str(room['is_check']) == "1" else "🟢"
                        ac_icon = "✅" if str(room['AC']) == "1" else "❌"
                        tv_icon = "✅" if str(room['TV']) == "1" else "❌"
                        toilet_icon = "✅" if str(room['Toilet']) == "1" else "❌"
                        remote_icon = "✅" if str(room['Remote_Control']) == "1" else "❌"
                        
                        total_capacity = room.get('total_capacity', 2)
                        current_guests = room.get('current_guests', 0)
                        available = total_capacity - current_guests
                        percent = int((current_guests / total_capacity * 100)) if total_capacity > 0 else 0
                        
                        floor = room['id_room'][:-2] if len(room['id_room']) > 2 else "1"
                        
                        lang = get_user_language(query.from_user.id, self.db)
                        
                        room_info = f"""🚪 Soba {room['id_room']}

📊 STATUS
{get_text('status_label', lang)}: {active_icon} | {get_text('occupancy_label', lang)}: {check_icon}

{get_text('capacity_label', lang)}
{get_text('capacity_info', lang).format(total_capacity=total_capacity, current_guests=current_guests, available=available)}
{get_text('occupancy_percentage', lang).format(percentage=percent)}

{get_text('equipment_label', lang)}
❄️ {get_text('climate', lang)}: {ac_icon} | 📺 {get_text('tv', lang)}: {tv_icon}
🚽 {get_text('toilet', lang)}: {toilet_icon} | 🎮 {get_text('remote', lang)}: {remote_icon}"""
                        
                        toggle_text = get_text('deactivate', lang) if room['is_active'] == 1 else get_text('activate', lang)
                        
                        keyboard = [
                            [InlineKeyboardButton(toggle_text, callback_data=f"emp_room_toggle_{room_id}")],
                            [InlineKeyboardButton(get_text('check_in_guests', lang), callback_data=f"emp_room_checkin_{room_id}"),
                             InlineKeyboardButton(get_text('check_out_guests', lang), callback_data=f"emp_room_checkout_{room_id}")],
                            [InlineKeyboardButton(get_text('set_capacity', lang), callback_data=f"emp_room_capacity_{room_id}")],
                            [InlineKeyboardButton(f"❄️ {get_text('climate', lang)} {ac_icon}", callback_data=f"emp_room_equip_AC_{room_id}"),
                             InlineKeyboardButton(f"📺 {get_text('tv', lang)} {tv_icon}", callback_data=f"emp_room_equip_TV_{room_id}")],
                            [InlineKeyboardButton(f"🚽 {get_text('toilet', lang)} {toilet_icon}", callback_data=f"emp_room_equip_Toilet_{room_id}"),
                             InlineKeyboardButton(f"🎮 {get_text('remote', lang)} {remote_icon}", callback_data=f"emp_room_equip_Remote_Control_{room_id}")],
                            [InlineKeyboardButton(get_text('back_to_rooms', lang), callback_data=f"emp_room_floor_{floor}")]
                        ]
                        
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await query.edit_message_text(room_info, reply_markup=reply_markup)
                    else:
                        lang = get_user_language(query.from_user.id, self.db)
                        await query.answer(get_text('room_status_toggle_error', lang), show_alert=True)
                else:
                    lang = get_user_language(query.from_user.id, self.db)
                    await query.answer(get_text('room_not_found', lang), show_alert=True)
            
            # Employee Room Check-in
            elif query.data.startswith("emp_room_checkin_set_"):
                from database import update_room_guests, get_room_by_id
                
                parts = query.data.replace("emp_room_checkin_set_", "").split("_")
                room_id = int(parts[0])
                guests = int(parts[1])
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_room_by_id(self.db, room_id)
                if room:
                    total_capacity = room.get('total_capacity', 2)
                    current_guests = room.get('current_guests', 0)
                    new_total = current_guests + guests
                    
                    if new_total > total_capacity:
                        await query.answer(get_text('capacity_exceeded', lang).format(capacity=total_capacity, current=current_guests, additional=guests), show_alert=True)
                        return
                    
                    if update_room_guests(self.db, room_id, new_total):
                        await query.answer(get_text('guests_checked_in_success', lang).format(guests=guests), show_alert=True)
                        
                        # Refresh employee room view directly
                        await self._show_emp_room_detail(query, room_id)
                    else:
                        await query.answer(get_text('guests_checkin_error', lang), show_alert=True)
                else:
                    await query.answer(get_text('room_not_found', lang), show_alert=True)
            
            elif query.data.startswith("emp_room_checkin_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("emp_room_checkin_", ""))
                room = get_room_by_id(self.db, room_id)
                
                if room:
                    total_capacity = room.get('total_capacity', 2)
                    current_guests = room.get('current_guests', 0)
                    available = total_capacity - current_guests
                    
                    if available <= 0:
                        await query.answer("⚠️ Soba je popunjena!", show_alert=True)
                        return
                    
                    text = f"""➕ Prijava gostiju - Soba {room['id_room']}

📊 Trenutno stanje:
• Kapacitet: {total_capacity}
• Prijavljeno: {current_guests}
• Slobodno: {available}

Koliko gostiju želite da prijavite?"""
                    
                    keyboard = []
                    row = []
                    for i in range(1, min(available + 1, 11)):
                        row.append(InlineKeyboardButton(f"{i}", callback_data=f"emp_room_checkin_set_{room_id}_{i}"))
                        if len(row) == 5:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data=f"emp_room_{room_id}")])
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("Soba nije pronađena.", show_alert=True)
            
            # Employee Room Check-out
            elif query.data.startswith("emp_room_checkout_set_"):
                from database import update_room_guests, get_room_by_id
                
                parts = query.data.replace("emp_room_checkout_set_", "").split("_")
                room_id = int(parts[0])
                guests = int(parts[1])
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_room_by_id(self.db, room_id)
                if room:
                    current_guests = room.get('current_guests', 0)
                    new_total = max(0, current_guests - guests)
                    
                    if update_room_guests(self.db, room_id, new_total):
                        await query.answer(get_text('guests_checked_out_success', lang).format(guests=guests), show_alert=True)
                        
                        # Refresh employee room view directly
                        await self._show_emp_room_detail(query, room_id)
                    else:
                        await query.answer(get_text('guests_checkout_error', lang), show_alert=True)
                else:
                    await query.answer(get_text('room_not_found', lang), show_alert=True)
            
            elif query.data.startswith("emp_room_checkout_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("emp_room_checkout_", ""))
                room = get_room_by_id(self.db, room_id)
                
                if room:
                    current_guests = room.get('current_guests', 0)
                    
                    if current_guests <= 0:
                        await query.answer("⚠️ Nema gostiju za odjavu!", show_alert=True)
                        return
                    
                    text = f"""➖ Odjava gostiju - Soba {room['id_room']}

📊 Trenutno stanje:
• Prijavljeno: {current_guests}

Koliko gostiju želite da odjavite?"""
                    
                    keyboard = []
                    row = []
                    for i in range(1, current_guests + 1):
                        row.append(InlineKeyboardButton(f"{i}", callback_data=f"emp_room_checkout_set_{room_id}_{i}"))
                        if len(row) == 5:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data=f"emp_room_{room_id}")])
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("Soba nije pronađena.", show_alert=True)
            
            # Employee Room Capacity
            elif query.data.startswith("emp_room_capacity_set_"):
                from database import update_room_capacity, get_room_by_id
                
                parts = query.data.replace("emp_room_capacity_set_", "").split("_")
                room_id = int(parts[0])
                new_capacity = int(parts[1])
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_room_by_id(self.db, room_id)
                if room:
                    current_guests = room.get('current_guests', 0)
                    
                    if new_capacity < current_guests:
                        await query.answer(get_text('capacity_below_guests', lang).format(current=current_guests), show_alert=True)
                        return
                    
                    if update_room_capacity(self.db, room_id, new_capacity):
                        await query.answer(get_text('capacity_updated', lang).format(capacity=new_capacity), show_alert=True)
                        
                        # Refresh employee room view directly
                        await self._show_emp_room_detail(query, room_id)
                    else:
                        await query.answer(get_text('capacity_set_error', lang), show_alert=True)
                else:
                    await query.answer(get_text('room_not_found', lang), show_alert=True)
            
            elif query.data.startswith("emp_room_capacity_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("emp_room_capacity_", ""))
                room = get_room_by_id(self.db, room_id)
                
                if room:
                    current_capacity = room.get('total_capacity', 2)
                    current_guests = room.get('current_guests', 0)
                    
                    text = f"""👥 Podešavanje kapaciteta - Soba {room['id_room']}

📊 Trenutno stanje:
• Kapacitet: {current_capacity}
• Prijavljeno: {current_guests}

Izaberite novi kapacitet (1-20):"""
                    
                    keyboard = []
                    row = []
                    # Create buttons for 1-20 capacity, 5 buttons per row
                    for i in range(1, 21):
                        # Mark current capacity
                        label = f"✓ {i}" if i == current_capacity else str(i)
                        # Disable if less than current guests
                        if i < current_guests:
                            label = f"✗ {i}"
                        row.append(InlineKeyboardButton(label, callback_data=f"emp_room_capacity_set_{room_id}_{i}"))
                        if len(row) == 5:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data=f"emp_room_{room_id}")])
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("Soba nije pronađena.", show_alert=True)
            
            # ========== HOTEL ROOMS MANAGEMENT ==========
            # Hotel room detail view (MOVED TO ADMIN)
            # This feature is now only available in admin panel (admin_hotel_room_*)
            # elif query.data.startswith("hotel_room_") and not query.data.endswith("_add") ...
            
            # Reception - Rooms Management (MOVED TO ADMIN)
            # This feature is now only available in admin panel
            # elif query.data == "reception_rooms":
            #     ... (commented out - use admin_hotel_rooms instead)
            
            # Reception - Keys Management
            elif query.data == "reception_keys":
                from database import get_active_rooms_for_keys, get_open_key_records
                lang = get_user_language(query.from_user.id, self.db)
                
                active_rooms = get_active_rooms_for_keys(self.db)
                open_records = get_open_key_records(self.db)
                
                text = f"🔑 {get_text('key_management', lang)}\n\n"
                text += f"{get_text('active_rooms', lang)}: {len(active_rooms)}\n"
                text += f"{get_text('currently_open', lang)}: {len(open_records)}\n\n"
                
                if open_records:
                    text += f"{get_text('open_records', lang)}\n"
                    for record in open_records[:5]:
                        rec_id, room_name, person_name, purpose, taken_at, status, _room_id = record
                        text += f"• {room_name} - {person_name}\n"
                    if len(open_records) > 5:
                        text += f"... {get_text('and_more', lang)} {len(open_records) - 5}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"{get_text('take_key', lang)}", callback_data="key_take")],
                    [InlineKeyboardButton(f"{get_text('return_key', lang)}", callback_data="key_return")],
                    [InlineKeyboardButton(f"{get_text('key_history', lang)}", callback_data="key_history")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_reception")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Key - Take (select room)
            elif query.data == "key_take":
                from database import get_active_rooms_for_keys, get_borrowed_room_ids
                lang = get_user_language(query.from_user.id, self.db)
                rooms = get_active_rooms_for_keys(self.db)
                borrowed_ids = get_borrowed_room_ids(self.db)
                
                if not rooms:
                    await query.answer(f"❌ {get_text('no_active_rooms', lang)}", show_alert=True)
                    return
                
                # Handle both dict and tuple formats
                def get_room_id(room):
                    return room['id'] if isinstance(room, dict) else room[0]
                def get_room_name(room):
                    return room['name'] if isinstance(room, dict) else room[1]
                
                available_count = len([r for r in rooms if get_room_id(r) not in borrowed_ids])
                borrowed_count = len([r for r in rooms if get_room_id(r) in borrowed_ids])
                
                text = f"{get_text('select_room_for_key', lang)}\n\n"
                text += f"{get_text('available', lang)}: {available_count} | {get_text('occupied', lang)}: {borrowed_count}"
                
                keyboard = []
                row = []
                for room in rooms:
                    room_id = get_room_id(room)
                    name = get_room_name(room)
                    
                    if room_id in borrowed_ids:
                        # Room key is borrowed - show as unavailable
                        row.append(InlineKeyboardButton(
                            f"🔒 {name}",
                            callback_data=f"key_borrowed_{room_id}"
                        ))
                    else:
                        # Room key is available
                        row.append(InlineKeyboardButton(
                            f"🔑 {name}",
                            callback_data=f"key_select_{room_id}"
                        ))
                    
                    if len(row) == 3:
                        keyboard.append(row)
                        row = []
                
                if row:  # Add remaining buttons
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_keys")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)

            
            # Key - Already borrowed message
            elif query.data.startswith("key_borrowed_"):
                room_id = int(query.data.replace("key_borrowed_", ""))
                from database import get_hotel_room_by_id, get_open_key_records
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_hotel_room_by_id(self.db, room_id)
                open_records = get_open_key_records(self.db)
                
                # Find who borrowed this key
                borrower_info = None
                for record in open_records:
                    rec_id, room_name_r, person_name, purpose, taken_at, status, rec_room_id = record
                    if rec_room_id == room_id:
                        borrower_info = {'person_name': person_name, 'purpose': purpose}
                        break
                
                if borrower_info:
                    await query.answer(
                        f"🔒 {get_text('key_already_taken', lang)}\n👤 {borrower_info['person_name']}\n📋 {borrower_info['purpose']}",
                        show_alert=True
                    )
                else:
                    await query.answer(f"🔒 {get_text('key_already_taken', lang)}", show_alert=True)
            
            # Key - Select room for taking
            elif query.data.startswith("key_select_"):
                room_id = int(query.data.replace("key_select_", ""))
                from database import get_hotel_room_by_id, get_borrowed_room_ids
                lang = get_user_language(query.from_user.id, self.db)
                
                # Double-check if key is still available
                borrowed_ids = get_borrowed_room_ids(self.db)
                if room_id in borrowed_ids:
                    await query.answer(f"❌ {get_text('key_just_taken', lang)}", show_alert=True)
                    # Refresh the key list
                    await self._show_key_take_list(query)
                    return
                
                room = get_hotel_room_by_id(self.db, room_id)
                if not room:
                    await query.answer(f"❌ {get_text('room_not_found', lang)}", show_alert=True)
                    return
                
                text = f"🔑 {get_text('taking_key', lang)}\n\n"
                text += f"{get_text('room', lang)}: {room['name']}\n"
                text += f"📋 {room['description'] or get_text('no_description', lang)}\n\n"
                text += f"❓ {get_text('want_to_take_key', lang)}\n\n"
                text += f"{get_text('after_confirm_enter', lang)}\n"
                text += f"• {get_text('person_name_label', lang)}\n"
                text += f"• {get_text('usage_purpose_label', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(f"✅ {get_text('confirm', lang)}", callback_data=f"key_confirm_{room_id}")],
                    [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="key_take")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
# Key - Confirm taking - show department selection
            elif query.data.startswith("key_confirm_"):
                room_id = int(query.data.replace("key_confirm_", ""))
                from database import get_hotel_room_by_id
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_hotel_room_by_id(self.db, room_id)
                if not room:
                    await query.answer(f"❌ {get_text('room_not_found', lang)}", show_alert=True)
                    return
                
                # Store room info
                context.user_data['key_taking_room_id'] = room_id
                context.user_data['key_taking_room_name'] = room['name']
                
                # Get all employees to find which departments have staff
                employees = self.db.get_all_employees()
                
                if not employees:
                    await query.answer(f"❌ {get_text('no_registered_employees', lang)}", show_alert=True)
                    return
                
                # Count employees per department
                dept_counts = {}
                for emp in employees:
                    dept = emp[3] if len(emp) > 3 else "Unknown"
                    dept_counts[dept] = dept_counts.get(dept, 0) + 1
                
                text = f"🔑 {get_text('taking_key_for', lang)}: {room['name']}\n\n"
                text += f"🏢 {get_text('select_department', lang)}\n"
                text += f"📊 {get_text('total', lang)}: {len(employees)} {get_text('employee', lang)}"
                
                # Build department buttons (2 per row)
                keyboard = []
                row = []
                for dept_name in DEPT_EMOJIS:
                    if dept_name in dept_counts:
                        emoji = DEPT_EMOJIS[dept_name]
                        dept_display = get_dept_display(dept_name, lang)
                        count = dept_counts[dept_name]
                        row.append(InlineKeyboardButton(
                            f"{emoji} {dept_display} ({count})",
                            callback_data=f"key_dept_{room_id}_{dept_name}"
                        ))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="key_take")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Key - Department selected, show employees in that department
            elif query.data.startswith("key_dept_"):
                parts = query.data.replace("key_dept_", "").split("_", 1)
                room_id = int(parts[0])
                dept_name = parts[1]
                
                from database import get_hotel_room_by_id
                lang = get_user_language(query.from_user.id, self.db)
                
                room = get_hotel_room_by_id(self.db, room_id)
                if not room:
                    await query.answer(f"❌ {get_text('room_not_found', lang)}", show_alert=True)
                    return
                
                # Get employees in selected department
                dept_employees = self.db.get_employees_by_department(dept_name)
                
                if not dept_employees:
                    await query.answer(f"❌ {get_text('no_registered_employees', lang)}", show_alert=True)
                    return
                
                dept_emoji = get_dept_emoji(dept_name)
                dept_display = get_dept_display(dept_name, lang)
                
                text = f"🔑 {get_text('taking_key_for', lang)}: {room['name']}\n\n"
                text += f"{dept_emoji} {dept_display}\n"
                text += f"👤 {get_text('select_employee_taking_key', lang)}\n"
                text += f"📊 {get_text('total', lang)}: {len(dept_employees)} {get_text('employee', lang)}"
                
                # Build keyboard with 3 employees per row
                keyboard = []
                row = []
                for emp in dept_employees:
                    emp_id = emp[0]
                    emp_name = emp[2]
                    row.append(InlineKeyboardButton(
                        f"👤 {emp_name}",
                        callback_data=f"key_emp_{room_id}_{emp_id}"
                    ))
                    if len(row) == 3:
                        keyboard.append(row)
                        row = []
                
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data=f"key_confirm_{room_id}")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Key - Employee selected, ask for purpose
            elif query.data.startswith("key_emp_"):
                parts = query.data.replace("key_emp_", "").split("_")
                room_id = int(parts[0])
                emp_id = parts[1]  # employee_id is TEXT like 'EMP00001'
                
                from database import get_hotel_room_by_id
                lang = get_user_language(query.from_user.id, self.db)
                room = get_hotel_room_by_id(self.db, room_id)
                
                # Get employee info
                emp_info = self.db.execute_query(
                    "SELECT employee_id, telegram_user_id, name, department FROM tbl_employeer WHERE employee_id = %s",
                    (emp_id,)
                )
                
                if not emp_info or len(emp_info) == 0:
                    await query.answer(f"❌ {get_text('employee_not_found', lang)}", show_alert=True)
                    return
                
                emp = emp_info[0]
                emp_telegram_id = emp[1]
                emp_name = emp[2]
                emp_department = emp[3]
                
                # Store for purpose input
                context.user_data['key_taking_room_id'] = room_id
                context.user_data['key_taking_room_name'] = room['name'] if room else "Unknown"
                context.user_data['key_taking_emp_id'] = emp_id
                context.user_data['key_taking_emp_name'] = emp_name
                context.user_data['key_taking_emp_telegram_id'] = emp_telegram_id
                context.user_data['key_taking_emp_department'] = emp_department
                context.user_data['awaiting_key_purpose'] = True
                
                dept_emoji = get_dept_emoji(emp_department)
                dept_display = get_dept_display(emp_department, lang)
                
                await query.edit_message_text(
                    f"🔑 {get_text('taking_key_for', lang)}: {room['name'] if room else 'Unknown'}\n\n"
                    f"👤 {get_text('employee', lang)}: {emp_name}\n"
                    f"{dept_emoji} {get_text('department', lang)}: {dept_display}\n\n"
                    f"📝 {get_text('enter_purpose', lang)}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data=f"key_dept_{room_id}_{emp_department}")
                    ]])
                )


            # Key - Skip proof (create record without proof)
            elif query.data == "key_skip_proof":
                from database import create_key_record
                lang = get_user_language(query.from_user.id, self.db)
                
                room_id = context.user_data.get('key_taking_room_id')
                room_name = context.user_data.get('key_taking_room_name')
                purpose = context.user_data.get('key_purpose')
                
                # Use selected employee info (from key_emp_ selection)
                emp_name = context.user_data.get('key_taking_emp_name')
                emp_telegram_id = context.user_data.get('key_taking_emp_telegram_id')
                emp_department = context.user_data.get('key_taking_emp_department')
                
                if not emp_name:
                    # Fallback to receptionist info if no employee selected
                    telegram_user_id = query.from_user.id
                    emp_info = self.db.get_employee_info(telegram_user_id)
                    if emp_info:
                        emp_name = emp_info['name']
                        emp_telegram_id = telegram_user_id
                        emp_department = emp_info.get('department', 'Unknown')
                    else:
                        emp_name = query.from_user.first_name or "Unknown"
                        emp_telegram_id = telegram_user_id
                        emp_department = "Unknown"
                
                record_id = create_key_record(
                    self.db, room_id, room_name, emp_name,
                    emp_telegram_id, purpose,
                    taken_photo=None, taken_video=None,
                    created_by=query.from_user.id
                )
                
                if record_id:
                    from datetime import datetime
                    now = datetime.now()
                    
                    dept_emoji = get_dept_emoji(emp_department)
                    dept_display = get_dept_display(emp_department)
                    
                    await query.answer(f"✅ {get_text('key_taken_success', lang)}", show_alert=True)
                    
                    text = f"✅ {get_text('key_taken', lang)}\n\n"
                    text += f"{get_text('room', lang)}: {room_name}\n"
                    text += f"{get_text('person', lang)}: {emp_name}\n"
                    text += f"{dept_emoji} {get_text('department', lang)}: {dept_display}\n"
                    text += f"{get_text('purpose', lang)}: {purpose}\n"
                    text += f"{get_text('proof', lang)}: {get_text('not_attached', lang)}\n"
                    text += f"{get_text('time', lang)}: {now.strftime('%d.%m.%Y %H:%M')}\n\n"
                    text += f"{get_text('remember_return', lang)}"
                    
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('key_management', lang)}", callback_data="reception_keys")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(f"❌ {get_text('error_creating_record', lang)}", show_alert=True)
                
                # Clean up context
                context.user_data.pop('key_taking_room_id', None)
                context.user_data.pop('key_taking_room_name', None)
                context.user_data.pop('key_purpose', None)
                context.user_data.pop('awaiting_key_proof', None)
                context.user_data.pop('key_taking_emp_id', None)
                context.user_data.pop('key_taking_emp_name', None)
                context.user_data.pop('key_taking_emp_telegram_id', None)
                context.user_data.pop('key_taking_emp_department', None)

            # Key - Return (select open record)
            elif query.data == "key_return":
                from database import get_open_key_records
                lang = get_user_language(query.from_user.id, self.db)
                records = get_open_key_records(self.db)
                
                if not records:
                    await query.answer(f"✅ {get_text('no_open_records', lang)}", show_alert=True)
                    return
                
                text = f"↩️ {get_text('select_record_for_return', lang)}\n\n"
                
                keyboard = []
                for rec_id, room_name, person_name, purpose, taken_at, status, _room_id in records:
                    from datetime import datetime
                    # Handle both datetime object and string
                    if isinstance(taken_at, datetime):
                        taken = taken_at
                    else:
                        taken = datetime.fromisoformat(taken_at)
                    time_str = taken.strftime("%d.%m %H:%M")
                    keyboard.append([InlineKeyboardButton(
                        f"🏢 {room_name} | {person_name} ({time_str})",
                        callback_data=f"key_return_select_{rec_id}"
                    )])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_keys")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Key - Select record for return
            elif query.data.startswith("key_return_select_"):
                lang = get_user_language(query.from_user.id, self.db)
                record_id = int(query.data.replace("key_return_select_", ""))
                from database import get_key_record_by_id
                
                record = get_key_record_by_id(self.db, record_id)
                if not record:
                    await query.answer(f"❌ {get_text('record_not_found', lang)}", show_alert=True)
                    return
                
                from datetime import datetime
                # Handle both datetime object and string
                if isinstance(record['taken_at'], datetime):
                    taken = record['taken_at']
                else:
                    taken = datetime.fromisoformat(record['taken_at'])
                
                text = f"↩️ {get_text('returning_key', lang)}\n\n"
                text += f"{get_text('room', lang)}: {record['room_name']}\n"
                text += f"{get_text('person', lang)}: {record['person_name']}\n"
                text += f"{get_text('purpose', lang)}: {record['purpose']}\n"
                text += f"{get_text('time', lang)}: {taken.strftime('%d.%m.%Y %H:%M')}\n\n"
                text += f"❓ {get_text('confirm_key_return', lang)}\n\n"
                text += f"📸 {get_text('can_add_proof_or_skip', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(f"📸 {get_text('add_proof', lang)}", callback_data=f"key_return_proof_{record_id}")],
                    [InlineKeyboardButton(f"⏭️ {get_text('skip_proof', lang)}", callback_data=f"key_return_skip_{record_id}")],
                    [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="key_return")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Key - Return with proof (ask for media)
            elif query.data.startswith("key_return_proof_"):
                lang = get_user_language(query.from_user.id, self.db)
                record_id = int(query.data.replace("key_return_proof_", ""))
                
                context.user_data['key_returning_record_id'] = record_id
                context.user_data['awaiting_key_return_proof'] = True
                
                await query.edit_message_text(
                    f"📸 {get_text('send_key_proof', lang)}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="key_return")
                    ]])
                )
            
            # Key - Return without proof (skip)
            elif query.data.startswith("key_return_skip_"):
                lang = get_user_language(query.from_user.id, self.db)
                record_id = int(query.data.replace("key_return_skip_", ""))
                from database import return_key
                
                success = return_key(self.db, record_id, None, None)
                
                if success:
                    await query.answer(f"✅ {get_text('key_returned_success', lang)}", show_alert=True)
                    # Return to reception keys menu
                    from database import get_active_rooms_for_keys, get_open_key_records
                    
                    active_rooms = get_active_rooms_for_keys(self.db)
                    open_records = get_open_key_records(self.db)
                    
                    text = f"{get_text('key_management', lang)}\n\n"
                    text += f"{get_text('active_rooms', lang)}: {len(active_rooms)}\n"
                    text += f"{get_text('currently_open', lang)}: {len(open_records)}\n\n"
                    
                    if open_records:
                        text += f"{get_text('open_records', lang)}\n"
                        for record in open_records[:5]:
                            rec_id, room_name, person_name, purpose, taken_at, status, _room_id = record
                            text += f"• {room_name} - {person_name}\n"
                        if len(open_records) > 5:
                            text += f"... {get_text('and_more', lang)} {len(open_records) - 5}\n"
                    
                    keyboard = [
                        [InlineKeyboardButton(f"{get_text('take_key', lang)}", callback_data="key_take")],
                        [InlineKeyboardButton(f"{get_text('return_key', lang)}", callback_data="key_return")],
                        [InlineKeyboardButton(f"{get_text('key_history', lang)}", callback_data="key_history")],
                        [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_reception")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(f"❌ {get_text('error_returning_key', lang)}", show_alert=True)
            
            # Key - Confirm return (legacy - redirect to skip)
            elif query.data.startswith("key_return_confirm_"):
                lang = get_user_language(query.from_user.id, self.db)
                record_id = int(query.data.replace("key_return_confirm_", ""))
                from database import return_key
                
                success = return_key(self.db, record_id)
                
                if success:
                    await query.answer(f"✅ {get_text('key_returned_success', lang)}", show_alert=True)
                    # Return to reception keys menu
                    from database import get_active_rooms_for_keys, get_open_key_records
                    
                    active_rooms = get_active_rooms_for_keys(self.db)
                    open_records = get_open_key_records(self.db)
                    
                    text = f"{get_text('key_management', lang)}\n\n"
                    text += f"{get_text('active_rooms', lang)}: {len(active_rooms)}\n"
                    text += f"{get_text('currently_open', lang)}: {len(open_records)}\n\n"
                    
                    if open_records:
                        text += f"{get_text('open_records', lang)}\n"
                        for record in open_records[:5]:
                            rec_id, room_name, person_name, purpose, taken_at, status, _room_id = record
                            text += f"• {room_name} - {person_name}\n"
                        if len(open_records) > 5:
                            text += f"... {get_text('and_more', lang)} {len(open_records) - 5}\n"
                    
                    keyboard = [
                        [InlineKeyboardButton(f"{get_text('take_key', lang)}", callback_data="key_take")],
                        [InlineKeyboardButton(f"{get_text('return_key', lang)}", callback_data="key_return")],
                        [InlineKeyboardButton(f"{get_text('key_history', lang)}", callback_data="key_history")],
                        [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_reception")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(f"❌ {get_text('error_returning_key', lang)}", show_alert=True)
            
            # Key - History
            elif query.data == "key_history":
                from database import get_all_key_history
                lang = get_user_language(query.from_user.id, self.db)
                records = get_all_key_history(self.db, limit=20)
                
                text = f"📜 {get_text('key_history_last20', lang)}\n\n"
                
                if records:
                    for rec_id, room_name, person_name, purpose, taken_at, returned_at, status in records:
                        from datetime import datetime
                        # Handle both datetime object and string
                        if isinstance(taken_at, datetime):
                            taken = taken_at
                        else:
                            taken = datetime.fromisoformat(taken_at)
                        
                        status_icon = "🔓" if status == "Opened" else "✅" if status == "Returned" else "⚠️"
                        text += f"{status_icon} {room_name}\n"
                        text += f"   👤 {person_name}\n"
                        text += f"   🕐 {taken.strftime('%d.%m %H:%M')}"
                        
                        if returned_at:
                            if isinstance(returned_at, datetime):
                                ret = returned_at
                            else:
                                ret = datetime.fromisoformat(returned_at)
                            text += f" → {ret.strftime('%d.%m %H:%M')}"
                        
                        text += f" | {status}\n\n"
                else:
                    text += get_text('no_records', lang)
                
                keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_keys")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ==================== TOOL MANAGEMENT ====================
            
            # Tool management main menu
            elif query.data == "reception_tools":
                from database import get_all_tools, get_open_tool_records
                lang = get_user_language(query.from_user.id, self.db)
                
                tools = get_all_tools(self.db)
                open_records = get_open_tool_records(self.db)
                
                # Calculate total and available
                total_tools = sum(t['total_quantity'] for t in tools)
                available_tools = sum(t['available_quantity'] for t in tools)
                borrowed = total_tools - available_tools
                
                text = f"🔧 {get_text('tool_management', lang)}\n\n"
                text += f"📊 {get_text('total_types', lang)}: {len(tools)}\n"
                text += f"📦 {get_text('total_items', lang)}: {total_tools}\n"
                text += f"✅ {get_text('available', lang)}: {available_tools} | 🔓 {get_text('borrowed', lang)}: {borrowed}\n\n"
                
                if open_records:
                    text += f"⚠️ {get_text('currently_borrowed', lang)}:\n"
                    for rec in open_records[:5]:
                        text += f"• {rec['tool_name']} x{rec['quantity']} - {rec['person_name']}\n"
                    if len(open_records) > 5:
                        text += f"... {get_text('and_more', lang)} {len(open_records) - 5}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"➕ {get_text('add_tool', lang)}", callback_data="tool_add")],
                    [InlineKeyboardButton(f"📋 {get_text('tool_list', lang)}", callback_data="tool_list")],
                    [InlineKeyboardButton(f"🔧 {get_text('borrow_tool', lang)}", callback_data="tool_borrow")],
                    [InlineKeyboardButton(f"↩️ {get_text('return_tool', lang)}", callback_data="tool_return")],
                    [InlineKeyboardButton(f"📜 {get_text('history', lang)}", callback_data="tool_history")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_reception")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Tool - Add new tool (ask for name)
            elif query.data == "tool_add":
                lang = get_user_language(query.from_user.id, self.db)
                context.user_data['awaiting_tool_name'] = True
                await query.edit_message_text(
                    f"🔧 {get_text('add_new_tool', lang)}\n\n📝 {get_text('enter_tool_name', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="reception_tools")
                    ]])
                )
            
            # Tool - List all tools
            elif query.data == "tool_list":
                from database import get_all_tools
                lang = get_user_language(query.from_user.id, self.db)
                tools = get_all_tools(self.db)
                
                if not tools:
                    text = f"🔧 {get_text('tool_list', lang)}\n\n{get_text('no_tools_registered', lang)}"
                else:
                    # Create table format
                    text = f"🔧 {get_text('tool_list', lang)}\n\n"
                    text += "```\n"
                    text += f"{'ID':<3} {'Name':<12} {'Desc':<10} {'Qty':<5} {'Avail':<5}\n"
                    text += "─" * 38 + "\n"
                    for tool in tools:
                        name = (tool['name'][:10] + '..') if len(tool['name']) > 12 else tool['name']
                        desc = tool['description'] or '-'
                        desc = (desc[:8] + '..') if len(desc) > 10 else desc
                        text += f"{tool['id']:<3} {name:<12} {desc:<10} {tool['total_quantity']:<5} {tool['available_quantity']:<5}\n"
                    text += "```"
                
                keyboard = []
                # Show tools 2 per row
                row = []
                for tool in tools:
                    avail = tool['available_quantity']
                    total = tool['total_quantity']
                    row.append(InlineKeyboardButton(
                        f"🔧 {tool['name']} ({avail}/{total})",
                        callback_data=f"tool_detail_{tool['id']}"
                    ))
                    if len(row) == 2:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="reception_tools")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode="Markdown")
            
            # Tool - Detail view
            elif query.data.startswith("tool_detail_"):
                lang = get_user_language(query.from_user.id, self.db)
                tool_id = int(query.data.replace("tool_detail_", ""))
                from database import get_tool_by_id
                
                tool = get_tool_by_id(self.db, tool_id)
                if not tool:
                    await query.answer(f"❌ {get_text('tool_not_found', lang)}", show_alert=True)
                    return
                
                avail = tool['available_quantity']
                total = tool['total_quantity']
                borrowed = total - avail
                status = f"✅ {get_text('available', lang)}" if avail > 0 else f"❌ {get_text('unavailable', lang)}"
                
                text = f"🔧 {tool['name']}\n\n"
                text += f"📋 {get_text('tool_desc', lang)}: {tool['description'] or get_text('no_description', lang)}\n\n"
                text += f"📦 {get_text('total', lang)}: {total}\n"
                text += f"✅ {get_text('available', lang)}: {avail}\n"
                text += f"🔓 {get_text('borrowed', lang)}: {borrowed}\n"
                text += f"📊 {get_text('status', lang)}: {status}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"✏️ {get_text('edit_tool', lang)}", callback_data=f"tool_edit_{tool_id}"),
                     InlineKeyboardButton(f"🗑️ {get_text('delete_tool', lang)}", callback_data=f"tool_delete_{tool_id}")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="tool_list")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Tool - Edit (ask for new name)
            elif query.data.startswith("tool_edit_"):
                lang = get_user_language(query.from_user.id, self.db)
                tool_id = int(query.data.replace("tool_edit_", ""))
                from database import get_tool_by_id
                
                tool = get_tool_by_id(self.db, tool_id)
                if not tool:
                    await query.answer(f"❌ {get_text('tool_not_found', lang)}", show_alert=True)
                    return
                
                context.user_data['editing_tool_id'] = tool_id
                context.user_data['awaiting_tool_edit_name'] = True
                
                await query.edit_message_text(
                    f"✏️ {get_text('edit_tool', lang)}: {tool['name']}\n\n"
                    f"{get_text('current_name', lang)}: {tool['name']}\n"
                    f"{get_text('current_description', lang)}: {tool['description'] or get_text('none', lang)}\n"
                    f"{get_text('current_quantity', lang)}: {tool['total_quantity']}\n\n"
                    f"📝 {get_text('enter_new_name', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data=f"tool_detail_{tool_id}")
                    ]])
                )
            
            # Tool - Delete confirmation
            elif query.data.startswith("tool_delete_"):
                lang = get_user_language(query.from_user.id, self.db)
                tool_id = int(query.data.replace("tool_delete_", ""))
                from database import get_tool_by_id
                
                tool = get_tool_by_id(self.db, tool_id)
                if not tool:
                    await query.answer(f"❌ {get_text('tool_not_found', lang)}", show_alert=True)
                    return
                
                text = f"🗑️ {get_text('delete_tool', lang)}\n\n"
                text += f"🔧 {tool['name']}\n"
                text += f"📋 {tool['description'] or get_text('no_description', lang)}\n\n"
                text += f"⚠️ {get_text('are_you_sure', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(f"✅ {get_text('yes_delete', lang)}", callback_data=f"tool_delete_confirm_{tool_id}")],
                    [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data=f"tool_detail_{tool_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Tool - Delete confirm
            elif query.data.startswith("tool_delete_confirm_"):
                lang = get_user_language(query.from_user.id, self.db)
                tool_id = int(query.data.replace("tool_delete_confirm_", ""))
                from database import delete_tool, get_all_tools
                
                if delete_tool(self.db, tool_id):
                    await query.answer(f"✅ {get_text('tool_deleted', lang)}", show_alert=True)
                    
                    # Show tool list
                    tools = get_all_tools(self.db)
                    
                    if not tools:
                        text = f"🔧 {get_text('tool_list', lang)}\n\n{get_text('no_tools_registered', lang)}"
                    else:
                        text = f"🔧 {get_text('tool_list', lang)}\n\n"
                        for tool in tools:
                            avail = tool['available_quantity']
                            total = tool['total_quantity']
                            status_icon = "✅" if avail > 0 else "❌"
                            text += f"{status_icon} {tool['name']}: {avail}/{total}\n"
                    
                    keyboard = []
                    row = []
                    for tool in tools:
                        avail = tool['available_quantity']
                        total = tool['total_quantity']
                        row.append(InlineKeyboardButton(
                            f"🔧 {tool['name']} ({avail}/{total})",
                            callback_data=f"tool_detail_{tool['id']}"
                        ))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_tools")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(f"❌ {get_text('delete_error', lang)}", show_alert=True)
            
            # Tool - Borrow (select tool)
            elif query.data == "tool_borrow":
                from database import get_all_tools
                lang = get_user_language(query.from_user.id, self.db)
                tools = get_all_tools(self.db)
                
                # Filter available tools
                available_tools = [t for t in tools if t['available_quantity'] > 0]
                unavailable_tools = [t for t in tools if t['available_quantity'] == 0]
                
                if not tools:
                    await query.answer(f"❌ {get_text('no_tools_registered', lang)}", show_alert=True)
                    return
                
                text = f"🔧 {get_text('borrowing_tool', lang)}\n\n"
                text += f"✅ {get_text('available', lang)}: {len(available_tools)} | ❌ {get_text('unavailable', lang)}: {len(unavailable_tools)}\n"
                text += f"{get_text('select_tool', lang)}:"
                
                keyboard = []
                row = []
                for tool in tools:
                    avail = tool['available_quantity']
                    total = tool['total_quantity']
                    if avail > 0:
                        row.append(InlineKeyboardButton(
                            f"✅ {tool['name']} ({avail}/{total})",
                            callback_data=f"tool_borrow_select_{tool['id']}"
                        ))
                    else:
                        row.append(InlineKeyboardButton(
                            f"❌ {tool['name']} (0/{total})",
                            callback_data=f"tool_unavailable_{tool['id']}"
                        ))
                    if len(row) == 2:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_tools")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Tool - Unavailable message
            elif query.data.startswith("tool_unavailable_"):
                lang = get_user_language(query.from_user.id, self.db)
                tool_id = int(query.data.replace("tool_unavailable_", ""))
                from database import get_tool_by_id, get_open_tool_records
                
                tool = get_tool_by_id(self.db, tool_id)
                records = get_open_tool_records(self.db)
                
                # Find who borrowed this tool
                borrowers = [r for r in records if r['tool_id'] == tool_id]
                
                if borrowers:
                    msg = f"❌ {tool['name']} - {get_text('all_borrowed', lang)}\n"
                    for b in borrowers[:3]:
                        msg += f"👤 {b['person_name']} x{b['quantity']}\n"
                    await query.answer(msg, show_alert=True)
                else:
                    await query.answer(f"❌ {get_text('tool_not_available', lang)}", show_alert=True)
            
            # Tool - Select tool to borrow (ask quantity)
            elif query.data.startswith("tool_borrow_select_"):
                tool_id = int(query.data.replace("tool_borrow_select_", ""))
                from database import get_tool_by_id
                lang = get_user_language(query.from_user.id, self.db)
                
                tool = get_tool_by_id(self.db, tool_id)
                if not tool or tool['available_quantity'] == 0:
                    await query.answer(f"❌ {get_text('tool_not_available', lang)}", show_alert=True)
                    return
                
                context.user_data['tool_borrowing_id'] = tool_id
                context.user_data['tool_borrowing_name'] = tool['name']
                context.user_data['tool_borrowing_available'] = tool['available_quantity']
                
                avail = tool['available_quantity']
                
                text = f"🔧 {get_text('borrowing_tool', lang)}: {tool['name']}\n\n"
                text += f"📦 {get_text('available', lang)}: {avail}\n\n"
                text += f"{get_text('select_quantity', lang)}:"
                
                # Quantity buttons (1 to available, max 10 buttons)
                keyboard = []
                row = []
                max_qty = min(avail, 10)
                for qty in range(1, max_qty + 1):
                    row.append(InlineKeyboardButton(
                        str(qty), callback_data=f"tool_qty_{tool_id}_{qty}"
                    ))
                    if len(row) == 5:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="tool_borrow")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Tool - Quantity selected, show employee list
            elif query.data.startswith("tool_qty_"):
                parts = query.data.replace("tool_qty_", "").split("_")
                tool_id = int(parts[0])
                quantity = int(parts[1])
                lang = get_user_language(query.from_user.id, self.db)
                
                from database import get_tool_by_id
                tool = get_tool_by_id(self.db, tool_id)
                
                context.user_data['tool_borrowing_id'] = tool_id
                context.user_data['tool_borrowing_name'] = tool['name'] if tool else "Unknown"
                context.user_data['tool_borrowing_qty'] = quantity
                
                # Get employees for selection
                employees = self.db.get_all_employees()
                
                text = f"🔧 {get_text('borrowing_tool', lang)}: {tool['name'] if tool else 'Unknown'}\n"
                text += f"📦 {get_text('quantity', lang)}: {quantity}\n\n"
                text += f"👤 {get_text('select_employee', lang)}:\n"
                text += f"📊 {get_text('total', lang)}: {len(employees)} {get_text('employee', lang)}"
                
                # Build keyboard with 3 employees per row
                keyboard = []
                row = []
                for emp in employees:
                    emp_id, telegram_id, name, department = emp
                    dept_emoji = get_dept_emoji(department)
                    row.append(InlineKeyboardButton(
                        f"{dept_emoji} {name}",
                        callback_data=f"tool_emp_{tool_id}_{quantity}_{emp_id}"
                    ))
                    if len(row) == 3:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="tool_borrow")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Tool - Employee selected, ask for purpose
            elif query.data.startswith("tool_emp_"):
                parts = query.data.replace("tool_emp_", "").split("_")
                tool_id = int(parts[0])
                quantity = int(parts[1])
                emp_id = parts[2]
                lang = get_user_language(query.from_user.id, self.db)
                
                from database import get_tool_by_id
                tool = get_tool_by_id(self.db, tool_id)
                
                # Get employee info
                emp_info = self.db.execute_query(
                    "SELECT employee_id, telegram_user_id, name, department FROM tbl_employeer WHERE employee_id = %s",
                    (emp_id,)
                )
                
                if not emp_info or len(emp_info) == 0:
                    await query.answer(f"❌ {get_text('employee_not_found', lang)}", show_alert=True)
                    return
                
                emp = emp_info[0]
                emp_telegram_id = emp[1]
                emp_name = emp[2]
                emp_department = emp[3]
                
                context.user_data['tool_borrowing_id'] = tool_id
                context.user_data['tool_borrowing_name'] = tool['name'] if tool else "Unknown"
                context.user_data['tool_borrowing_qty'] = quantity
                context.user_data['tool_borrowing_emp_id'] = emp_id
                context.user_data['tool_borrowing_emp_name'] = emp_name
                context.user_data['tool_borrowing_emp_telegram_id'] = emp_telegram_id
                context.user_data['tool_borrowing_emp_department'] = emp_department
                context.user_data['awaiting_tool_purpose'] = True
                
                dept_emoji = get_dept_emoji(emp_department)
                dept_display = get_dept_display(emp_department)
                
                await query.edit_message_text(
                    f"🔧 {get_text('borrowing_tool', lang)}: {tool['name'] if tool else 'Unknown'}\n"
                    f"📦 {get_text('quantity', lang)}: {quantity}\n"
                    f"👤 {get_text('employee', lang)}: {emp_name}\n"
                    f"{dept_emoji} {get_text('department', lang)}: {dept_display}\n\n"
                    f"📝 {get_text('enter_purpose', lang)}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_tools")
                    ]])
                )
            
            # Tool - Skip proof (borrow without proof)
            elif query.data == "tool_skip_proof":
                from database import borrow_tool
                
                tool_id = context.user_data.get('tool_borrowing_id')
                tool_name = context.user_data.get('tool_borrowing_name')
                quantity = context.user_data.get('tool_borrowing_qty', 1)
                purpose = context.user_data.get('tool_purpose')
                emp_name = context.user_data.get('tool_borrowing_emp_name')
                emp_telegram_id = context.user_data.get('tool_borrowing_emp_telegram_id')
                emp_department = context.user_data.get('tool_borrowing_emp_department')
                
                record_id = borrow_tool(
                    self.db, tool_id, tool_name, quantity,
                    emp_name, emp_telegram_id, purpose,
                    taken_photo=None, taken_video=None,
                    created_by=query.from_user.id
                )
                
                if record_id:
                    from datetime import datetime
                    now = datetime.now()
                    
                    dept_emoji = get_dept_emoji(emp_department) if emp_department else "👤"
                    dept_display = get_dept_display(emp_department) if emp_department else ""
                    
                    await query.answer(f"✅ {get_text('tool_borrowed_success', lang)}", show_alert=True)
                    
                    text = f"✅ {get_text('tool_borrowed_success', lang)}\n\n"
                    text += f"🔧 {get_text('tool_name', lang)}: {tool_name}\n"
                    text += f"📦 {get_text('quantity', lang)}: {quantity}\n"
                    text += f"👤 {get_text('person', lang)}: {emp_name}\n"
                    text += f"{dept_emoji} {get_text('department', lang)}: {dept_display}\n"
                    text += f"📝 {get_text('purpose', lang)}: {purpose}\n"
                    text += f"📸 {get_text('proof', lang)}: {get_text('not_attached', lang)}\n"
                    text += f"🕐 {get_text('time', lang)}: {now.strftime('%d.%m.%Y %H:%M')}\n\n"
                    text += f"⚠️ {get_text('dont_forget_return', lang)}"
                    
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('tool_management', lang)}", callback_data="reception_tools")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(f"❌ {get_text('borrow_error', lang)}", show_alert=True)
                
                # Clean up context
                for key in list(context.user_data.keys()):
                    if key.startswith('tool_'):
                        context.user_data.pop(key, None)
                context.user_data.pop('awaiting_tool_proof', None)
            
            # Tool - Return (select record)
            elif query.data == "tool_return":
                lang = get_user_language(query.from_user.id, self.db)
                from database import get_open_tool_records
                records = get_open_tool_records(self.db)
                
                if not records:
                    await query.answer(f"✅ {get_text('no_open_records', lang)}", show_alert=True)
                    return
                
                text = f"↩️ {get_text('return_tool_title', lang)}\n\n{get_text('select_record', lang)}"
                
                keyboard = []
                for rec in records:
                    from datetime import datetime
                    # Handle both datetime object and string
                    if isinstance(rec['taken_at'], datetime):
                        taken = rec['taken_at']
                    else:
                        taken = datetime.fromisoformat(rec['taken_at'])
                    time_str = taken.strftime("%d.%m %H:%M")
                    keyboard.append([InlineKeyboardButton(
                        f"🔧 {rec['tool_name']} x{rec['quantity']} | {rec['person_name']} ({time_str})",
                        callback_data=f"tool_return_select_{rec['id']}"
                    )])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_tools")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Tool - Select record for return
            elif query.data.startswith("tool_return_select_"):
                lang = get_user_language(query.from_user.id, self.db)
                record_id = int(query.data.replace("tool_return_select_", ""))
                from database import get_tool_record_by_id
                
                record = get_tool_record_by_id(self.db, record_id)
                if not record:
                    await query.answer(f"❌ {get_text('record_not_found', lang)}", show_alert=True)
                    return
                
                from datetime import datetime
                # Handle both datetime object and string
                if isinstance(record['taken_at'], datetime):
                    taken = record['taken_at']
                else:
                    taken = datetime.fromisoformat(record['taken_at'])
                
                text = f"↩️ {get_text('return_tool_title', lang)}\n\n"
                text += f"🔧 {get_text('tool_name', lang)}: {record['tool_name']}\n"
                text += f"📦 {get_text('quantity', lang)}: {record['quantity']}\n"
                text += f"👤 {get_text('person', lang)}: {record['person_name']}\n"
                text += f"📝 {get_text('purpose', lang)}: {record['purpose']}\n"
                text += f"🕐 {get_text('taken_at', lang)}: {taken.strftime('%d.%m.%Y %H:%M')}\n\n"
                text += f"📸 {get_text('can_add_proof_or_skip', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(f"📸 {get_text('add_proof', lang)}", callback_data=f"tool_return_proof_{record_id}")],
                    [InlineKeyboardButton(f"⏭️ {get_text('skip_proof', lang)}", callback_data=f"tool_return_skip_{record_id}")],
                    [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="tool_return")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Tool - Return with proof
            elif query.data.startswith("tool_return_proof_"):
                lang = get_user_language(query.from_user.id, self.db)
                record_id = int(query.data.replace("tool_return_proof_", ""))
                
                context.user_data['tool_returning_record_id'] = record_id
                context.user_data['awaiting_tool_return_proof'] = True
                
                await query.edit_message_text(
                    f"📸 {get_text('send_proof_photo_video', lang)}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="tool_return")
                    ]])
                )
            
            # Tool - Return without proof
            elif query.data.startswith("tool_return_skip_"):
                lang = get_user_language(query.from_user.id, self.db)
                record_id = int(query.data.replace("tool_return_skip_", ""))
                from database import return_tool, get_tool_record_by_id
                
                record = get_tool_record_by_id(self.db, record_id)
                success = return_tool(self.db, record_id, None, None)
                
                if success:
                    await query.answer(f"✅ {get_text('tool_returned_success', lang)}", show_alert=True)
                    
                    from database import get_all_tools, get_open_tool_records
                    tools = get_all_tools(self.db)
                    open_records = get_open_tool_records(self.db)
                    
                    total_tools = sum(t['total_quantity'] for t in tools)
                    available_tools = sum(t['available_quantity'] for t in tools)
                    borrowed = total_tools - available_tools
                    
                    text = f"🔧 {get_text('tool_management', lang)}\n\n"
                    text += f"📊 {get_text('total_types', lang)}: {len(tools)}\n"
                    text += f"📦 {get_text('total_items', lang)}: {total_tools}\n"
                    text += f"✅ {get_text('available', lang)}: {available_tools} | 🔓 {get_text('borrowed', lang)}: {borrowed}\n\n"
                    
                    if open_records:
                        text += f"⚠️ {get_text('currently_borrowed', lang)}:\n"
                        for rec in open_records[:5]:
                            text += f"• {rec['tool_name']} x{rec['quantity']} - {rec['person_name']}\n"
                    
                    keyboard = [
                        [InlineKeyboardButton(f"➕ {get_text('add_tool', lang)}", callback_data="tool_add")],
                        [InlineKeyboardButton(f"📋 {get_text('tool_list', lang)}", callback_data="tool_list")],
                        [InlineKeyboardButton(f"🔧 {get_text('borrow_tool', lang)}", callback_data="tool_borrow")],
                        [InlineKeyboardButton(f"↩️ {get_text('return_tool', lang)}", callback_data="tool_return")],
                        [InlineKeyboardButton(f"📜 {get_text('history', lang)}", callback_data="tool_history")],
                        [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_reception")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(f"❌ {get_text('return_error', lang)}", show_alert=True)
            
            # Tool - History
            elif query.data == "tool_history":
                result = self.db.execute_query("""
                    SELECT id, tool_name, quantity, person_name, purpose, taken_at, returned_at, status
                    FROM tbl_tool_history 
                    ORDER BY taken_at DESC 
                    LIMIT 20
                """)
                
                text = f"📜 {get_text('tool_history_last20', lang)}\n\n"
                
                if result:
                    for row in result:
                        rec_id, tool_name, quantity, person_name, purpose, taken_at, returned_at, status = row
                        from datetime import datetime
                        # Handle both datetime object and string
                        if isinstance(taken_at, datetime):
                            taken = taken_at
                        else:
                            taken = datetime.fromisoformat(taken_at)
                        
                        status_icon = "🔓" if status == "Opened" else "✅" if status == "Returned" else "⚠️"
                        text += f"{status_icon} {tool_name} x{quantity}\n"
                        text += f"   👤 {person_name}\n"
                        text += f"   🕐 {taken.strftime('%d.%m %H:%M')}"
                        
                        if returned_at:
                            if isinstance(returned_at, datetime):
                                ret = returned_at
                            else:
                                ret = datetime.fromisoformat(returned_at)
                            text += f" → {ret.strftime('%d.%m %H:%M')}"
                        
                        text += f"\n\n"
                else:
                    text += get_text('no_records', lang)
                
                keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_tools")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ==================== Vehicle Usage Handlers ====================
            
            # Vehicle Usage - Main menu
            elif query.data == "reception_vehicles":
                from database import get_active_vehicle_usage
                
                lang = get_user_language(telegram_user_id, self.db)
                active_usage = get_active_vehicle_usage(self.db)
                active_count = len(active_usage) if active_usage else 0
                
                text = f"🚗 {get_text('vehicle_usage', lang)}\n\n"
                if active_count > 0:
                    text += f"📊 {get_text('active_usage', lang)}: {active_count}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"🚙 {get_text('borrow_vehicle', lang)}", callback_data="vehicle_borrow_select")],
                    [InlineKeyboardButton(f"� {get_text('return_vehicle', lang)}", callback_data="vehicle_return_select")],
                    [InlineKeyboardButton(f"📋 {get_text('usage_history', lang)}", callback_data="vehicle_usage_history")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_home")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Vehicle Usage - Select vehicle to borrow
            elif query.data == "vehicle_borrow_select":
                from database import get_available_vehicles
                
                lang = get_user_language(telegram_user_id, self.db)
                vehicles = get_available_vehicles(self.db)
                
                text = f"🚙 {get_text('select_vehicle_to_borrow', lang)}\n\n"
                
                if not vehicles:
                    text += f"⚠️ {get_text('no_available_vehicles', lang)}"
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")]]
                else:
                    keyboard = []
                    for v in vehicles:
                        vehicle_id, name, vehicle_type, plate_no = v[0], v[1], v[2] or "", v[3] or ""
                        btn_text = f"{name}"
                        if plate_no:
                            btn_text += f" ({plate_no})"
                        keyboard.append([InlineKeyboardButton(btn_text, callback_data=f"vehicle_borrow_{vehicle_id}")])
                    keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Vehicle Usage - Select driver for vehicle
            elif query.data.startswith("vehicle_borrow_") and not query.data.startswith("vehicle_borrow_select"):
                lang = get_user_language(telegram_user_id, self.db)
                vehicle_id = int(query.data.replace("vehicle_borrow_", ""))
                
                # Store selected vehicle in context
                if telegram_user_id not in self.user_context:
                    self.user_context[telegram_user_id] = {}
                self.user_context[telegram_user_id]['selected_vehicle_id'] = vehicle_id
                
                # Get employees for driver selection (only drivers, managers, directors)
                employees = self.db.get_all_employees()
                
                # Filter: only Driver, Manager, Director roles
                driver_roles = ['Driver', 'Manager', 'Director', 'Vozač', 'Rukovodilac', 'Direktor']
                
                text = f"👤 {get_text('select_driver', lang)}\n\n"
                
                keyboard = []
                if employees:
                    for emp in employees:
                        emp_id = emp[0]
                        emp_name = emp[2]  # name is at index 2
                        emp_role = emp[4] if len(emp) > 4 and emp[4] else ""  # work_role at index 4
                        
                        # Only show employees with driver/manager/director roles
                        if emp_role and any(role.lower() in emp_role.lower() for role in driver_roles):
                            btn_text = f"{emp_name}"
                            if emp_role:
                                btn_text += f" ({emp_role})"
                            keyboard.append([InlineKeyboardButton(btn_text, callback_data=f"vehicle_driver_{emp_id}")])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="vehicle_borrow_select")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Vehicle Usage - Driver selected, ask for purpose
            elif query.data.startswith("vehicle_driver_"):
                lang = get_user_language(telegram_user_id, self.db)
                driver_id = int(query.data.replace("vehicle_driver_", ""))
                
                # Store driver in context
                if telegram_user_id not in self.user_context:
                    self.user_context[telegram_user_id] = {}
                self.user_context[telegram_user_id]['selected_driver_id'] = driver_id
                
                # Get driver name
                employees = self.db.get_all_employees()
                driver_name = ""
                for emp in employees:
                    if emp[0] == driver_id:
                        driver_name = emp[2]  # name is at index 2
                        break
                self.user_context[telegram_user_id]['selected_driver_name'] = driver_name
                
                text = f"📝 {get_text('enter_purpose', lang)}\n\n"
                text += f"👤 {get_text('driver', lang)}: {driver_name}"
                
                keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data=f"vehicle_borrow_{self.user_context[telegram_user_id].get('selected_vehicle_id', 0)}")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                self.user_context[telegram_user_id]['awaiting_vehicle_purpose'] = True
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Vehicle Usage - Select vehicle to return
            elif query.data == "vehicle_return_select":
                from database import get_active_vehicle_usage
                
                lang = get_user_language(telegram_user_id, self.db)
                active_usage = get_active_vehicle_usage(self.db)
                
                text = f"🔙 {get_text('select_vehicle_to_return', lang)}\n\n"
                
                if not active_usage:
                    text += f"⚠️ {get_text('no_active_usage', lang)}"
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")]]
                else:
                    keyboard = []
                    for usage in active_usage:
                        usage_id = usage[0]
                        vehicle_name = usage[1]
                        driver_name = usage[2]
                        purpose = usage[3] or ""
                        btn_text = f"{vehicle_name} - {driver_name}"
                        keyboard.append([InlineKeyboardButton(btn_text, callback_data=f"vehicle_return_{usage_id}")])
                    keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Vehicle Usage - Return vehicle, ask for mileage after
            elif query.data.startswith("vehicle_return_") and not query.data.startswith("vehicle_return_select"):
                lang = get_user_language(telegram_user_id, self.db)
                usage_id = int(query.data.replace("vehicle_return_", ""))
                
                # Store usage_id in context
                if telegram_user_id not in self.user_context:
                    self.user_context[telegram_user_id] = {}
                self.user_context[telegram_user_id]['returning_usage_id'] = usage_id
                
                text = f"📊 {get_text('enter_mileage_after', lang)}\n\n"
                text += f"({get_text('mileage_after', lang)})"
                
                keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="vehicle_return_select")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                self.user_context[telegram_user_id]['awaiting_vehicle_mileage_after'] = True
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Vehicle Usage - Usage history
            elif query.data == "vehicle_usage_history":
                from database import get_vehicle_usage_records
                
                lang = get_user_language(telegram_user_id, self.db)
                records = get_vehicle_usage_records(self.db, limit=20)
                
                text = f"📋 {get_text('usage_history', lang)}\n\n"
                
                if records:
                    for rec in records:
                        usage_id, vehicle_name, driver_name, purpose, mileage_before, mileage_after, status, borrowed_at, returned_at = rec
                        
                        status_emoji = "🚙" if status == 'Borrowed' else "✅"
                        text += f"{status_emoji} {vehicle_name}\n"
                        text += f"   👤 {driver_name}\n"
                        if purpose:
                            text += f"   📝 {purpose}\n"
                        if mileage_before:
                            text += f"   📊 {mileage_before}"
                            if mileage_after:
                                text += f" → {mileage_after} km"
                            text += "\n"
                        
                        if borrowed_at:
                            # Handle both datetime object and string
                            if isinstance(borrowed_at, datetime):
                                borrowed = borrowed_at
                            else:
                                borrowed = datetime.fromisoformat(borrowed_at)
                            text += f"   🕐 {borrowed.strftime('%d.%m %H:%M')}"
                            if returned_at:
                                if isinstance(returned_at, datetime):
                                    returned = returned_at
                                else:
                                    returned = datetime.fromisoformat(returned_at)
                                text += f" → {returned.strftime('%d.%m %H:%M')}"
                        text += "\n\n"
                else:
                    text += f"⚠️ {get_text('no_active_usage', lang)}"
                
                keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Vehicle Usage - Inspection status selection
            elif query.data.startswith("vehicle_inspection_"):
                from database import complete_vehicle_usage
                
                lang = get_user_language(telegram_user_id, self.db)
                parts = query.data.replace("vehicle_inspection_", "").split("_")
                status = parts[0]  # good or issue
                
                usage_id = self.user_context.get(telegram_user_id, {}).get('returning_usage_id')
                mileage_after = self.user_context.get(telegram_user_id, {}).get('vehicle_mileage_after')
                
                if usage_id:
                    # Complete vehicle return
                    complete_vehicle_usage(self.db, usage_id, mileage_after, status)
                    
                    # Clean up context
                    if telegram_user_id in self.user_context:
                        self.user_context[telegram_user_id].pop('returning_usage_id', None)
                        self.user_context[telegram_user_id].pop('vehicle_mileage_after', None)
                    
                    text = f"✅ {get_text('vehicle_returned', lang)}\n\n"
                    text += f"📊 {get_text('mileage_after', lang)}: {mileage_after}\n"
                    text += f"🔍 {get_text('inspection_status', lang)}: "
                    text += get_text('inspection_good', lang) if status == 'good' else get_text('inspection_issue', lang)
                    
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.edit_message_text("Error: Usage not found", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("🔙 Back", callback_data="reception_vehicles")]]))
            
            # ==================== Laundry Assignment Handlers ====================
            
            # Laundry Assignment - Main menu (Step 1: Select employee)
            elif query.data == "emp_assign_laundry":
                from database import get_laundry_employees, create_assignments_table
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Ensure table exists
                create_assignments_table(self.db)
                
                employees = get_laundry_employees(self.db)
                
                if not employees:
                    text = f"{get_text('assign_laundry', lang)}\n\n"
                    text += get_text('no_laundry_employees', lang)
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                    return
                
                # Clear any previous state
                context.user_data.pop('laundry_assign', None)
                context.user_data.pop('awaiting_laundry_attachment', None)
                
                text = f"{get_text('assign_laundry', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_select_worker', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('select_worker_for_task', lang)
                
                keyboard = []
                for emp in employees:
                    tg_id, emp_id, name, work_role = emp
                    role_text = f" ({work_role})" if work_role else ""
                    keyboard.append([InlineKeyboardButton(f"👤 {name}{role_text}", callback_data=f"laundry_emp_{tg_id}")])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Laundry Assignment - Step 2: Enter description (no floor/room selection)
            elif query.data.startswith("laundry_emp_"):
                emp_tg_id = int(query.data.replace("laundry_emp_", ""))
                lang = get_user_language(telegram_user_id, self.db)
                
                # Store selected employee
                context.user_data['laundry_assign'] = {
                    'assignee_id': emp_tg_id,
                    'step': 'description'
                }
                
                # Get employee name
                emp_info = self.db.get_employee_info(emp_tg_id)
                if emp_info:
                    context.user_data['laundry_assign']['assignee_name'] = emp_info['name']
                
                assignee_name = context.user_data['laundry_assign'].get('assignee_name', 'Unknown')
                
                text = f"{get_text('assign_laundry', lang)}\n\n"
                text += f"👤 {get_text('worker_label', lang)}: {assignee_name}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_enter_task', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('enter_task_description', lang)}\n"
                text += f"{get_text('order_description_example', lang)}\n\n"
                text += get_text('enter_order_text', lang)
                
                keyboard = [[InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_laundry")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Laundry Assignment - Set deadline
            elif query.data.startswith("laundry_deadline_"):
                hours = int(query.data.replace("laundry_deadline_", ""))
                from datetime import datetime, timedelta
                lang = get_user_language(telegram_user_id, self.db)
                
                now = datetime.now()
                deadline = now + timedelta(hours=hours)
                
                context.user_data['laundry_assign']['due_date'] = deadline.strftime("%Y-%m-%d")
                context.user_data['laundry_assign']['due_time'] = deadline.strftime("%H:%M")
                context.user_data['laundry_assign']['step'] = 'media'
                
                assignee_name = context.user_data['laundry_assign'].get('assignee_name', 'Unknown')
                description = context.user_data['laundry_assign'].get('description', '')
                
                text = f"{get_text('assign_laundry', lang)}\n\n"
                text += f"👤 {get_text('worker_label', lang)}: {assignee_name}\n"
                text += f"📝 {get_text('task_order', lang)}: {description}\n"
                text += f"⏰ {get_text('deadline_label', lang)}: {deadline.strftime('%d.%m.%Y %H:%M')}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_attachment', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('send_attachment_hint', lang)
                
                # Initialize attachments list
                if 'laundry_assign' not in context.user_data:
                    context.user_data['laundry_assign'] = {}
                if 'attachments' not in context.user_data['laundry_assign']:
                    context.user_data['laundry_assign']['attachments'] = []
                
                context.user_data['awaiting_laundry_attachment'] = True
                
                keyboard = [
                    [InlineKeyboardButton(f"{get_text('finish_and_send', lang)}", callback_data="laundry_finish_attachments")],
                    [InlineKeyboardButton(f"⏭️ {get_text('skip_attachment', lang)}", callback_data="laundry_skip_media")],
                    [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_laundry")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Laundry Assignment - Finish attachments
            elif query.data == "laundry_finish_attachments":
                context.user_data.pop('awaiting_laundry_attachment', None)
                lang = get_user_language(telegram_user_id, self.db)
                
                # Show confirmation
                data = context.user_data['laundry_assign']
                assignee_name = data.get('assignee_name', 'Unknown')
                description = data.get('description', '')
                due_date = data.get('due_date', '')
                due_time = data.get('due_time', '')
                attachments = data.get('attachments', [])
                attachment_count = len(attachments)
                
                text = f"{get_text('laundry_confirm_title', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"👤 {get_text('worker_label', lang)}: {assignee_name}\n"
                text += f"📝 {get_text('task_order', lang)}:\n{description}\n"
                text += f"⏰ {get_text('deadline_label', lang)}: {due_date} {due_time}\n"
                if attachment_count > 0:
                    text += f"📎 {get_text('attachments', lang)}: {attachment_count} {get_text('file', lang) if attachment_count == 1 else get_text('files', lang)}\n"
                else:
                    text += f"📎 {get_text('attachment', lang)}: {get_text('no_attachment_label', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('confirm_assign_question', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"✅ {get_text('confirm', lang)}", callback_data="laundry_confirm"),
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_laundry")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Laundry Assignment - Skip media attachment
            elif query.data == "laundry_skip_media":
                context.user_data.pop('awaiting_laundry_attachment', None)
                lang = get_user_language(telegram_user_id, self.db)
                # Clear attachments when skipping
                if 'laundry_assign' in context.user_data:
                    context.user_data['laundry_assign']['attachments'] = []
                
                # Show confirmation
                data = context.user_data['laundry_assign']
                assignee_name = data.get('assignee_name', 'Unknown')
                description = data.get('description', '')
                due_date = data.get('due_date', '')
                due_time = data.get('due_time', '')
                
                text = f"{get_text('laundry_confirm_title', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"👤 {get_text('worker_label', lang)}: {assignee_name}\n"
                text += f"📝 {get_text('task_order', lang)}:\n{description}\n"
                text += f"⏰ {get_text('deadline_label', lang)}: {due_date} {due_time}\n"
                text += f"📎 {get_text('attachment', lang)}: {get_text('no_attachment_label', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('confirm_assign_question', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"✅ {get_text('confirm', lang)}", callback_data="laundry_confirm"),
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_laundry")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Laundry Assignment - Confirm and create task
            elif query.data == "laundry_confirm":
                from database import create_laundry_task
                import json
                
                lang = get_user_language(telegram_user_id, self.db)
                data = context.user_data.get('laundry_assign', {})
                
                # Get assigner info
                telegram_user_id = query.from_user.id
                assigner_info = self.db.get_employee_info(telegram_user_id)
                assigner_name = assigner_info['name'] if assigner_info else 'Unknown'
                
                # Get assignee lang for notification
                assignee_lang = get_user_language(data.get('assignee_id', 0), self.db)
                
                # Get attachments info
                attachments = data.get('attachments', [])
                attachment_count = len(attachments)
                
                # Store attachments as JSON (legacy compatibility)
                attachment_json = json.dumps(attachments) if attachments else None
                
                task_id = create_laundry_task(
                    self.db,
                    room_id=0,
                    room_number='',
                    floor=0,
                    assignee_id=data.get('assignee_id', 0),
                    assignee_name=data.get('assignee_name', ''),
                    description=data.get('description', ''),
                    due_date=data.get('due_date', ''),
                    due_time=data.get('due_time', ''),
                    proof_required=1 if attachments else 0,
                    assigned_by=telegram_user_id,
                    assigned_by_name=assigner_name
                )
                
                if task_id:
                    # Send notification to assignee
                    try:
                        assignee_id = data.get('assignee_id')
                        attachment_text = f"{attachment_count} {get_text('file', assignee_lang) if attachment_count == 1 else get_text('files', assignee_lang)}" if attachment_count > 0 else get_text('no_attachment_label', assignee_lang)
                        
                        notification_text = f"""{get_text('new_laundry_task_notification', assignee_lang)}

📝 {get_text('task_order', assignee_lang)}:
{data.get('description', '')}
⏰ {get_text('deadline_label', assignee_lang)}: {data.get('due_date', '')} {data.get('due_time', '')}
👤 {get_text('assigned_by', assignee_lang)}: {assigner_name}
📎 {get_text('attachments', assignee_lang)}: {attachment_text}

{get_text('press_start_to_view', assignee_lang)}"""
                        
                        # Send notification message
                        await self.application.bot.send_message(
                            chat_id=assignee_id,
                            text=notification_text
                        )
                        
                        # Send attachments as media group
                        if attachments:
                            from telegram import InputMediaPhoto, InputMediaVideo
                            
                            media_group = []
                            documents = []
                            
                            for idx, attachment in enumerate(attachments):
                                file_id = attachment.get('file_id')
                                file_type = attachment.get('type', 'photo')
                                
                                caption = f"📎 {attachment_count} {get_text('file', assignee_lang) if attachment_count == 1 else get_text('files', assignee_lang)}" if idx == 0 else None
                                
                                if file_type == 'photo':
                                    media_group.append(InputMediaPhoto(media=file_id, caption=caption))
                                elif file_type == 'video':
                                    media_group.append(InputMediaVideo(media=file_id, caption=caption))
                                elif file_type == 'document':
                                    documents.append(file_id)
                            
                            # Send media group (photos/videos together)
                            if media_group:
                                try:
                                    await self.application.bot.send_media_group(
                                        chat_id=assignee_id,
                                        media=media_group
                                    )
                                except Exception as e:
                                    print(f"❌ Failed to send media group: {e}")
                            
                            # Send documents individually
                            for idx, doc_id in enumerate(documents, 1):
                                try:
                                    await self.application.bot.send_document(
                                        chat_id=assignee_id,
                                        document=doc_id,
                                        caption=get_text('document_num', assignee_lang).format(current=idx, total=len(documents))
                                    )
                                except Exception as e:
                                    print(f"❌ Failed to send document {idx}: {e}")
                    except Exception as e:
                        print(f"Failed to send notification: {e}")
                    
                    await query.answer(get_text('laundry_task_success', lang), show_alert=True)
                    
                    attachment_text = f"{attachment_count} {get_text('file', lang) if attachment_count == 1 else get_text('files', lang)}" if attachment_count > 0 else get_text('no_attachment_label', lang)
                    
                    text = f"{get_text('laundry_task_success', lang)}\n\n"
                    text += f"👤 {get_text('worker_label', lang)}: {data.get('assignee_name', '')}\n"
                    text += f"📝 {get_text('task_order', lang)}: {data.get('description', '')[:50]}...\n" if len(data.get('description', '')) > 50 else f"📝 {get_text('task_order', lang)}: {data.get('description', '')}\n"
                    text += f"⏰ {get_text('deadline_label', lang)}: {data.get('due_date', '')} {data.get('due_time', '')}\n"
                    text += f"📎 {get_text('attachments', lang)}: {attachment_text}\n"
                    text += f"\n{get_text('notification_sent_to_employee', lang)}"
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('new_assignment_btn', lang), callback_data="emp_assign_laundry")],
                        [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('error_assigning_task', lang), show_alert=True)
                
                # Clean up
                context.user_data.pop('laundry_assign', None)
                context.user_data.pop('awaiting_laundry_attachment', None)
            
            # ==================== Restaurant Assignment Handlers ====================
            
            # Restaurant Assignment - Main menu (Step 1: Select employee)
            elif query.data == "emp_assign_kitchen":
                lang = get_user_language(query.from_user.id, self.db)
                from database import get_restaurant_employees, create_restaurant_tasks_table
                
                # Ensure table exists
                create_restaurant_tasks_table(self.db)
                
                employees = get_restaurant_employees(self.db)
                
                if not employees:
                    text = f"{get_text('assign_kitchen', lang)}\n\n"
                    text += get_text('no_kitchen_employees', lang)
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                    return
                
                # Clear any previous state
                context.user_data.pop('restaurant_assign', None)
                context.user_data.pop('awaiting_restaurant_attachment', None)
                
                text = f"{get_text('assign_kitchen', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_select_worker', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('select_worker_for_task', lang)
                
                keyboard = []
                for emp in employees:
                    tg_id, emp_id, name, work_role = emp
                    role_text = f" ({work_role})" if work_role else ""
                    keyboard.append([InlineKeyboardButton(f"👤 {name}{role_text}", callback_data=f"rest_emp_{tg_id}")])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ============================================================
            # DRIVER/DELIVERY ASSIGNMENT SYSTEM
            # ============================================================
            
            # Driver Assignment - Step 1: Select driver
            elif query.data == "emp_assign_driver":
                lang = get_user_language(query.from_user.id, self.db)
                from database import get_drivers, create_delivery_tasks_table
                
                # Ensure table exists
                create_delivery_tasks_table(self.db)
                
                drivers = get_drivers(self.db)
                
                if not drivers:
                    text = f"{get_text('assign_driver', lang)}\n\n"
                    text += get_text('no_drivers', lang)
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                    return
                
                # Clear any previous state
                context.user_data.pop('driver_assign', None)
                context.user_data.pop('awaiting_driver_attachment', None)
                
                text = f"{get_text('assign_driver', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_select_worker', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('select_driver_for_delivery', lang)
                
                keyboard = []
                for driver in drivers:
                    emp_id, name, dept, work_role = driver
                    # Get telegram_user_id for this driver
                    driver_info = self.db.execute_query(
                        "SELECT telegram_user_id FROM tbl_employeer WHERE employee_id = %s",
                        (emp_id,)
                    )
                    if driver_info:
                        tg_id = driver_info[0][0]
                        role_text = f" ({work_role})" if work_role else ""
                        keyboard.append([InlineKeyboardButton(f"🚗 {name}{role_text}", callback_data=f"driver_emp_{tg_id}")])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Driver Assignment - Step 2: Enter description
            elif query.data.startswith("driver_emp_"):
                lang = get_user_language(query.from_user.id, self.db)
                driver_tg_id = int(query.data.replace("driver_emp_", ""))
                
                # Store selected driver
                context.user_data['driver_assign'] = {
                    'assignee_id': driver_tg_id,
                    'step': 'description'
                }
                
                # Get driver name
                emp_info = self.db.get_employee_info(driver_tg_id)
                if emp_info:
                    context.user_data['driver_assign']['assignee_name'] = emp_info['name']
                
                assignee_name = context.user_data['driver_assign'].get('assignee_name', 'Unknown')
                
                text = f"{get_text('assign_driver', lang)}\n\n"
                text += f"{get_text('driver_label', lang)}: {assignee_name}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_enter_task', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('enter_task_description', lang)}\n\n"
                text += f"{get_text('driver_order_example_title', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += get_text('driver_order_example', lang) + "\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('driver_order_alt', lang) + "\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                
                keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_assign_driver")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
                
                context.user_data['awaiting_driver_description'] = True
            
            # Driver Assignment - Step 3: Select deadline
            elif query.data.startswith("driver_deadline_"):
                lang = get_user_language(query.from_user.id, self.db)
                hours = int(query.data.replace("driver_deadline_", ""))
                
                from datetime import datetime, timedelta
                deadline = datetime.now() + timedelta(hours=hours)
                due_date = deadline.strftime("%Y-%m-%d")
                due_time = deadline.strftime("%H:%M")
                
                context.user_data['driver_assign']['due_date'] = due_date
                context.user_data['driver_assign']['due_time'] = due_time
                context.user_data['driver_assign']['step'] = 'attachment'
                
                assignee_name = context.user_data['driver_assign'].get('assignee_name', 'Unknown')
                description = context.user_data['driver_assign'].get('description', '')
                
                text = f"{get_text('assign_driver', lang)}\n\n"
                text += f"{get_text('driver_label', lang)}: {assignee_name}\n"
                text += f"⏰ {get_text('deadline_label', lang)}: {due_date} {due_time}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_attachment', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('send_attachment_hint', lang)
                
                # Initialize attachments list
                if 'driver_assign' not in context.user_data:
                    context.user_data['driver_assign'] = {}
                if 'attachments' not in context.user_data['driver_assign']:
                    context.user_data['driver_assign']['attachments'] = []
                
                keyboard = [
                    [InlineKeyboardButton(f"{get_text('finish_and_send', lang)}", callback_data="driver_finish_attachments")],
                    [InlineKeyboardButton(f"⏭️ {get_text('skip_attachment', lang)}", callback_data="driver_skip_attachment")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_assign_driver")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
                
                context.user_data['awaiting_driver_attachment'] = True
            
            # Driver Assignment - Finish attachments
            elif query.data == "driver_finish_attachments":
                lang = get_user_language(query.from_user.id, self.db)
                context.user_data.pop('awaiting_driver_attachment', None)
                
                # Show confirmation
                data = context.user_data['driver_assign']
                assignee_name = data.get('assignee_name', 'Unknown')
                description = data.get('description', '')
                due_date = data.get('due_date', '')
                due_time = data.get('due_time', '')
                attachments = data.get('attachments', [])
                attachment_count = len(attachments)
                
                text = f"{get_text('driver_confirm_title', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('driver_label', lang)}: {assignee_name}\n"
                text += f"📝 {get_text('task_order', lang)}:\n{description[:100]}{'...' if len(description) > 100 else ''}\n"
                text += f"⏰ {get_text('deadline_label', lang)}: {due_date} {due_time}\n"
                if attachment_count > 0:
                    text += f"📎 {get_text('attachments', lang)}: {attachment_count} {get_text('file' if attachment_count == 1 else 'files', lang)}\n"
                else:
                    text += f"📎 {get_text('attachment', lang)}: {get_text('no_attachment_label', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('confirm_assign_question', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"✅ {get_text('confirm', lang)}", callback_data="driver_confirm"),
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_driver")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Driver Assignment - Skip attachment
            elif query.data == "driver_skip_attachment":
                lang = get_user_language(query.from_user.id, self.db)
                context.user_data.pop('awaiting_driver_attachment', None)
                # Clear attachments when skipping
                if 'driver_assign' in context.user_data:
                    context.user_data['driver_assign']['attachments'] = []
                
                # Show confirmation
                context.user_data['callback_query_data'] = 'driver_finish_attachments'
                await self.button_handler(update, context)
            
            # Driver Assignment - Confirm
            elif query.data == "driver_confirm":
                lang = get_user_language(query.from_user.id, self.db)
                import json
                assign_data = context.user_data.get('driver_assign', {})
                
                assignee_id = assign_data.get('assignee_id')
                assignee_name = assign_data.get('assignee_name', 'Unknown')
                description = assign_data.get('description', '')
                due_date = assign_data.get('due_date')
                due_time = assign_data.get('due_time')
                attachments = assign_data.get('attachments', [])
                attachment_count = len(attachments)
                
                # Get assigner info
                telegram_user_id = query.from_user.id
                assigner_info = self.db.get_employee_info(telegram_user_id)
                assigned_by_name = assigner_info['name'] if assigner_info else 'Unknown'
                
                # Convert attachments to JSON
                attachment_json = json.dumps(attachments) if attachments else None
                
                from database import create_delivery_task
                task_id = create_delivery_task(
                    self.db,
                    assignee_id=str(assignee_id),
                    assignee_name=assignee_name,
                    description=description,
                    due_date=due_date,
                    due_time=due_time,
                    assigned_by=str(telegram_user_id),
                    assigned_by_name=assigned_by_name,
                    attachment_file_id=attachment_json,
                    attachment_type=None
                )
                
                if task_id:
                    # Send notification to driver
                    try:
                        attachment_text = f"{attachment_count} {get_text('file' if attachment_count == 1 else 'files', 'sr')}" if attachment_count > 0 else get_text('without_attachments', 'sr')
                        
                        notify_text = f"{get_text('new_driver_task_notification', 'sr')}\n\n"
                        notify_text += f"📋 {get_text('task_order', 'sr')}:\n{description}\n\n"
                        notify_text += f"⏰ {get_text('deadline_label', 'sr')}: {due_date} {due_time}\n"
                        notify_text += f"👤 {get_text('assigned_by', 'sr')}: {assigned_by_name}\n"
                        notify_text += f"📎 {get_text('attachments', 'sr')}: {attachment_text}\n\n"
                        notify_text += get_text('press_start_for_tasks', 'sr')
                        
                        # Send notification message
                        await self.application.bot.send_message(
                            chat_id=assignee_id,
                            text=notify_text
                        )
                        
                        # Send attachments as media group
                        if attachments:
                            from telegram import InputMediaPhoto, InputMediaVideo
                            
                            media_group = []
                            documents = []
                            
                            for idx, attachment in enumerate(attachments):
                                file_id = attachment.get('file_id')
                                file_type = attachment.get('type', 'photo')
                                
                                caption = f"📎 {attachment_count} {get_text('file' if attachment_count == 1 else 'files', 'sr')}" if idx == 0 else None
                                
                                if file_type == 'photo':
                                    media_group.append(InputMediaPhoto(media=file_id, caption=caption))
                                elif file_type == 'video':
                                    media_group.append(InputMediaVideo(media=file_id, caption=caption))
                                elif file_type == 'document':
                                    documents.append(file_id)
                            
                            # Send media group (photos/videos together)
                            if media_group:
                                try:
                                    await self.application.bot.send_media_group(
                                        chat_id=assignee_id,
                                        media=media_group
                                    )
                                except Exception as e:
                                    print(f"❌ Failed to send media group: {e}")
                            
                            # Send documents individually
                            for idx, doc_id in enumerate(documents, 1):
                                try:
                                    await self.application.bot.send_document(
                                        chat_id=assignee_id,
                                        document=doc_id,
                                        caption=get_text('document_num', 'sr').format(current=idx, total=len(documents))
                                    )
                                except Exception as e:
                                    print(f"❌ Failed to send document {idx}: {e}")
                    except Exception as e:
                        print(f"Failed to send driver notification: {e}")
                    
                    attachment_text = f"{attachment_count} {get_text('file' if attachment_count == 1 else 'files', lang)}" if attachment_count > 0 else get_text('without_attachments', lang)
                    
                    text = f"{get_text('driver_task_success', lang)}\n\n"
                    text += f"{get_text('driver_label', lang)}: {assignee_name}\n"
                    text += f"📋 {get_text('task_order', lang)}: {description[:50]}...\n" if len(description) > 50 else f"📋 {get_text('task_order', lang)}: {description}\n"
                    text += f"⏰ {get_text('deadline_label', lang)}: {due_date} {due_time}\n"
                    text += f"📎 {get_text('attachments', lang)}: {attachment_text}"
                else:
                    text = get_text('error_assigning_task', lang)
                
                # Clear state
                context.user_data.pop('driver_assign', None)
                context.user_data.pop('awaiting_driver_attachment', None)
                
                keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ============================================================
            # DRIVER TASK VIEW AND COMPLETION
            # ============================================================
            
            # My delivery tasks (for drivers)
            elif query.data == "my_delivery_tasks":
                telegram_user_id = query.from_user.id
                
                from database import get_delivery_tasks_by_assignee
                tasks = get_delivery_tasks_by_assignee(self.db, str(telegram_user_id))
                
                if not tasks:
                    text = f"{get_text('my_tasks_driver_title', lang)}\n\n"
                    text += get_text('no_active_driver_tasks', lang)
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                    return
                
                text = f"{get_text('my_tasks_driver_title', lang)} ({len(tasks)})\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = []
                for task in tasks:
                    task_id, description, due_date, due_time, status, assigned_at, accepted_at, completed_at, assigned_by_name = task
                    
                    status_emoji = {"Pending": "📋", "Accepted": "🔄"}.get(status, "❓")
                    
                    short_desc = description[:30] + "..." if len(description) > 30 else description
                    button_text = f"{status_emoji} #{task_id} - {short_desc}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"driver_task_{task_id}")])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # View specific delivery task
            elif query.data.startswith("driver_task_"):
                task_id = int(query.data.replace("driver_task_", ""))
                
                from database import get_delivery_task_by_id
                task = get_delivery_task_by_id(self.db, task_id)
                
                if not task:
                    await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    return
                
                status_emoji = {"Pending": "📋", "Accepted": "🔄", "Completed": "✅"}.get(task['status'], "❓")
                text = f"{status_emoji} {get_text('task', lang)} #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"👤 {get_text('assigned_by', lang)}: {task['assigned_by_name']}\n"
                text += f"📅 {get_text('assigned_at', lang)}: {task['assigned_at']}\n\n"
                text += f"📝 {get_text('task_order', lang)}:\n{task['description']}\n"
                text += f"\n⏰ {get_text('deadline_label', lang)}: {task['due_date']} {task['due_time']}\n"
                
                if task.get('attachment_file_id'):
                    text += f"📎 {get_text('attachment', lang)}: {task['attachment_type']}\n"
                
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = []
                if task['status'] == 'Pending':
                    keyboard.append([InlineKeyboardButton(get_text('accept_task_btn', lang), callback_data=f"driver_accept_{task_id}")])
                elif task['status'] == 'Accepted':
                    keyboard.append([InlineKeyboardButton(get_text('complete_task_btn', lang), callback_data=f"driver_complete_{task_id}")])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="my_delivery_tasks")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Accept delivery task
            elif query.data.startswith("driver_accept_"):
                task_id = int(query.data.replace("driver_accept_", ""))
                
                from database import accept_delivery_task, get_delivery_task_by_id
                
                # Check current task status
                task = get_delivery_task_by_id(self.db, task_id)
                if not task:
                    try:
                        await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    except:
                        pass
                    return
                
                if task['status'] == 'Accepted':
                    try:
                        await query.answer(get_text('already_accepted_task', lang), show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                elif task['status'] == 'Completed':
                    try:
                        await query.answer(get_text('already_completed_task', lang), show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                elif task['status'] != 'Pending':
                    try:
                        await query.answer(get_text('task_already_status', lang).format(status=task['status']), show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                
                if accept_delivery_task(self.db, task_id):
                    try:
                        await query.answer(get_text('task_accepted_success', lang), show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                else:
                    try:
                        await query.answer(get_text('error_accepting_task', lang), show_alert=True)
                    except:
                        pass
            
            # Complete delivery task - start report flow
            elif query.data.startswith("driver_complete_"):
                task_id = int(query.data.replace("driver_complete_", ""))
                
                from database import get_delivery_task_by_id
                task = get_delivery_task_by_id(self.db, task_id)
                
                if not task:
                    await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    return
                
                context.user_data['driver_report'] = {
                    'task_id': task_id,
                    'step': 'notes',
                    'task': task
                }
                
                task_desc = task['description'][:50] + "..." if len(task['description']) > 50 else task['description']
                text = f"{get_text('task_report_title', lang)} #{task_id}\n\n"
                text += f"📝 {get_text('task', lang)}: {task_desc}\n"
                text += "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('task_report_step_notes', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('enter_task_notes', lang)}\n"
                text += get_text('driver_task_notes_example', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('skip_notes', lang), callback_data=f"driver_skip_notes_{task_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"driver_task_{task_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
                
                context.user_data['awaiting_driver_report_notes'] = task_id
            
            # Skip notes and go to media for driver
            elif query.data.startswith("driver_skip_notes_"):
                task_id = int(query.data.replace("driver_skip_notes_", ""))
                
                context.user_data['driver_report'] = context.user_data.get('driver_report', {})
                context.user_data['driver_report']['task_id'] = task_id
                context.user_data['driver_report']['notes'] = ''
                context.user_data['driver_report']['step'] = 'media'
                context.user_data['awaiting_driver_report_media'] = task_id
                
                from database import get_delivery_task_by_id
                task = get_delivery_task_by_id(self.db, task_id)
                
                text = f"{get_text('task_report_title', lang)} #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('task_report_step_media', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('attach_proof_text', lang) + "\n"
                
                keyboard = [
                    [InlineKeyboardButton(get_text('finish_without_proof', lang), callback_data=f"driver_finish_nophoto_{task_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"driver_task_{task_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finish delivery task without photo
            elif query.data.startswith("driver_finish_nophoto_"):
                from database import complete_delivery_task, get_delivery_task_by_id
                
                task_id = int(query.data.replace("driver_finish_nophoto_", ""))
                report_notes = context.user_data.get('driver_report', {}).get('notes', '')
                
                if complete_delivery_task(self.db, task_id, report_notes):
                    task = get_delivery_task_by_id(self.db, task_id)
                    
                    telegram_user_id = query.from_user.id
                    reporter_info = self.db.get_employee_info(telegram_user_id)
                    reporter_name = reporter_info['name'] if reporter_info else task['assignee_name']
                    
                    # Notify assigner (always in Serbian for admin)
                    try:
                        notification_text = f"""{get_text('driver_task_completed', 'sr')}

📝 {get_text('task', 'sr')}: {task['description'][:100]}...
{get_text('completed_by_label', 'sr')}: {reporter_name}
{get_text('time_label', 'sr')}: {task['completed_at']}"""
                        
                        if report_notes:
                            notification_text += f"\n\n{get_text('report_label', 'sr')}:\n{report_notes}"
                        
                        notification_text += f"\n\n{get_text('proof_label', 'sr')}: {get_text('no_proof_attached', 'sr')}"
                        
                        await self.application.bot.send_message(
                            chat_id=task['assigned_by'],
                            text=notification_text
                        )
                    except Exception as e:
                        print(f"Failed to send completion notification: {e}")
                    
                    await query.answer(get_text('task_completed_success', lang), show_alert=True)
                    
                    text = f"{get_text('task_completed_success', lang)}\n\n"
                    text += f"📝 {get_text('task', lang)}: {task['description'][:50]}...\n" if len(task['description']) > 50 else f"📝 {get_text('task', lang)}: {task['description']}\n"
                    text += f"{get_text('completed_label', lang)}: {task['completed_at']}\n"
                    
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="my_delivery_tasks")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('error_completing_task', lang), show_alert=True)
                
                context.user_data.pop('awaiting_driver_report_media', None)
                context.user_data.pop('driver_report', None)
            
            # ============================================================
            # ACCOUNTING TASK ASSIGNMENT AND MANAGEMENT
            # ============================================================
            
            # Accounting Assignment - Step 1: Select accountant
            elif query.data == "emp_assign_accounting":
                from database import get_accountants, create_accounting_tasks_table
                lang = get_user_language(query.from_user.id, self.db)
                
                # Ensure table exists
                create_accounting_tasks_table(self.db)
                
                accountants = get_accountants(self.db)
                
                if not accountants:
                    text = f"{get_text('assign_accounting_title', lang)}\n\n"
                    text += f"{get_text('no_accountants', lang)}"
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                    return
                
                # Clear any previous state
                context.user_data.pop('accounting_assign', None)
                context.user_data.pop('awaiting_accounting_attachment', None)
                
                text = f"{get_text('assign_accounting_title', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_select_worker', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('select_accountant_cashier', lang)}"
                
                keyboard = []
                for acct in accountants:
                    emp_id, name, dept, work_role = acct
                    # Get telegram_user_id for this accountant
                    acct_info = self.db.execute_query(
                        "SELECT telegram_user_id FROM tbl_employeer WHERE employee_id = %s",
                        (emp_id,)
                    )
                    if acct_info:
                        tg_id = acct_info[0][0]
                        role_text = f" ({work_role})" if work_role else ""
                        keyboard.append([InlineKeyboardButton(f"💰 {name}{role_text}", callback_data=f"acct_emp_{tg_id}")])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Accounting Assignment - Step 2: Enter description
            elif query.data.startswith("acct_emp_"):
                acct_tg_id = int(query.data.replace("acct_emp_", ""))
                lang = get_user_language(query.from_user.id, self.db)
                
                # Store selected accountant
                context.user_data['accounting_assign'] = {
                    'assignee_id': acct_tg_id,
                    'step': 'description'
                }
                
                # Get accountant name
                emp_info = self.db.get_employee_info(acct_tg_id)
                if emp_info:
                    context.user_data['accounting_assign']['assignee_name'] = emp_info['name']
                
                assignee_name = context.user_data['accounting_assign'].get('assignee_name', 'Unknown')
                
                text = f"{get_text('assign_accounting_title', lang)}\n\n"
                text += f"{get_text('worker_label', lang)}: {assignee_name}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_enter_task', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('enter_task_description', lang)}\n\n"
                text += f"{get_text('example_label', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('type_label', lang)}: {get_text('supplier_invoice', lang)}\n"
                text += f"{get_text('amount_label', lang)}: 50,000 RSD\n"
                text += f"{get_text('due_date_label', lang)}: 2024-02-15\n"
                text += f"{get_text('supplier_label', lang)}: ABC d.o.o.\n"
                text += f"{get_text('note_label', lang)}: {get_text('urgent_payment', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('or_label', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('type_label', lang)}: {get_text('salary_calc', lang)}\n"
                text += f"👥 {get_text('department_label', lang)}: {get_dept_display('Recepcija', lang)}\n"
                text += f"📅 {get_text('period_label', lang)}: Januar 2024\n"
                text += f"{get_text('note_label', lang)}: {get_text('bonus_overtime', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_assign_accounting")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
                
                context.user_data['awaiting_accounting_description'] = True
            
            # Accounting Assignment - Step 3: Select deadline
            elif query.data.startswith("acct_deadline_"):
                hours = int(query.data.replace("acct_deadline_", ""))
                lang = get_user_language(query.from_user.id, self.db)
                
                from datetime import datetime, timedelta
                deadline = datetime.now() + timedelta(hours=hours)
                due_date = deadline.strftime("%Y-%m-%d")
                due_time = deadline.strftime("%H:%M")
                
                context.user_data['accounting_assign']['due_date'] = due_date
                context.user_data['accounting_assign']['due_time'] = due_time
                context.user_data['accounting_assign']['step'] = 'attachment'
                
                assignee_name = context.user_data['accounting_assign'].get('assignee_name', 'Unknown')
                description = context.user_data['accounting_assign'].get('description', '')
                
                text = f"{get_text('assign_accounting_title', lang)}\n\n"
                text += f"{get_text('worker_label', lang)}: {assignee_name}\n"
                text += f"{get_text('deadline_label', lang)}: {due_date} {due_time}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_attachment', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('send_attachment_hint', lang)}\n"
                text += "a zatim kliknite 'Završi i pošalji' dugme"
                
                # Initialize attachments list
                if 'accounting_assign' not in context.user_data:
                    context.user_data['accounting_assign'] = {}
                if 'attachments' not in context.user_data['accounting_assign']:
                    context.user_data['accounting_assign']['attachments'] = []
                
                keyboard = [
                    [InlineKeyboardButton(f"{get_text('finish_and_send', lang)}", callback_data="accounting_finish_attachments")],
                    [InlineKeyboardButton(get_text('skip', lang), callback_data="accounting_skip_attachment")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="emp_assign_accounting")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
                
                context.user_data['awaiting_accounting_attachment'] = True
            
            # Accounting Assignment - Finish attachments
            elif query.data == "accounting_finish_attachments":
                context.user_data.pop('awaiting_accounting_attachment', None)
                lang = get_user_language(query.from_user.id, self.db)
                
                # Show confirmation
                data = context.user_data['accounting_assign']
                assignee_name = data.get('assignee_name', 'Unknown')
                description = data.get('description', '')
                due_date = data.get('due_date', '')
                due_time = data.get('due_time', '')
                attachments = data.get('attachments', [])
                attachment_count = len(attachments)
                
                text = f"{get_text('confirm_assignment', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"👤 {get_text('worker_label', lang)}: {assignee_name}\n"
                text += f"📝 {get_text('task_label', lang)}:\n{description[:100]}{'...' if len(description) > 100 else ''}\n"
                text += f"⏰ {get_text('deadline_label', lang)}: {due_date} {due_time}\n"
                if attachment_count > 0:
                    text += f"📎 {get_text('attachment', lang)}: {attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}\n"
                else:
                    text += f"📎 {get_text('attachment', lang)}: Nije priložen\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('confirm_assignment_question', lang)}"
                
                keyboard = [
                    [
                        InlineKeyboardButton("✅ Potvrdi", callback_data="acct_confirm"),
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_accounting")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Accounting Assignment - Skip attachment
            elif query.data == "accounting_skip_attachment":
                context.user_data.pop('awaiting_accounting_attachment', None)
                # Clear attachments when skipping
                if 'accounting_assign' in context.user_data:
                    context.user_data['accounting_assign']['attachments'] = []
                
                # Show confirmation
                context.user_data['callback_query_data'] = 'accounting_finish_attachments'
                await self.button_handler(update, context)
            
            # Accounting Assignment - Confirm
            elif query.data == "acct_confirm":
                import json
                assign_data = context.user_data.get('accounting_assign', {})
                
                assignee_id = assign_data.get('assignee_id')
                assignee_name = assign_data.get('assignee_name', 'Unknown')
                description = assign_data.get('description', '')
                due_date = assign_data.get('due_date')
                due_time = assign_data.get('due_time')
                attachments = assign_data.get('attachments', [])
                attachment_count = len(attachments)
                
                # Get assigner info
                telegram_user_id = query.from_user.id
                assigner_info = self.db.get_employee_info(telegram_user_id)
                assigned_by_name = assigner_info['name'] if assigner_info else 'Unknown'
                
                # Convert attachments to JSON
                attachment_json = json.dumps(attachments) if attachments else None
                
                from database import create_accounting_task
                task_id = create_accounting_task(
                    self.db,
                    assignee_id=str(assignee_id),
                    assignee_name=assignee_name,
                    description=description,
                    due_date=due_date,
                    due_time=due_time,
                    assigned_by=str(telegram_user_id),
                    assigned_by_name=assigned_by_name,
                    attachment_file_id=attachment_json,
                    attachment_type=None
                )
                
                if task_id:
                    # Send notification to accountant
                    try:
                        attachment_text = f"{attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}" if attachment_count > 0 else "Bez priloga"
                        
                        notify_text = f"💰 Novi zadatak za računovodstvo!\n\n"
                        notify_text += f"📋 Zadatak:\n{description}\n\n"
                        notify_text += f"⏰ Rok: {due_date} {due_time}\n"
                        notify_text += f"👤 Dodelio: {assigned_by_name}\n"
                        notify_text += f"📎 Prilozi: {attachment_text}\n\n"
                        notify_text += "Pritisnite /start za pregled zadataka."
                        
                        # Send notification message
                        await self.application.bot.send_message(
                            chat_id=assignee_id,
                            text=notify_text
                        )
                        
                        # Send attachments as media group
                        if attachments:
                            from telegram import InputMediaPhoto, InputMediaVideo
                            
                            media_group = []
                            documents = []
                            
                            for idx, attachment in enumerate(attachments):
                                file_id = attachment.get('file_id')
                                file_type = attachment.get('type', 'photo')
                                
                                caption = f"📎 {attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}" if idx == 0 else None
                                
                                if file_type == 'photo':
                                    media_group.append(InputMediaPhoto(media=file_id, caption=caption))
                                elif file_type == 'video':
                                    media_group.append(InputMediaVideo(media=file_id, caption=caption))
                                elif file_type == 'document':
                                    documents.append(file_id)
                            
                            # Send media group (photos/videos together)
                            if media_group:
                                try:
                                    await self.application.bot.send_media_group(
                                        chat_id=assignee_id,
                                        media=media_group
                                    )
                                except Exception as e:
                                    print(f"❌ Failed to send media group: {e}")
                            
                            # Send documents individually
                            for idx, doc_id in enumerate(documents, 1):
                                try:
                                    await self.application.bot.send_document(
                                        chat_id=assignee_id,
                                        document=doc_id,
                                        caption=f"📎 Dokument {idx}/{len(documents)}"
                                    )
                                except Exception as e:
                                    print(f"❌ Failed to send document {idx}: {e}")
                    except Exception as e:
                        print(f"Failed to send accounting notification: {e}")
                    
                    attachment_text = f"{attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}" if attachment_count > 0 else "Bez priloga"
                    
                    text = "✅ Zadatak uspešno dodeljen!\n\n"
                    text += f"💰 Radnik: {assignee_name}\n"
                    text += f"📋 Zadatak: {description[:50]}...\n" if len(description) > 50 else f"📋 Zadatak: {description}\n"
                    text += f"⏰ Rok: {due_date} {due_time}\n"
                    text += f"📎 Prilozi: {attachment_text}"
                else:
                    text = "❌ Greška pri kreiranju zadatka"
                
                # Clear state
                context.user_data.pop('accounting_assign', None)
                context.user_data.pop('awaiting_accounting_attachment', None)
                
                keyboard = [[InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_menu")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ============================================================
            # ACCOUNTING TASK VIEW AND COMPLETION
            # ============================================================
            
            # My accounting tasks (for accountants/cashiers)
            elif query.data == "my_accounting_tasks":
                telegram_user_id = query.from_user.id
                
                from database import get_accounting_tasks_by_assignee
                tasks = get_accounting_tasks_by_assignee(self.db, str(telegram_user_id))
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not tasks:
                    text = f"{get_text('my_accounting_tasks', lang)}\n\n"
                    text += "✅ Nemate aktivnih zadataka."
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                    return
                
                text = f"{get_text('my_accounting_tasks', lang)} ({len(tasks)})\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = []
                for task in tasks:
                    # Query returns 14 columns: id, description, due_date, due_time, status, assigned_at, 
                    # accepted_at, completed_at, assigned_by_name, category, amount, vendor_name, invoice_number, payment_method
                    task_id, description, due_date, due_time, status, assigned_at, accepted_at, completed_at, assigned_by_name, category, amount, vendor_name, invoice_number, payment_method = task
                    
                    status_emoji = {"Pending": "📋", "Accepted": "🔄"}.get(status, "❓")
                    
                    short_desc = description[:30] + "..." if len(description) > 30 else description
                    button_text = f"{status_emoji} #{task_id} - {short_desc}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"acct_task_{task_id}")])
                
                keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # View specific accounting task
            elif query.data.startswith("acct_task_"):
                task_id = int(query.data.replace("acct_task_", ""))
                
                from database import get_accounting_task_by_id
                task = get_accounting_task_by_id(self.db, task_id)
                
                if not task:
                    await query.answer("❌ Zadatak nije pronađen", show_alert=True)
                    return
                
                status_emoji = {"Pending": "📋", "Accepted": "🔄", "Completed": "✅"}.get(task['status'], "❓")
                text = f"{status_emoji} Zadatak #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"👤 Dodelio: {task['assigned_by_name']}\n"
                text += f"📅 Dodeljen: {task['assigned_at']}\n\n"
                text += f"📝 Zadatak:\n{task['description']}\n"
                text += f"\n⏰ Rok: {task['due_date']} {task['due_time']}\n"
                
                if task.get('attachment_file_id'):
                    text += f"📎 Prilog: {task['attachment_type']}\n"
                
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = []
                if task['status'] == 'Pending':
                    keyboard.append([InlineKeyboardButton("✅ Prihvati zadatak", callback_data=f"acct_accept_{task_id}")])
                elif task['status'] == 'Accepted':
                    keyboard.append([InlineKeyboardButton("✅ Završi zadatak", callback_data=f"acct_complete_{task_id}")])
                
                keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data="my_accounting_tasks")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Accept accounting task
            elif query.data.startswith("acct_accept_"):
                task_id = int(query.data.replace("acct_accept_", ""))
                
                from database import accept_accounting_task, get_accounting_task_by_id
                
                # Check current task status
                task = get_accounting_task_by_id(self.db, task_id)
                if not task:
                    try:
                        await query.answer("❌ Zadatak nije pronađen", show_alert=True)
                    except:
                        pass
                    return
                
                if task['status'] == 'Accepted':
                    try:
                        await query.answer("⚠️ Već ste prihvatili ovaj zadatak!\nBrzo ga izvršite i pošaljite izveštaj! 🚀", show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                elif task['status'] == 'Completed':
                    try:
                        await query.answer("✅ Ovaj zadatak je već završen!", show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                elif task['status'] != 'Pending':
                    try:
                        await query.answer(f"⚠️ Zadatak je već {task['status']}", show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                
                if accept_accounting_task(self.db, task_id):
                    try:
                        await query.answer("✅ Zadatak prihvaćen!", show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                else:
                    try:
                        await query.answer("❌ Greška pri prihvatanju zadatka", show_alert=True)
                    except:
                        pass
            
            # Complete accounting task - start report flow
            elif query.data.startswith("acct_complete_"):
                task_id = int(query.data.replace("acct_complete_", ""))
                
                from database import get_accounting_task_by_id
                task = get_accounting_task_by_id(self.db, task_id)
                
                if not task:
                    await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    return
                
                context.user_data['accounting_report'] = {
                    'task_id': task_id,
                    'step': 'notes',
                    'task': task
                }
                
                task_desc = task['description'][:50] + "..." if len(task['description']) > 50 else task['description']
                text = f"{get_text('task_report_title', lang)} #{task_id}\n\n"
                text += f"📝 {get_text('task', lang)}: {task_desc}\n"
                text += "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('task_report_step_notes', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('enter_task_notes', lang)}\n"
                text += get_text('accounting_task_notes_example', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('skip_notes', lang), callback_data=f"acct_skip_notes_{task_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"acct_task_{task_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
                
                context.user_data['awaiting_accounting_report_notes'] = task_id
            
            # Skip notes and go to media for accounting
            elif query.data.startswith("acct_skip_notes_"):
                task_id = int(query.data.replace("acct_skip_notes_", ""))
                
                context.user_data['accounting_report'] = context.user_data.get('accounting_report', {})
                context.user_data['accounting_report']['task_id'] = task_id
                context.user_data['accounting_report']['notes'] = ''
                context.user_data['accounting_report']['step'] = 'media'
                context.user_data['awaiting_accounting_report_media'] = task_id
                
                from database import get_accounting_task_by_id
                task = get_accounting_task_by_id(self.db, task_id)
                
                text = f"{get_text('task_report_title', lang)} #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('task_report_step_media', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('attach_proof_text', lang) + "\n"
                
                keyboard = [
                    [InlineKeyboardButton(get_text('finish_without_proof', lang), callback_data=f"acct_finish_nophoto_{task_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"acct_task_{task_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finish accounting task without photo
            elif query.data.startswith("acct_finish_nophoto_"):
                from database import complete_accounting_task, get_accounting_task_by_id
                
                task_id = int(query.data.replace("acct_finish_nophoto_", ""))
                report_notes = context.user_data.get('accounting_report', {}).get('notes', '')
                
                if complete_accounting_task(self.db, task_id, report_notes):
                    task = get_accounting_task_by_id(self.db, task_id)
                    
                    telegram_user_id = query.from_user.id
                    reporter_info = self.db.get_employee_info(telegram_user_id)
                    reporter_name = reporter_info['name'] if reporter_info else task['assignee_name']
                    
                    # Notify assigner (always in Serbian for admin)
                    try:
                        notification_text = f"""{get_text('accounting_task_completed', 'sr')}

📝 {get_text('task', 'sr')}: {task['description'][:100]}...
{get_text('completed_by_label', 'sr')}: {reporter_name}
{get_text('time_label', 'sr')}: {task['completed_at']}"""
                        
                        if report_notes:
                            notification_text += f"\n\n{get_text('report_label', 'sr')}:\n{report_notes}"
                        
                        notification_text += f"\n\n{get_text('proof_label', 'sr')}: {get_text('no_proof_attached', 'sr')}"
                        
                        await self.application.bot.send_message(
                            chat_id=task['assigned_by'],
                            text=notification_text
                        )
                    except Exception as e:
                        print(f"Failed to send completion notification: {e}")
                    
                    await query.answer("✅ Zadatak uspešno završen!", show_alert=True)
                    
                    text = f"✅ Zadatak uspešno završen!\n\n"
                    text += f"📝 Zadatak: {task['description'][:50]}...\n" if len(task['description']) > 50 else f"📝 Zadatak: {task['description']}\n"
                    text += f"🕐 Završeno: {task['completed_at']}\n"
                    
                    keyboard = [[InlineKeyboardButton("🔙 Nazad", callback_data="my_accounting_tasks")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("❌ Greška pri završavanju zadatka", show_alert=True)
                
                context.user_data.pop('awaiting_accounting_report_media', None)
                context.user_data.pop('accounting_report', None)
            
            # ============================================================
            # REPAIR TASK ASSIGNMENT AND MANAGEMENT (Technical Department)
            # ============================================================
            
            # Repair Assignment - Step 1: Select technician
            elif query.data == "emp_assign_repair":
                from database import get_technical_employees, create_repair_tasks_table
                lang = get_user_language(query.from_user.id, self.db)
                
                # Ensure table exists
                create_repair_tasks_table(self.db)
                
                technicians = get_technical_employees(self.db)
                
                if not technicians:
                    text = f"{get_text('assign_repair_title', lang)}\n\n"
                    text += f"{get_text('no_technicians', lang)}"
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                    return
                
                # Clear any previous state
                context.user_data.pop('repair_assign', None)
                context.user_data.pop('awaiting_repair_attachment', None)
                
                text = f"{get_text('assign_repair_title', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_1_5', lang)}: {get_text('select_technician', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('select_technician_prompt', lang)}:"
                
                keyboard = []
                for tech in technicians:
                    tg_id, emp_id, name, work_role = tech
                    role_text = f" ({work_role})" if work_role else ""
                    keyboard.append([InlineKeyboardButton(f"🔧 {name}{role_text}", callback_data=f"repair_emp_{tg_id}")])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Repair Assignment - Step 2: Select room
            elif query.data.startswith("repair_emp_"):
                lang = get_user_language(query.from_user.id, self.db)
                emp_tg_id = int(query.data.replace("repair_emp_", ""))
                
                # Store selected technician
                context.user_data['repair_assign'] = {
                    'assignee_id': emp_tg_id,
                    'step': 'room'
                }
                
                # Get technician name
                emp_info = self.db.get_employee_info(emp_tg_id)
                if emp_info:
                    context.user_data['repair_assign']['assignee_name'] = emp_info['name']
                
                assignee_name = context.user_data['repair_assign'].get('assignee_name', 'Unknown')
                
                # Get rooms
                rooms = self.db.get_customer_rooms()
                
                text = f"{get_text('assign_repair_title', lang)}\n\n"
                text += f"👤 {get_text('technician', lang)}: {assignee_name}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_2_5', lang)}: {get_text('select_room', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('select_room_prompt', lang)}:"
                
                keyboard = []
                # Add "No Room" option for general repairs
                keyboard.append([InlineKeyboardButton(get_text('general_repair', lang), callback_data="repair_room_0")])
                
                if rooms:
                    row = []
                    for room in rooms:
                        room_id, room_number, floor, status, is_active = room[:5]
                        if is_active:
                            btn_text = f"🚪 {room_number} (S{floor})"
                            row.append(InlineKeyboardButton(btn_text, callback_data=f"repair_room_{room_id}_{room_number}_{floor}"))
                            if len(row) == 3:
                                keyboard.append(row)
                                row = []
                    if row:
                        keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_repair")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Repair Assignment - Step 3: Select repair type
            elif query.data.startswith("repair_room_"):
                lang = get_user_language(query.from_user.id, self.db)
                room_data = query.data.replace("repair_room_", "")
                
                if room_data == "0":
                    context.user_data['repair_assign']['room_id'] = 0
                    context.user_data['repair_assign']['room_number'] = get_text('general', lang)
                    context.user_data['repair_assign']['floor'] = 0
                else:
                    parts = room_data.split("_")
                    context.user_data['repair_assign']['room_id'] = int(parts[0])
                    context.user_data['repair_assign']['room_number'] = parts[1]
                    context.user_data['repair_assign']['floor'] = int(parts[2])
                
                assignee_name = context.user_data['repair_assign'].get('assignee_name', 'Unknown')
                room_number = context.user_data['repair_assign'].get('room_number', 'Unknown')
                
                text = f"{get_text('assign_repair_title', lang)}\n\n"
                text += f"👤 {get_text('technician', lang)}: {assignee_name}\n"
                text += f"🚪 {get_text('room', lang)}: {room_number}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_3_5', lang)}: {get_text('repair_type', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('select_repair_type', lang)}:"
                
                keyboard = [
                    [InlineKeyboardButton(get_text('repair_type_electrical', lang), callback_data="repair_type_Electrical")],
                    [InlineKeyboardButton(get_text('repair_type_plumbing', lang), callback_data="repair_type_Plumbing")],
                    [InlineKeyboardButton(get_text('repair_type_hvac', lang), callback_data="repair_type_HVAC")],
                    [InlineKeyboardButton(get_text('repair_type_furniture', lang), callback_data="repair_type_Furniture")],
                    [InlineKeyboardButton(get_text('repair_type_electronics', lang), callback_data="repair_type_Electronics")],
                    [InlineKeyboardButton(get_text('repair_type_other', lang), callback_data="repair_type_Other")],
                    [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_repair")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Repair Assignment - Step 4: Select priority & enter description
            elif query.data.startswith("repair_type_"):
                lang = get_user_language(query.from_user.id, self.db)
                repair_type = query.data.replace("repair_type_", "")
                context.user_data['repair_assign']['repair_type'] = repair_type
                context.user_data['repair_assign']['step'] = 'priority'
                
                assignee_name = context.user_data['repair_assign'].get('assignee_name', 'Unknown')
                room_number = context.user_data['repair_assign'].get('room_number', 'Unknown')
                
                type_labels = {
                    'Electrical': get_text('repair_type_electrical', lang),
                    'Plumbing': get_text('repair_type_plumbing', lang),
                    'HVAC': get_text('repair_type_hvac', lang),
                    'Furniture': get_text('repair_type_furniture', lang),
                    'Electronics': get_text('repair_type_electronics', lang),
                    'Other': get_text('repair_type_other', lang)
                }
                
                text = f"{get_text('assign_repair_title', lang)}\n\n"
                text += f"👤 {get_text('technician', lang)}: {assignee_name}\n"
                text += f"🚪 {get_text('room', lang)}: {room_number}\n"
                text += f"📋 {get_text('type', lang)}: {type_labels.get(repair_type, repair_type)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_4_5', lang)}: {get_text('priority', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('select_priority', lang)}:"
                
                keyboard = [
                    [InlineKeyboardButton(get_text('priority_urgent', lang), callback_data="repair_priority_Urgent")],
                    [InlineKeyboardButton(get_text('priority_high', lang), callback_data="repair_priority_High")],
                    [InlineKeyboardButton(get_text('priority_normal', lang), callback_data="repair_priority_Normal")],
                    [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_repair")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Repair Assignment - Step 5: Enter description
            elif query.data.startswith("repair_priority_"):
                lang = get_user_language(query.from_user.id, self.db)
                priority = query.data.replace("repair_priority_", "")
                context.user_data['repair_assign']['priority'] = priority
                context.user_data['repair_assign']['step'] = 'description'
                
                assignee_name = context.user_data['repair_assign'].get('assignee_name', 'Unknown')
                room_number = context.user_data['repair_assign'].get('room_number', 'Unknown')
                repair_type = context.user_data['repair_assign'].get('repair_type', 'Unknown')
                
                priority_labels = {
                    'Urgent': get_text('priority_urgent', lang),
                    'High': get_text('priority_high', lang),
                    'Normal': get_text('priority_normal', lang)
                }
                type_labels = {
                    'Electrical': get_text('repair_type_electrical', lang),
                    'Plumbing': get_text('repair_type_plumbing', lang),
                    'HVAC': get_text('repair_type_hvac', lang),
                    'Furniture': get_text('repair_type_furniture', lang),
                    'Electronics': get_text('repair_type_electronics', lang),
                    'Other': get_text('repair_type_other', lang)
                }
                
                text = f"{get_text('assign_repair_title', lang)}\n\n"
                text += f"👤 {get_text('technician', lang)}: {assignee_name}\n"
                text += f"🚪 {get_text('room', lang)}: {room_number}\n"
                text += f"📋 {get_text('type', lang)}: {type_labels.get(repair_type, repair_type)}\n"
                text += f"⚠️ {get_text('priority', lang)}: {priority_labels.get(priority, priority)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_5_5', lang)}: {get_text('problem_description', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"📝 {get_text('enter_problem_description', lang)}:\n"
                text += f"({get_text('description_example', lang)})\n\n"
                text += f"{get_text('enter_description', lang)}:"
                
                keyboard = [[InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_repair")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Repair Assignment - Set deadline
            elif query.data.startswith("repair_deadline_"):
                lang = get_user_language(query.from_user.id, self.db)
                hours = int(query.data.replace("repair_deadline_", ""))
                from datetime import datetime, timedelta
                
                now = datetime.now()
                deadline = now + timedelta(hours=hours)
                
                context.user_data['repair_assign']['due_date'] = deadline.strftime("%Y-%m-%d")
                context.user_data['repair_assign']['due_time'] = deadline.strftime("%H:%M")
                context.user_data['repair_assign']['step'] = 'confirm'
                
                # Get all data
                assignee_id = context.user_data['repair_assign'].get('assignee_id')
                assignee_name = context.user_data['repair_assign'].get('assignee_name', 'Unknown')
                room_number = context.user_data['repair_assign'].get('room_number', 'Unknown')
                repair_type = context.user_data['repair_assign'].get('repair_type', 'Unknown')
                priority = context.user_data['repair_assign'].get('priority', 'Normal')
                description = context.user_data['repair_assign'].get('description', '')
                
                priority_labels = {
                    'Urgent': get_text('priority_urgent', lang),
                    'High': get_text('priority_high', lang),
                    'Normal': get_text('priority_normal', lang)
                }
                type_labels = {
                    'Electrical': get_text('repair_type_electrical', lang),
                    'Plumbing': get_text('repair_type_plumbing', lang),
                    'HVAC': get_text('repair_type_hvac', lang),
                    'Furniture': get_text('repair_type_furniture', lang),
                    'Electronics': get_text('repair_type_electronics', lang),
                    'Other': get_text('repair_type_other', lang)
                }
                
                # Create the task
                from database import create_repair_task
                
                room_id = context.user_data['repair_assign'].get('room_id', 0)
                floor = context.user_data['repair_assign'].get('floor', 0)
                assigned_by = query.from_user.id
                assigner_info = self.db.get_employee_info(assigned_by)
                assigned_by_name = assigner_info['name'] if assigner_info else "Unknown"
                
                due_date = context.user_data['repair_assign']['due_date']
                due_time = context.user_data['repair_assign']['due_time']
                
                task_id = create_repair_task(
                    self.db, room_id, room_number, floor,
                    assignee_id, assignee_name, description,
                    repair_type, priority, due_date, due_time,
                    0, assigned_by, assigned_by_name
                )
                
                if task_id:
                    # Send notification to technician
                    try:
                        emp_lang = get_user_language(assignee_id, self.db)
                        notify_text = f"{get_text('new_repair_task', emp_lang)}!\n\n"
                        notify_text += f"🚪 {get_text('room', emp_lang)}: {room_number}\n"
                        notify_text += f"📋 {get_text('type', emp_lang)}: {type_labels.get(repair_type, repair_type)}\n"
                        notify_text += f"⚠️ {get_text('priority', emp_lang)}: {priority_labels.get(priority, priority)}\n"
                        notify_text += f"📝 {get_text('description', emp_lang)}: {description}\n\n"
                        notify_text += f"⏰ {get_text('deadline', emp_lang)}: {deadline.strftime('%d.%m.%Y %H:%M')}\n"
                        notify_text += f"👤 {get_text('assigned_by', emp_lang)}: {assigned_by_name}\n\n"
                        notify_text += get_text('press_start_to_view', emp_lang)
                        
                        await self.application.bot.send_message(
                            chat_id=assignee_id,
                            text=notify_text
                        )
                    except Exception as e:
                        print(f"Failed to send repair notification: {e}")
                    
                    text = f"✅ {get_text('task_assigned_successfully', lang)}!\n\n"
                    text += f"🔧 {get_text('technician', lang)}: {assignee_name}\n"
                    text += f"🚪 {get_text('room', lang)}: {room_number}\n"
                    text += f"📋 {get_text('type', lang)}: {type_labels.get(repair_type, repair_type)}\n"
                    text += f"⚠️ {get_text('priority', lang)}: {priority_labels.get(priority, priority)}\n"
                    text += f"📝 {get_text('description', lang)}: {description[:50]}...\n" if len(description) > 50 else f"📝 {get_text('description', lang)}: {description}\n"
                    text += f"⏰ {get_text('deadline', lang)}: {deadline.strftime('%d.%m.%Y %H:%M')}"
                else:
                    text = f"❌ {get_text('task_creation_error', lang)}"
                
                # Clear state
                context.user_data.pop('repair_assign', None)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('new_assignment', lang), callback_data="emp_assign_repair")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ============================================================
            # REPAIR TASK VIEW AND COMPLETION (For Technicians)
            # ============================================================
            
            # My repair tasks
            elif query.data == "my_repair_tasks":
                telegram_user_id = query.from_user.id
                
                from database import get_pending_repair_tasks
                tasks = get_pending_repair_tasks(self.db, telegram_user_id)
                
                if not tasks:
                    text = "🔧 Moji zadaci za popravke\n\n"
                    text += "✅ Nemate aktivnih zadataka."
                    keyboard = [[InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                    return
                
                text = f"🔧 Moji zadaci za popravke ({len(tasks)})\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = []
                for task in tasks:
                    task_id, room_id, room_number, floor, description, repair_type, priority, due_date, due_time, proof_required, assigned_by_name, assigned_at, status = task
                    
                    status_emoji = {"Pending": "📋", "Accepted": "🔄"}.get(status, "❓")
                    priority_emoji = {"Urgent": "🔴", "High": "🟠", "Normal": "🟢"}.get(priority, "⚪")
                    
                    short_desc = description[:20] + "..." if len(description) > 20 else description
                    button_text = f"{status_emoji}{priority_emoji} #{task_id} {room_number}: {short_desc}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"repair_task_{task_id}")])
                
                keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # View specific repair task
            elif query.data.startswith("repair_task_") and not query.data.startswith("repair_task_accept_") and not query.data.startswith("repair_task_complete_"):
                task_id = int(query.data.replace("repair_task_", ""))
                
                from database import get_repair_task_by_id
                task = get_repair_task_by_id(self.db, task_id)
                
                if not task:
                    await query.answer("❌ Zadatak nije pronađen", show_alert=True)
                    return
                
                task_id, room_id, room_number, floor, assignee_id, assignee_name, description, repair_type, priority, due_date, due_time, proof_required, proof_path, status, assigned_by, assigned_by_name, assigned_at, accepted_at, completed_at, report_notes = task
                
                status_emoji = {"Pending": "📋 Na čekanju", "Accepted": "🔄 U toku", "Completed": "✅ Završeno"}.get(status, status)
                priority_emoji = {"Urgent": "🔴 Hitno", "High": "🟠 Visok", "Normal": "🟢 Normalan"}.get(priority, priority)
                type_labels = {
                    'Electrical': '⚡ Električni kvar',
                    'Plumbing': '🚿 Vodovod',
                    'HVAC': '❄️ Klimatizacija',
                    'Furniture': '🚪 Nameštaj/Vrata',
                    'Electronics': '📺 TV/Elektronika',
                    'Other': '🔧 Ostalo'
                }
                
                text = f"🔧 Zadatak za popravku #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"🚪 Soba: {room_number}\n"
                text += f"📋 Vrsta: {type_labels.get(repair_type, repair_type)}\n"
                text += f"⚠️ Prioritet: {priority_emoji}\n"
                text += f"📝 Opis:\n{description}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"⏰ Rok: {due_date} {due_time}\n"
                text += f"👤 Dodelio: {assigned_by_name}\n"
                text += f"📊 Status: {status_emoji}\n"
                
                if accepted_at:
                    text += f"✅ Prihvaćeno: {accepted_at}\n"
                
                keyboard = []
                if status == "Pending":
                    keyboard.append([InlineKeyboardButton("✅ Prihvati zadatak", callback_data=f"repair_task_accept_{task_id}")])
                elif status == "Accepted":
                    keyboard.append([InlineKeyboardButton(f"{get_text('finish_report', lang)}", callback_data=f"repair_task_complete_{task_id}")])
                
                keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data="my_repair_tasks")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Accept repair task
            elif query.data.startswith("repair_task_accept_"):
                task_id = int(query.data.replace("repair_task_accept_", ""))
                
                from database import accept_repair_task, get_repair_task_by_id
                
                task = get_repair_task_by_id(self.db, task_id)
                if not task:
                    await query.answer("❌ Zadatak nije pronađen", show_alert=True)
                    return
                
                if task[13] == 'Accepted':  # status is at index 13
                    await query.answer("⚠️ Već ste prihvatili ovaj zadatak!", show_alert=True)
                    return
                elif task[13] == 'Completed':
                    await query.answer("✅ Ovaj zadatak je već završen!", show_alert=True)
                    return
                
                if accept_repair_task(self.db, task_id):
                    await query.answer("✅ Zadatak prihvaćen!", show_alert=True)
                    
                    # Notify assigner
                    try:
                        notify_text = f"🔧 Zadatak za popravku #{task_id} prihvaćen!\n\n"
                        notify_text += f"👤 Tehničar: {task[5]}\n"  # assignee_name
                        notify_text += f"🚪 Soba: {task[2]}"  # room_number
                        
                        await self.application.bot.send_message(
                            chat_id=task[14],  # assigned_by
                            text=notify_text
                        )
                    except Exception as e:
                        print(f"Failed to send accept notification: {e}")
                    
                    # Refresh task view
                    context.user_data['callback_query_data'] = f"repair_task_{task_id}"
                    await self.button_handler(update, context)
                else:
                    await query.answer("❌ Greška pri prihvatanju zadatka", show_alert=True)
            
            # Complete repair task - enter report
            elif query.data.startswith("repair_task_complete_"):
                task_id = int(query.data.replace("repair_task_complete_", ""))
                
                context.user_data['repair_report'] = {
                    'task_id': task_id,
                    'step': 'notes'
                }
                
                from database import get_repair_task_by_id
                task = get_repair_task_by_id(self.db, task_id)
                
                text = f"📋 Izveštaj o popravci #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += "📝 Korak 1/2: Unesite izveštaj\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += "Opišite šta ste uradili:\n"
                text += "(npr. 'Zamenjena sijalica, očišćen filter klime')"
                
                keyboard = [[InlineKeyboardButton("🔙 Nazad", callback_data=f"repair_task_{task_id}")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finish repair without photo
            elif query.data.startswith("repair_finish_nophoto_"):
                from database import complete_repair_task, get_repair_task_by_id
                
                task_id = int(query.data.replace("repair_finish_nophoto_", ""))
                report_notes = context.user_data.get('repair_report', {}).get('notes', '')
                
                if complete_repair_task(self.db, task_id, report_notes):
                    task = get_repair_task_by_id(self.db, task_id)
                    
                    # Notify assigner
                    try:
                        notification_text = f"""🔧 Popravka završena!

🚪 Soba: {task[2]}
📋 Vrsta: {task[7]}
👤 Tehničar: {task[5]}
🕐 Završeno: {task[18]}"""
                        
                        if report_notes:
                            notification_text += f"\n\n📋 Izveštaj:\n{report_notes}"
                        
                        await self.application.bot.send_message(
                            chat_id=task[14],  # assigned_by
                            text=notification_text
                        )
                    except Exception as e:
                        print(f"Failed to send completion notification: {e}")
                    
                    await query.answer("✅ Popravka uspešno završena!", show_alert=True)
                    
                    text = "✅ Popravka uspešno završena!\n\n"
                    text += f"🚪 Soba: {task[2]}\n"
                    text += f"📋 Izveštaj: {report_notes if report_notes else 'Bez izveštaja'}\n"
                    
                    keyboard = [[InlineKeyboardButton("🔙 Nazad", callback_data="my_repair_tasks")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("❌ Greška pri završavanju popravke", show_alert=True)
                
                context.user_data.pop('repair_report', None)
                context.user_data.pop('awaiting_repair_report_media', None)

            # Restaurant Assignment - Step 2: Enter description
            elif query.data.startswith("rest_emp_"):
                lang = get_user_language(query.from_user.id, self.db)
                emp_tg_id = int(query.data.replace("rest_emp_", ""))
                
                # Store selected employee
                context.user_data['restaurant_assign'] = {
                    'assignee_id': emp_tg_id,
                    'step': 'description'
                }
                
                # Get employee name
                emp_info = self.db.get_employee_info(emp_tg_id)
                if emp_info:
                    context.user_data['restaurant_assign']['assignee_name'] = emp_info['name']
                
                assignee_name = context.user_data['restaurant_assign'].get('assignee_name', 'Unknown')
                
                text = f"{get_text('assign_kitchen', lang)}\n\n"
                text += f"{get_text('worker_label', lang)}: {assignee_name}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_enter_task', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('enter_task_description', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('order_examples_title', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('kitchen_order_event_example', lang) + "\n\n"
                text += get_text('kitchen_order_catering_example', lang) + "\n\n"
                text += get_text('kitchen_order_daily_example', lang) + "\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += get_text('enter_order_text', lang)
                
                keyboard = [[InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_kitchen")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Restaurant Assignment - Set deadline
            elif query.data.startswith("rest_deadline_"):
                lang = get_user_language(query.from_user.id, self.db)
                hours = int(query.data.replace("rest_deadline_", ""))
                from datetime import datetime, timedelta
                
                now = datetime.now()
                deadline = now + timedelta(hours=hours)
                
                context.user_data['restaurant_assign']['due_date'] = deadline.strftime("%Y-%m-%d")
                context.user_data['restaurant_assign']['due_time'] = deadline.strftime("%H:%M")
                context.user_data['restaurant_assign']['step'] = 'media'
                
                assignee_name = context.user_data['restaurant_assign'].get('assignee_name', 'Unknown')
                description = context.user_data['restaurant_assign'].get('description', '')
                
                text = f"{get_text('assign_kitchen', lang)}\n\n"
                text += f"{get_text('worker_label', lang)}: {assignee_name}\n"
                text += f"📝 {get_text('task_order', lang)}: {description[:50]}...\n" if len(description) > 50 else f"📝 {get_text('task_order', lang)}: {description}\n"
                text += f"⏰ {get_text('deadline_label', lang)}: {deadline.strftime('%d.%m.%Y %H:%M')}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('step_attachment', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('send_attachment_hint', lang)
                
                # Initialize attachments list
                if 'restaurant_assign' not in context.user_data:
                    context.user_data['restaurant_assign'] = {}
                if 'attachments' not in context.user_data['restaurant_assign']:
                    context.user_data['restaurant_assign']['attachments'] = []
                
                context.user_data['awaiting_restaurant_attachment'] = True
                
                keyboard = [
                    [InlineKeyboardButton(f"{get_text('finish_and_send', lang)}", callback_data="restaurant_finish_attachments")],
                    [InlineKeyboardButton(f"⏭️ {get_text('skip_attachment', lang)}", callback_data="rest_skip_attachment")],
                    [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_kitchen")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Restaurant Assignment - Finish attachments
            elif query.data == "restaurant_finish_attachments":
                lang = get_user_language(query.from_user.id, self.db)
                context.user_data.pop('awaiting_restaurant_attachment', None)
                
                # Show confirmation
                data = context.user_data['restaurant_assign']
                assignee_name = data.get('assignee_name', 'Unknown')
                description = data.get('description', '')
                due_date = data.get('due_date', '')
                due_time = data.get('due_time', '')
                attachments = data.get('attachments', [])
                attachment_count = len(attachments)
                
                text = f"{get_text('kitchen_confirm_title', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('worker_label', lang)}: {assignee_name}\n"
                text += f"📝 {get_text('description', lang)}:\n{description}\n"
                text += f"⏰ {get_text('deadline_label', lang)}: {due_date} {due_time}\n"
                if attachment_count > 0:
                    text += f"📎 {get_text('attachments', lang)}: {attachment_count} {get_text('file' if attachment_count == 1 else 'files', lang)}\n"
                else:
                    text += f"📎 {get_text('attachment', lang)}: {get_text('no_attachment_label', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('confirm_assign_question', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"✅ {get_text('confirm', lang)}", callback_data="rest_confirm"),
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_kitchen")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Restaurant Assignment - Skip media attachment
            elif query.data in ["rest_skip_media", "rest_skip_attachment"]:
                lang = get_user_language(query.from_user.id, self.db)
                context.user_data.pop('awaiting_restaurant_attachment', None)
                # Clear attachments when skipping
                if 'restaurant_assign' in context.user_data:
                    context.user_data['restaurant_assign']['attachments'] = []
                
                # Show confirmation
                data = context.user_data.get('restaurant_assign', {})
                assignee_name = data.get('assignee_name', 'Unknown')
                description = data.get('description', '')
                due_date = data.get('due_date', '')
                due_time = data.get('due_time', '')
                
                text = f"{get_text('kitchen_confirm_title', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('worker_label', lang)}: {assignee_name}\n"
                text += f"📝 {get_text('task_order', lang)}:\n{description}\n"
                text += f"⏰ {get_text('deadline_label', lang)}: {due_date} {due_time}\n"
                text += f"📎 {get_text('attachment', lang)}: {get_text('no_attachment_label', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('confirm_assign_question', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"✅ {get_text('confirm', lang)}", callback_data="rest_confirm"),
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_kitchen")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Restaurant Assignment - Confirm and create task
            elif query.data == "rest_confirm":
                from database import create_restaurant_task
                import json
                
                lang = get_user_language(query.from_user.id, self.db)
                data = context.user_data.get('restaurant_assign', {})
                
                # Get assigner info
                telegram_user_id = query.from_user.id
                assigner_info = self.db.get_employee_info(telegram_user_id)
                assigner_name = assigner_info['name'] if assigner_info else 'Unknown'
                
                # Get attachments info
                attachments = data.get('attachments', [])
                attachment_count = len(attachments)
                
                # Convert attachments to JSON
                attachment_json = json.dumps(attachments) if attachments else None
                
                task_id = create_restaurant_task(
                    self.db,
                    assignee_id=data.get('assignee_id', 0),
                    assignee_name=data.get('assignee_name', ''),
                    description=data.get('description', ''),
                    due_date=data.get('due_date', ''),
                    due_time=data.get('due_time', ''),
                    assigned_by=telegram_user_id,
                    assigned_by_name=assigner_name,
                    attachment_file_id=attachment_json,
                    attachment_type=None
                )
                
                if task_id:
                    # Send notification to assignee
                    try:
                        assignee_id = data.get('assignee_id')
                        attachment_text = f"{attachment_count} {get_text('file' if attachment_count == 1 else 'files', 'sr')}" if attachment_count > 0 else get_text('without_attachments', 'sr')
                        
                        notification_text = f"""{get_text('new_kitchen_task_notification', 'sr')}

📝 {get_text('task_order', 'sr')}:
{data.get('description', '')}
⏰ {get_text('deadline_label', 'sr')}: {data.get('due_date', '')} {data.get('due_time', '')}
👤 {get_text('assigned_by', 'sr')}: {assigner_name}
📎 {get_text('attachments', 'sr')}: {attachment_text}

{get_text('press_start_for_tasks', 'sr')}"""
                        
                        # Send notification message
                        await self.application.bot.send_message(
                            chat_id=assignee_id,
                            text=notification_text
                        )
                        
                        # Send attachments as media group
                        if attachments:
                            from telegram import InputMediaPhoto, InputMediaVideo
                            
                            media_group = []
                            documents = []
                            
                            for idx, attachment in enumerate(attachments):
                                file_id = attachment.get('file_id')
                                file_type = attachment.get('type', 'photo')
                                
                                caption = f"📎 {attachment_count} {get_text('file' if attachment_count == 1 else 'files', 'sr')}" if idx == 0 else None
                                
                                if file_type == 'photo':
                                    media_group.append(InputMediaPhoto(media=file_id, caption=caption))
                                elif file_type == 'video':
                                    media_group.append(InputMediaVideo(media=file_id, caption=caption))
                                elif file_type == 'document':
                                    documents.append(file_id)
                            
                            # Send media group (photos/videos together)
                            if media_group:
                                try:
                                    await self.application.bot.send_media_group(
                                        chat_id=assignee_id,
                                        media=media_group
                                    )
                                except Exception as e:
                                    print(f"❌ Failed to send media group: {e}")
                            
                            # Send documents individually
                            for idx, doc_id in enumerate(documents, 1):
                                try:
                                    await self.application.bot.send_document(
                                        chat_id=assignee_id,
                                        document=doc_id,
                                        caption=get_text('document_num', 'sr').format(current=idx, total=len(documents))
                                    )
                                except Exception as e:
                                    print(f"❌ Failed to send document {idx}: {e}")
                    except Exception as e:
                        print(f"Failed to send notification: {e}")
                    
                    await query.answer(get_text('kitchen_task_success', lang), show_alert=True)
                    
                    attachment_text = f"{attachment_count} {get_text('file' if attachment_count == 1 else 'files', lang)}" if attachment_count > 0 else get_text('without_attachments', lang)
                    
                    text = f"{get_text('kitchen_task_success', lang)}\n\n"
                    text += f"{get_text('worker_label', lang)}: {data.get('assignee_name', '')}\n"
                    text += f"📝 {get_text('task_order', lang)}: {data.get('description', '')[:50]}...\n" if len(data.get('description', '')) > 50 else f"📝 {get_text('task_order', lang)}: {data.get('description', '')}\n"
                    text += f"⏰ {get_text('deadline_label', lang)}: {data.get('due_date', '')} {data.get('due_time', '')}\n"
                    text += f"📎 {get_text('attachments', lang)}: {attachment_text}\n"
                    text += f"\n{get_text('notification_sent_to_employee', lang)}"
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('new_assignment_btn', lang), callback_data="emp_assign_kitchen")],
                        [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('error_assigning_task', lang), show_alert=True)
                
                # Clean up
                context.user_data.pop('restaurant_assign', None)
                context.user_data.pop('awaiting_restaurant_attachment', None)
            
            # ==================== Laundry Task Handlers for Workers ====================
            
            # View my laundry tasks
            elif query.data == "my_laundry_tasks":
                from database import get_pending_laundry_tasks
                
                lang = get_user_language(telegram_user_id, self.db)
                telegram_user_id = query.from_user.id
                tasks = get_pending_laundry_tasks(self.db, telegram_user_id)
                
                if not tasks:
                    text = f"{get_text('my_tasks_laundry_title', lang)}\n\n"
                    text += get_text('no_pending_laundry_tasks', lang)
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                    return
                
                text = f"{get_text('my_tasks_laundry_title', lang)} ({len(tasks)})\n\n"
                
                keyboard = []
                for task in tasks:
                    task_id, room_id, room_number, floor, description, due_date, due_time, proof_req, assigned_by_name, assigned_at, status = task
                    status_icon = "🔄" if status == "Accepted" else "📥"
                    # Show description preview instead of room
                    desc_preview = description[:20] + "..." if len(description) > 20 else description
                    keyboard.append([InlineKeyboardButton(
                        f"{status_icon} {desc_preview} - {due_date}",
                        callback_data=f"laundry_task_{task_id}"
                    )])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # View laundry task details
            elif query.data.startswith("laundry_task_"):
                from database import get_laundry_task_by_id
                
                task_id = int(query.data.replace("laundry_task_", ""))
                task = get_laundry_task_by_id(self.db, task_id)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not task:
                    await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    return
                
                status_map = {'Pending': get_text('task_status_pending', lang), 'Accepted': get_text('task_status_accepted', lang), 'Completed': get_text('task_status_completed', lang)}
                
                text = f"🧺 {get_text('task', lang)} #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"📋 {get_text('task_order', lang)}:\n{task['description']}\n\n"
                text += f"⏰ {get_text('deadline_label', lang)}: {task['due_date']} {task['due_time']}\n"
                text += f"📊 {get_text('status', lang)}: {status_map.get(task['status'], task['status'])}\n"
                text += f"👤 {get_text('assigned_by', lang)}: {task['assigned_by_name']}\n"
                text += f"📅 {get_text('assigned_at', lang)}: {task['assigned_at']}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = []
                if task['status'] == 'Pending':
                    keyboard.append([InlineKeyboardButton(get_text('accept_task_btn', lang), callback_data=f"laundry_accept_{task_id}")])
                elif task['status'] == 'Accepted':
                    keyboard.append([InlineKeyboardButton(get_text('report_completion_btn', lang), callback_data=f"laundry_complete_{task_id}")])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="my_laundry_tasks")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Accept laundry task
            elif query.data.startswith("laundry_accept_"):
                from database import accept_laundry_task, get_laundry_task_by_id
                
                lang = get_user_language(telegram_user_id, self.db)
                task_id = int(query.data.replace("laundry_accept_", ""))
                
                # Check current task status
                task = get_laundry_task_by_id(self.db, task_id)
                if not task:
                    try:
                        await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    except:
                        pass
                    return
                
                if task['status'] == 'Accepted':
                    try:
                        await query.answer(get_text('already_accepted_task', lang), show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                elif task['status'] == 'Completed':
                    try:
                        await query.answer(get_text('already_completed_task', lang), show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                elif task['status'] != 'Pending':
                    try:
                        await query.answer(get_text('task_already_status', lang).format(status=task['status']), show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                
                if accept_laundry_task(self.db, task_id):
                    # Log action with audit system
                    employee = self.db.check_employee_exists(telegram_user_id)
                    if employee:
                        employee_id, name, department, work_role, gmail, whatsapp = employee
                        try:
                            event_logger = get_event_logger()
                            event_logger.log_task_accepted(
                                user_id=telegram_user_id,
                                user_name=name,
                                task_id=task_id,
                                department=department,
                                employee_id=employee_id,
                                before_status="Pending"
                            )
                        except Exception as log_error:
                            print(f"Event logging error: {log_error}")
                    
                    try:
                        await query.answer(get_text('task_accepted_success', lang), show_alert=True)
                    except:
                        pass
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                else:
                    try:
                        await query.answer(get_text('error_accepting_task', lang), show_alert=True)
                    except:
                        pass
            
            # Complete laundry task - start report flow (notes first, then media)
            elif query.data.startswith("laundry_complete_"):
                task_id = int(query.data.replace("laundry_complete_", ""))
                
                from database import get_laundry_task_by_id
                task = get_laundry_task_by_id(self.db, task_id)
                
                if not task:
                    await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    return
                
                context.user_data['laundry_report'] = {
                    'task_id': task_id, 
                    'step': 'notes',
                    'task': task
                }
                
                task_desc = task['description'][:50] + "..." if len(task['description']) > 50 else task['description']
                text = f"{get_text('task_report_title_laundry', lang)} #{task_id}\n\n"
                text += f"📋 {get_text('task_order', lang)}: {task_desc}\n"
                text += "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('task_report_step_notes', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"✍️ {get_text('enter_task_notes', lang)}\n"
                text += get_text('laundry_task_notes_example', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('skip_notes', lang), callback_data=f"laundry_skip_notes_{task_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"laundry_task_{task_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Skip notes and go to media
            elif query.data.startswith("laundry_skip_notes_"):
                task_id = int(query.data.replace("laundry_skip_notes_", ""))
                lang = get_user_language(query.from_user.id, self.db)
                
                context.user_data['laundry_report'] = context.user_data.get('laundry_report', {})
                context.user_data['laundry_report']['task_id'] = task_id
                context.user_data['laundry_report']['notes'] = ''
                context.user_data['laundry_report']['step'] = 'media'
                context.user_data['awaiting_laundry_report_media'] = task_id
                
                from database import get_laundry_task_by_id
                task = get_laundry_task_by_id(self.db, task_id)
                
                text = f"{get_text('task_report_title_laundry', lang)} #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('task_report_step_media', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                if task and task.get('proof_required'):
                    text += f"{get_text('proof_required_warning', lang)}\n\n"
                else:
                    text += get_text('attach_proof_text', lang) + "\n"
                
                keyboard = [
                    [InlineKeyboardButton(get_text('finish_without_proof', lang), callback_data=f"laundry_finish_nophoto_{task_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"laundry_task_{task_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finish laundry task without photo
            elif query.data.startswith("laundry_finish_nophoto_"):
                from database import complete_laundry_task, get_laundry_task_by_id
                
                task_id = int(query.data.replace("laundry_finish_nophoto_", ""))
                lang = get_user_language(query.from_user.id, self.db)
                
                # Get report notes if available
                report_notes = context.user_data.get('laundry_report', {}).get('notes', '')
                
                if complete_laundry_task(self.db, task_id, None, report_notes):
                    task = get_laundry_task_by_id(self.db, task_id)
                    
                    # Get reporter info
                    telegram_user_id = query.from_user.id
                    reporter_info = self.db.get_employee_info(telegram_user_id)
                    reporter_name = reporter_info['name'] if reporter_info else task['assignee_name']
                    
                    # Notify assigner (always in Serbian for admin)
                    try:
                        notification_text = f"""{get_text('laundry_task_completed', 'sr')}

📋 {get_text('task_order', 'sr')}: {task['description'][:100]}...
{get_text('completed_by_label', 'sr')}: {reporter_name}
{get_text('time_label', 'sr')}: {task['completed_at']}"""
                        
                        if report_notes:
                            notification_text += f"\n\n{get_text('report_label', 'sr')}:\n{report_notes}"
                        
                        notification_text += f"\n\n{get_text('proof_label', 'sr')}: {get_text('no_proof_attached', 'sr')}"
                        
                        await self.application.bot.send_message(
                            chat_id=task['assigned_by'],
                            text=notification_text
                        )
                    except Exception as e:
                        print(f"Failed to send completion notification: {e}")
                    
                    await query.answer(get_text('task_completed_msg', lang), show_alert=True)
                    
                    task_desc = task['description'][:50] + "..." if len(task['description']) > 50 else task['description']
                    text = f"{get_text('task_completed_msg', lang)}\n\n"
                    text += f"📋 {get_text('task_order', lang)}: {task_desc}\n"
                    if report_notes:
                        report_short = report_notes[:50] + "..." if len(report_notes) > 50 else report_notes
                        text += f"{get_text('report_label', lang)}: {report_short}\n"
                    text += f"🕐 {get_text('completed_at', lang)}: {task['completed_at']}"
                    
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="my_laundry_tasks")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('error_completing_task', lang), show_alert=True)
                
                context.user_data.pop('awaiting_laundry_photo', None)
                context.user_data.pop('awaiting_laundry_report_media', None)
                context.user_data.pop('laundry_report', None)
            
            # ==================== Restaurant Task Handlers for Workers ====================
            
            # View my restaurant tasks
            elif query.data == "my_restaurant_tasks":
                from database import get_restaurant_tasks_by_assignee
                
                telegram_user_id = query.from_user.id
                lang = get_user_language(telegram_user_id, self.db)
                tasks = get_restaurant_tasks_by_assignee(self.db, telegram_user_id)
                
                if not tasks:
                    text = f"{get_text('my_tasks_kitchen_title', lang)}\n\n"
                    text += get_text('no_pending_kitchen_tasks', lang)
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                    return
                
                text = f"{get_text('my_tasks_kitchen_title', lang)} ({len(tasks)})\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = []
                for task in tasks:
                    task_id, description, due_date, due_time, status, assigned_at, accepted_at, completed_at, assigned_by_name = task
                    
                    status_emoji = {"Pending": "📋", "Accepted": "🔄"}.get(status, "❓")
                    
                    short_desc = description[:30] + "..." if len(description) > 30 else description
                    button_text = f"{status_emoji} #{task_id} - {short_desc}"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"rest_task_{task_id}")])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # View specific restaurant task
            elif query.data.startswith("rest_task_"):
                task_id = int(query.data.replace("rest_task_", ""))
                lang = get_user_language(query.from_user.id, self.db)
                
                from database import get_restaurant_task_by_id
                task = get_restaurant_task_by_id(self.db, task_id)
                
                if not task:
                    await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    return
                
                status_emoji = {"Pending": "📋", "Accepted": "🔄", "Completed": "✅"}.get(task['status'], "❓")
                text = f"{status_emoji} {get_text('task', lang)} #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"👤 {get_text('assigned_by', lang)}: {task['assigned_by_name']}\n"
                text += f"📅 {get_text('assigned_at', lang)}: {task['assigned_at']}\n\n"
                text += f"📝 {get_text('description', lang)}:\n{task['description']}\n"
                text += f"\n⏰ {get_text('deadline_label', lang)}: {task['due_date']} {task['due_time']}\n"
                
                if task.get('attachment_file_id'):
                    text += f"📎 {get_text('attachment', lang)}: {task['attachment_type']}\n"
                
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = []
                if task['status'] == 'Pending':
                    keyboard.append([InlineKeyboardButton(get_text('accept_task_btn', lang), callback_data=f"rest_accept_{task_id}")])
                elif task['status'] == 'Accepted':
                    keyboard.append([InlineKeyboardButton(get_text('complete_task_btn', lang), callback_data=f"rest_complete_{task_id}")])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="my_restaurant_tasks")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Accept restaurant task
            elif query.data.startswith("rest_accept_"):
                task_id = int(query.data.replace("rest_accept_", ""))
                lang = get_user_language(query.from_user.id, self.db)
                
                from database import accept_restaurant_task, get_restaurant_task_by_id
                
                # Check current task status
                task = get_restaurant_task_by_id(self.db, task_id)
                if not task:
                    try:
                        await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    except:
                        pass
                    return
                
                if task['status'] == 'Accepted':
                    try:
                        await query.answer(get_text('already_accepted_task', lang), show_alert=True)
                    except:
                        pass
                    # Return to main menu
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                elif task['status'] == 'Completed':
                    try:
                        await query.answer(get_text('already_completed_task', lang), show_alert=True)
                    except:
                        pass
                    # Return to main menu
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                elif task['status'] != 'Pending':
                    try:
                        await query.answer(get_text('task_already_status', lang).format(status=task['status']), show_alert=True)
                    except:
                        pass
                    # Return to main menu
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                    return
                
                if accept_restaurant_task(self.db, task_id):
                    try:
                        await query.answer(get_text('task_accepted_success', lang), show_alert=True)
                    except:
                        pass
                    
                    # Return to main menu instead of task view
                    context.user_data['callback_query_data'] = 'emp_work_menu'
                    await self.button_handler(update, context)
                else:
                    try:
                        await query.answer(get_text('error_accepting_task', lang), show_alert=True)
                    except:
                        pass
            
            # Complete restaurant task - start report flow
            elif query.data.startswith("rest_complete_"):
                task_id = int(query.data.replace("rest_complete_", ""))
                lang = get_user_language(query.from_user.id, self.db)
                
                from database import get_restaurant_task_by_id
                task = get_restaurant_task_by_id(self.db, task_id)
                
                if not task:
                    await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    return
                
                context.user_data['restaurant_report'] = {
                    'task_id': task_id,
                    'step': 'notes',
                    'task': task
                }
                
                task_desc = task['description'][:50] + "..." if len(task['description']) > 50 else task['description']
                text = f"{get_text('task_report_title', lang)} #{task_id}\n\n"
                text += f"📝 {get_text('task', lang)}: {task_desc}\n"
                text += "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('task_report_step_notes', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('enter_task_notes', lang)}\n"
                text += get_text('restaurant_task_notes_example', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('skip_notes', lang), callback_data=f"rest_skip_notes_{task_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"rest_task_{task_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Skip notes and go to media
            elif query.data.startswith("rest_skip_notes_"):
                task_id = int(query.data.replace("rest_skip_notes_", ""))
                lang = get_user_language(query.from_user.id, self.db)
                
                context.user_data['restaurant_report'] = context.user_data.get('restaurant_report', {})
                context.user_data['restaurant_report']['task_id'] = task_id
                context.user_data['restaurant_report']['notes'] = ''
                context.user_data['restaurant_report']['step'] = 'media'
                context.user_data['awaiting_restaurant_report_media'] = task_id
                
                from database import get_restaurant_task_by_id
                task = get_restaurant_task_by_id(self.db, task_id)
                
                text = f"{get_text('task_report_title', lang)} #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('task_report_step_media', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                if task and task.get('proof_required'):
                    text += f"{get_text('proof_required_warning', lang)}\n\n"
                else:
                    text += get_text('attach_proof_text', lang) + "\n"
                
                keyboard = [
                    [InlineKeyboardButton(get_text('finish_without_proof', lang), callback_data=f"rest_finish_nophoto_{task_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"rest_task_{task_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finish restaurant task without photo
            elif query.data.startswith("rest_finish_nophoto_"):
                from database import complete_restaurant_task, get_restaurant_task_by_id
                
                task_id = int(query.data.replace("rest_finish_nophoto_", ""))
                lang = get_user_language(query.from_user.id, self.db)
                report_notes = context.user_data.get('restaurant_report', {}).get('notes', '')
                
                if complete_restaurant_task(self.db, task_id, None, report_notes):
                    task = get_restaurant_task_by_id(self.db, task_id)
                    
                    telegram_user_id = query.from_user.id
                    reporter_info = self.db.get_employee_info(telegram_user_id)
                    reporter_name = reporter_info['name'] if reporter_info else task['assignee_name']
                    
                    # Notify assigner
                    try:
                        notification_text = f"""{get_text('restaurant_task_completed', 'sr')}

📝 {get_text('task', 'sr')}: {task['description'][:100]}...
{get_text('completed_by_label', 'sr')}: {reporter_name}
{get_text('time_label', 'sr')}: {task['completed_at']}"""
                        
                        if report_notes:
                            notification_text += f"\n\n{get_text('report_label', 'sr')}:\n{report_notes}"
                        
                        notification_text += f"\n\n{get_text('proof_label', 'sr')}: {get_text('no_proof_attached', 'sr')}"
                        
                        await self.application.bot.send_message(
                            chat_id=task['assigned_by'],
                            text=notification_text
                        )
                    except Exception as e:
                        print(f"Failed to send completion notification: {e}")
                    
                    await query.answer(get_text('task_completed_success', lang), show_alert=True)
                    
                    text = f"{get_text('task_completed_success', lang)}\n\n"
                    text += f"📝 {get_text('task', lang)}: {task['description'][:50]}...\n" if len(task['description']) > 50 else f"📝 {get_text('task', lang)}: {task['description']}\n"
                    text += f"{get_text('completed_label', lang)}: {task['completed_at']}\n"
                    
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="my_restaurant_tasks")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer(get_text('error_completing_task', lang), show_alert=True)
                
                context.user_data.pop('awaiting_restaurant_report_media', None)
                context.user_data.pop('restaurant_report', None)
            
            # Restaurant Dashboard - for managers and receptionists
            elif query.data == "restaurant_dashboard":
                from database import get_restaurant_dashboard_view
                
                dashboard_text = get_restaurant_dashboard_view(self.db)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('tasks_pending_btn', lang), callback_data="rest_dash_pending")],
                    [InlineKeyboardButton(get_text('tasks_in_progress_btn', lang), callback_data="rest_dash_accepted")],
                    [InlineKeyboardButton(get_text('tasks_completed_btn', lang), callback_data="rest_dash_completed")],
                    [InlineKeyboardButton(get_text('refresh_btn', lang), callback_data="restaurant_dashboard")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="back_to_admin")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(dashboard_text, reply_markup=reply_markup)
            
            # ==================== Assignment Management ====================
            
            # Assignment Management - Main Menu
            elif query.data == "manage_assignments":
                from database import get_laundry_stats
                
                stats = get_laundry_stats(self.db)
                
                text = f"{get_text('manage_tasks_title', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('laundry_tasks_btn', lang)}:\n"
                text += f"   {get_text('task_status_pending_label', lang)}: {stats['Pending']}\n"
                text += f"   {get_text('task_status_in_progress_label', lang)}: {stats['Accepted']}\n"
                text += f"   {get_text('task_status_completed_label', lang)}: {stats['Completed']}\n"
                text += f"   📊 {get_text('total', lang)}: {stats['total']}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += get_text('select_category', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('laundry_tasks_btn', lang), callback_data="manage_laundry_tasks")],
                    [InlineKeyboardButton(get_text('kitchen_tasks_btn', lang), callback_data="manage_kitchen_tasks")],
                    [InlineKeyboardButton(get_text('driver_tasks_btn', lang), callback_data="manage_driver_tasks")],
                    [InlineKeyboardButton(get_text('accounting_tasks_btn', lang), callback_data="manage_accounting_tasks")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Assignment Management - Laundry Tasks
            elif query.data == "manage_laundry_tasks":
                lang = get_user_language(telegram_user_id, self.db)
                text = f"🧺 {get_text('laundry_task_management', lang)}\n\n"
                text += get_text('select_filter', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"📥 {get_text('pending', lang)}", callback_data="laundry_filter_Pending"),
                        InlineKeyboardButton(f"🔄 {get_text('in_progress', lang)}", callback_data="laundry_filter_Accepted")
                    ],
                    [
                        InlineKeyboardButton(f"✅ {get_text('completed', lang)}", callback_data="laundry_filter_Completed"),
                        InlineKeyboardButton(f"📊 {get_text('all', lang)}", callback_data="laundry_filter_all")
                    ],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="manage_assignments")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Assignment Management - Laundry Filter
            elif query.data.startswith("laundry_filter_"):
                from database import get_all_laundry_tasks
                
                lang = get_user_language(telegram_user_id, self.db)
                filter_status = query.data.replace("laundry_filter_", "")
                
                if filter_status == "all":
                    tasks = get_all_laundry_tasks(self.db)
                    filter_text = get_text('all_tasks', lang)
                else:
                    tasks = get_all_laundry_tasks(self.db, status=filter_status)
                    status_map = {'Pending': 'pending', 'Accepted': 'in_progress', 'Completed': 'completed'}
                    filter_text = get_text(status_map.get(filter_status, 'all'), lang)
                
                text = f"🧺 {get_text('laundry_tasks', lang)} - {filter_text}\n\n"
                
                if not tasks:
                    text += f"✅ {get_text('no_tasks_in_category', lang)}"
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="manage_laundry_tasks")]]
                else:
                    text += get_text('found_tasks', lang).format(len(tasks)) + "\n\n"
                    
                    keyboard = []
                    for task in tasks[:15]:  # Limit to 15 tasks for UI
                        task_id, room_number, floor, assignee_name, description, due_date, due_time, status, assigned_by_name, assigned_at, accepted_at, completed_at, proof_path, report_notes = task
                        
                        status_icon = "📥" if status == "Pending" else "🔄" if status == "Accepted" else "✅"
                        desc_preview = description[:15] + "..." if len(description) > 15 else description
                        
                        keyboard.append([InlineKeyboardButton(
                            f"{status_icon} {assignee_name}: {desc_preview}",
                            callback_data=f"view_laundry_{task_id}"
                        )])
                    
                    if len(tasks) > 15:
                        text += f"\n⚠️ {get_text('showing_first_15', lang).format(len(tasks))}"
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="manage_laundry_tasks")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Assignment Management - View Laundry Task Detail
            elif query.data.startswith("view_laundry_"):
                from database import get_laundry_task_by_id
                
                task_id = int(query.data.replace("view_laundry_", ""))
                task = get_laundry_task_by_id(self.db, task_id)
                
                if not task:
                    await query.answer(f"❌ {get_text('task_not_found', lang)}", show_alert=True)
                    return
                
                status_map = {'Pending': get_text('task_status_pending_label', lang), 'Accepted': get_text('task_status_in_progress_label', lang), 'Completed': get_text('task_status_completed_label', lang)}
                
                text = f"{get_text('view_task_details_title', lang)} #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"📝 {get_text('task_order', lang)}:\n{task['description']}\n\n"
                text += f"👤 {get_text('assigned_at', lang)}: {task['assignee_name']}\n"
                text += f"⏰ {get_text('deadline_label', lang)}: {task['due_date']} {task['due_time']}\n"
                text += f"📊 {get_text('status', lang)}: {status_map.get(task['status'], task['status'])}\n"
                text += f"👤 {get_text('assigned_by', lang)}: {task['assigned_by_name']}\n"
                text += f"📅 {get_text('assigned_at', lang)}: {task['assigned_at']}\n"
                
                if task['accepted_at']:
                    text += f"{get_text('accepted_label', lang)}: {task['accepted_at']}\n"
                
                if task['completed_at']:
                    text += f"{get_text('finished_label', lang)}: {task['completed_at']}\n"
                
                if task['report_notes']:
                    text += f"\n📋 {get_text('report_label', lang)}:\n{task['report_notes']}\n"
                
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = []
                
                # Show proof if available
                if task['proof_path']:
                    keyboard.append([InlineKeyboardButton(get_text('view_proof_btn', lang), callback_data=f"view_laundry_proof_{task_id}")])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data=f"laundry_filter_{task['status']}")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # View Laundry Task Proof
            elif query.data.startswith("view_laundry_proof_"):
                from database import get_laundry_task_by_id
                
                task_id = int(query.data.replace("view_laundry_proof_", ""))
                task = get_laundry_task_by_id(self.db, task_id)
                
                proof_path = task.get('proof_path') if task else None
                if proof_path and len(proof_path.strip()) > 0:
                    try:
                        caption = f"📸 {get_text('proof_label', lang)} #{task_id}\n\n"
                        caption += f"{get_text('completed_by_label', lang)}: {task['assignee_name']}\n"
                        caption += f"{get_text('time_label', lang)}: {task['completed_at']}"
                        
                        if task['report_notes']:
                            caption += f"\n\n📋 {get_text('report_label', lang)}:\n{task['report_notes']}"
                        
                        # Try to send as photo first, then as document
                        try:
                            await self.application.bot.send_photo(
                                chat_id=query.from_user.id,
                                photo=proof_path,
                                caption=caption
                            )
                        except:
                            await self.application.bot.send_document(
                                chat_id=query.from_user.id,
                                document=proof_path,
                                caption=caption
                            )
                        
                        await query.answer("📸 Dokaz poslat", show_alert=False)
                    except Exception as e:
                        print(f"Error sending laundry proof: {e}")
                        await query.answer("❌ Greška pri slanju dokaza", show_alert=True)
                else:
                    await query.answer("❌ Dokaz nije dostupan", show_alert=True)
            
            # Placeholder for other assignment types
            elif query.data in ["manage_kitchen_tasks", "manage_driver_tasks", "manage_accounting_tasks"]:
                text = "🚧 Ova funkcija je u razvoju.\n\n"
                text += "Biće dostupna uskoro!"
                
                keyboard = [[InlineKeyboardButton("🔙 Nazad", callback_data="manage_assignments")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ==================== Cleaning Handlers ====================
            
            # Cleaning - Guest rooms (select floor)
            elif query.data == "clean_guest_rooms":
                from database import get_floors_for_cleaning, get_today_clean_records
                
                floors = get_floors_for_cleaning(self.db, 'guest')
                today_records = get_today_clean_records(self.db, 'guest_room')
                cleaned_rooms = set(r['room_number'] for r in today_records)
                
                if not floors:
                    await query.answer("❌ Nema dostupnih soba", show_alert=True)
                    return
                
                text = "🏨 Čišćenje soba za goste\n\n"
                text += f"📅 Danas očišćeno: {len(cleaned_rooms)} soba\n\n"
                text += "Izaberite sprat:"
                
                keyboard = []
                row = []
                for floor in floors:
                    row.append(InlineKeyboardButton(f"🏢 Sprat {floor}", callback_data=f"clean_guest_floor_{floor}"))
                    if len(row) == 3:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_cleaning")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            elif query.data == "clean_staff_rooms" or query.data.startswith("clean_staff_rooms_page_"):
                from database import get_all_hotel_rooms, get_today_clean_records, get_room_cleaned_today
                
                rooms = get_all_hotel_rooms(self.db)
                today_records = get_today_clean_records(self.db, 'staff_room')
                cleaned_rooms = set(r['room_number'] for r in today_records)
                
                if not rooms:
                    await query.answer("❌ Nema dostupnih prostorija", show_alert=True)
                    return
                
                page = 1
                if query.data.startswith("clean_staff_rooms_page_"):
                    page = int(query.data.replace("clean_staff_rooms_page_", ""))
                
                cleaned_count = len([r for r in rooms if r['name'] in cleaned_rooms])
                
                items_per_page = 18
                total_pages = (len(rooms) + items_per_page - 1) // items_per_page
                page = max(1, min(page, total_pages))
                
                start_idx = (page - 1) * items_per_page
                end_idx = min(start_idx + items_per_page, len(rooms))
                page_rooms = rooms[start_idx:end_idx]
                
                text = "🏢 Čišćenje prostorija za osoblje\n\n"
                text += f"📅 Danas očišćeno: {cleaned_count}/{len(rooms)} prostorija\n"
                text += f"📄 Stranica {page}/{total_pages}\n"
                text += "✅ = Očišćeno | 🔲 = Nije očišćeno\n\n"
                text += "Izaberite prostoriju:"
                
                keyboard = []
                row = []
                for room in page_rooms:
                    is_cleaned = room['name'] in cleaned_rooms
                    status_icon = "✅" if is_cleaned else "🔲"
                    short_name = room['name'][:12] + "..." if len(room['name']) > 12 else room['name']
                    row.append(InlineKeyboardButton(
                        f"{status_icon} {short_name}", 
                        callback_data=f"clean_room_staff_{room['id']}"
                    ))
                    if len(row) == 3:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                
                nav_row = []
                if page > 1:
                    nav_row.append(InlineKeyboardButton("◀️ Prethodna", callback_data=f"clean_staff_rooms_page_{page-1}"))
                if page < total_pages:
                    nav_row.append(InlineKeyboardButton("Sledeća ▶️", callback_data=f"clean_staff_rooms_page_{page+1}"))
                if nav_row:
                    keyboard.append(nav_row)
                
                keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_cleaning")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Cleaning - Guest floor rooms
            elif query.data.startswith("clean_guest_floor_"):
                floor = int(query.data.replace("clean_guest_floor_", ""))
                from database import get_rooms_by_floor_and_type, get_room_cleaned_today
                
                rooms = get_rooms_by_floor_and_type(self.db, floor)
                
                if not rooms:
                    await query.answer("❌ Nema soba na ovom spratu", show_alert=True)
                    return
                
                text = f"🏢 Sprat {floor} - Sobe za goste\n\n"
                text += "✅ = Očišćeno danas | 🔲 = Nije očišćeno\n\n"
                text += "Izaberite sobu za čišćenje:"
                
                keyboard = []
                row = []
                for room in rooms:
                    is_cleaned = get_room_cleaned_today(self.db, room['id'], 'guest_room')
                    status_icon = "✅" if is_cleaned else "🔲"
                    row.append(InlineKeyboardButton(
                        f"{status_icon} {room['room_number']}", 
                        callback_data=f"clean_room_guest_{room['id']}"
                    ))
                    if len(row) == 4:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data="clean_guest_rooms")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Cleaning - Staff floor rooms
            elif query.data.startswith("clean_staff_floor_"):
                floor = int(query.data.replace("clean_staff_floor_", ""))
                from database import get_rooms_by_floor_and_type, get_room_cleaned_today
                
                rooms = get_rooms_by_floor_and_type(self.db, floor)
                
                if not rooms:
                    await query.answer("❌ Nema prostorija na ovom spratu", show_alert=True)
                    return
                
                text = f"🏢 Sprat {floor} - Prostorije za osoblje\n\n"
                text += "✅ = Očišćeno danas | 🔲 = Nije očišćeno\n\n"
                text += "Izaberite prostoriju za čišćenje:"
                
                keyboard = []
                row = []
                for room in rooms:
                    is_cleaned = get_room_cleaned_today(self.db, room['id'], 'staff_room')
                    status_icon = "✅" if is_cleaned else "🔲"
                    row.append(InlineKeyboardButton(
                        f"{status_icon} {room['room_number']}", 
                        callback_data=f"clean_room_staff_{room['id']}"
                    ))
                    if len(row) == 4:
                        keyboard.append(row)
                        row = []
                if row:
                    keyboard.append(row)
                
                keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data="clean_staff_rooms")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Cleaning - Report for guest room
            elif query.data.startswith("clean_room_guest_"):
                room_id = int(query.data.replace("clean_room_guest_", ""))
                from database import get_customer_room_by_id, get_room_cleaned_today
                
                room = get_customer_room_by_id(self.db, room_id)
                if not room:
                    await query.answer("❌ Soba ne postoji", show_alert=True)
                    return
                
                is_cleaned = get_room_cleaned_today(self.db, room_id, 'guest_room')
                
                context.user_data['clean_room_id'] = room_id
                context.user_data['clean_room_number'] = room['room_number']
                context.user_data['clean_room_floor'] = room['floor']
                context.user_data['clean_type'] = 'guest_room'
                
                cleaned_status = "✅ Već očišćeno danas" if is_cleaned else "🔲 Nije očišćeno"
                
                text = f"🏨 Soba {room['room_number']}\n\n"
                text += f"🏢 Sprat: {room['floor']}\n"
                text += f"📋 Tip: {room.get('room_type', 'Standard')}\n"
                text += f"📊 Status: {cleaned_status}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += "📸 Pošaljite fotografiju kao dokaz čišćenja,\n"
                text += "zatim pritisnite 'Potvrdi čišćenje'.\n\n"
                text += "Ili pritisnite 'Bez dokaza' za prijavu bez slike."
                
                keyboard = [
                    [InlineKeyboardButton("✅ Potvrdi čišćenje", callback_data=f"clean_confirm_guest_{room_id}")],
                    [InlineKeyboardButton("📷 Bez dokaza", callback_data=f"clean_nodoc_guest_{room_id}")],
                    [InlineKeyboardButton("🔙 Nazad", callback_data=f"clean_guest_floor_{room['floor']}")]
                ]
                
                context.user_data['awaiting_clean_photo'] = True
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Cleaning - Report for staff room (tbl_hotel_rooms)
            elif query.data.startswith("clean_room_staff_"):
                room_id = int(query.data.replace("clean_room_staff_", ""))
                from database import get_hotel_room_by_id_for_clean, get_room_cleaned_today
                
                room = get_hotel_room_by_id_for_clean(self.db, room_id)
                if not room:
                    await query.answer("❌ Prostorija ne postoji", show_alert=True)
                    return
                
                # Check if cleaned today using room name
                is_cleaned = get_room_cleaned_today(self.db, room_id, 'staff_room')
                
                context.user_data['clean_room_id'] = room_id
                context.user_data['clean_room_number'] = room['name']
                context.user_data['clean_room_floor'] = 0
                context.user_data['clean_type'] = 'staff_room'
                
                cleaned_status = "✅ Već očišćeno danas" if is_cleaned else "🔲 Nije očišćeno"
                
                text = f"🏢 Prostorija: {room['name']}\n\n"
                text += f"📋 Opis: {room.get('description', '-')}\n"
                text += f"📊 Status: {cleaned_status}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += "📸 Pošaljite fotografiju kao dokaz čišćenja,\n"
                text += "zatim pritisnite 'Potvrdi čišćenje'.\n\n"
                text += "Ili pritisnite 'Bez dokaza' za prijavu bez slike."
                
                keyboard = [
                    [InlineKeyboardButton("✅ Potvrdi čišćenje", callback_data=f"clean_confirm_staff_{room_id}")],
                    [InlineKeyboardButton("📷 Bez dokaza", callback_data=f"clean_nodoc_staff_{room_id}")],
                    [InlineKeyboardButton("🔙 Nazad", callback_data="clean_staff_rooms")]
                ]
                
                context.user_data['awaiting_clean_photo'] = True
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Cleaning - Confirm with proof (guest)
            elif query.data.startswith("clean_confirm_guest_"):
                room_id = int(query.data.replace("clean_confirm_guest_", ""))
                from database import create_clean_record, get_customer_room_by_id
                
                room = get_customer_room_by_id(self.db, room_id)
                room_number = room['room_number'] if room else context.user_data.get('clean_room_number', 'Unknown')
                floor = 0
                
                telegram_user_id = query.from_user.id
                employee = self.db.check_employee_exists(telegram_user_id)
                cleaner_name = employee[1] if employee else "Unknown"
                
                photo = context.user_data.get('clean_photo')
                video = context.user_data.get('clean_video')
                
                record_id = create_clean_record(
                    self.db, room_id, room_number, floor, 'guest_room',
                    'Completed', 'Good', '', photo, video,
                    telegram_user_id, cleaner_name
                )
                
                if record_id:
                    from datetime import datetime
                    now = datetime.now()
                    
                    proof_text = "✅ Priložen" if photo or video else "❌ Nije priložen"
                    
                    await query.answer("✅ Čišćenje potvrđeno!", show_alert=True)
                    
                    text = "✅ Čišćenje sobe potvrđeno!\n\n"
                    text += f"🚪 Soba: {room_number}\n"
                    text += f"🏢 Sprat: {floor}\n"
                    text += f"📸 Dokaz: {proof_text}\n"
                    text += f"👤 Očistio: {cleaner_name}\n"
                    text += f"🕐 Vreme: {now.strftime('%d.%m.%Y %H:%M')}"
                    
                    keyboard = [
                        [InlineKeyboardButton("➕ Sledeća soba", callback_data=f"clean_guest_floor_{floor}")],
                        [InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_cleaning")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("❌ Greška pri čuvanju", show_alert=True)
                
                # Clean up
                context.user_data.pop('clean_photo', None)
                context.user_data.pop('clean_video', None)
                context.user_data.pop('awaiting_clean_photo', None)
            
            # Cleaning - Confirm with proof (staff)
            elif query.data.startswith("clean_confirm_staff_"):
                room_id = int(query.data.replace("clean_confirm_staff_", ""))
                from database import create_clean_record, get_hotel_room_by_id_for_clean
                
                room = get_hotel_room_by_id_for_clean(self.db, room_id)
                room_number = room['name'] if room else context.user_data.get('clean_room_number', 'Unknown')
                floor = 0
                
                telegram_user_id = query.from_user.id
                employee = self.db.check_employee_exists(telegram_user_id)
                cleaner_name = employee[1] if employee else "Unknown"
                
                photo = context.user_data.get('clean_photo')
                video = context.user_data.get('clean_video')
                
                record_id = create_clean_record(
                    self.db, room_id, room_number, floor, 'staff_room',
                    'Completed', 'Good', '', photo, video,
                    telegram_user_id, cleaner_name
                )
                
                if record_id:
                    from datetime import datetime
                    now = datetime.now()
                    
                    proof_text = "📸 Priložen" if photo or video else "❌ Nije priložen"
                    
                    await query.answer("✅ Čišćenje potvrđeno!", show_alert=True)
                    
                    text = "✅ Čišćenje prostorije potvrđeno!\n\n"
                    text += f"🚪 Prostorija: {room_number}\n"
                    text += f"📸 Dokaz: {proof_text}\n"
                    text += f"👤 Očistio: {cleaner_name}\n"
                    text += f"🕐 Vreme: {now.strftime('%d.%m.%Y %H:%M')}"
                    
                    keyboard = [
                        [InlineKeyboardButton("➕ Sledeća prostorija", callback_data="clean_staff_rooms")],
                        [InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_cleaning")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("❌ Greška pri čuvanju", show_alert=True)
                
                # Clean up
                context.user_data.pop('clean_photo', None)
                context.user_data.pop('clean_video', None)
                context.user_data.pop('awaiting_clean_photo', None)
            
            # Cleaning - No document (guest)
            elif query.data.startswith("clean_nodoc_guest_"):
                room_id = int(query.data.replace("clean_nodoc_guest_", ""))
                from database import create_clean_record, get_customer_room_by_id
                
                room = get_customer_room_by_id(self.db, room_id)
                room_number = room['room_number'] if room else 'Unknown'
                floor = room['floor'] if room else 0
                
                telegram_user_id = query.from_user.id
                employee = self.db.check_employee_exists(telegram_user_id)
                cleaner_name = employee[1] if employee else "Unknown"
                
                record_id = create_clean_record(
                    self.db, room_id, room_number, floor, 'guest_room',
                    'Completed', 'Good', '', None, None,
                    telegram_user_id, cleaner_name
                )
                
                if record_id:
                    from datetime import datetime
                    now = datetime.now()
                    
                    await query.answer("✅ Čišćenje potvrđeno!", show_alert=True)
                    
                    text = "✅ Čišćenje sobe potvrđeno!\n\n"
                    text += f"🚪 Soba: {room_number}\n"
                    text += f"🏢 Sprat: {floor}\n"
                    text += f"📸 Dokaz: ❌ Nije priložen\n"
                    text += f"👤 Očistio: {cleaner_name}\n"
                    text += f"🕐 Vreme: {now.strftime('%d.%m.%Y %H:%M')}"
                    
                    keyboard = [
                        [InlineKeyboardButton("➕ Sledeća soba", callback_data=f"clean_guest_floor_{floor}")],
                        [InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_cleaning")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("❌ Greška pri čuvanju", show_alert=True)
                
                context.user_data.pop('awaiting_clean_photo', None)
            
            # Cleaning - No document (staff)
            elif query.data.startswith("clean_nodoc_staff_"):
                room_id = int(query.data.replace("clean_nodoc_staff_", ""))
                from database import create_clean_record, get_hotel_room_by_id_for_clean
                
                room = get_hotel_room_by_id_for_clean(self.db, room_id)
                room_number = room['name'] if room else 'Unknown'
                floor = 0
                
                telegram_user_id = query.from_user.id
                employee = self.db.check_employee_exists(telegram_user_id)
                cleaner_name = employee[1] if employee else "Unknown"
                
                record_id = create_clean_record(
                    self.db, room_id, room_number, floor, 'staff_room',
                    'Completed', 'Good', '', None, None,
                    telegram_user_id, cleaner_name
                )
                
                if record_id:
                    from datetime import datetime
                    now = datetime.now()
                    
                    await query.answer("✅ Čišćenje potvrđeno!", show_alert=True)
                    
                    text = "✅ Čišćenje prostorije potvrđeno!\n\n"
                    text += f"🚪 Prostorija: {room_number}\n"
                    text += f"📸 Dokaz: ❌ Nije priložen\n"
                    text += f"👤 Očistio: {cleaner_name}\n"
                    text += f"🕐 Vreme: {now.strftime('%d.%m.%Y %H:%M')}"
                    
                    keyboard = [
                        [InlineKeyboardButton("➕ Sledeća prostorija", callback_data="clean_staff_rooms")],
                        [InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_cleaning")]
                    ]
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("❌ Greška pri čuvanju", show_alert=True)
                
                context.user_data.pop('awaiting_clean_photo', None)
            
            # Cleaning - My stats
            elif query.data == "clean_my_stats":
                from database import get_cleaner_stats
                
                telegram_user_id = query.from_user.id
                employee = self.db.check_employee_exists(telegram_user_id)
                emp_name = employee[1] if employee else "Unknown"
                
                today_stats = get_cleaner_stats(self.db, telegram_user_id, days=1)
                week_stats = get_cleaner_stats(self.db, telegram_user_id, days=7)
                month_stats = get_cleaner_stats(self.db, telegram_user_id, days=30)
                
                text = f"📊 Moj izveštaj - {emp_name}\n\n"
                
                text += "📅 DANAS:\n"
                text += f"   🏨 Sobe za goste: {today_stats.get('guest_room', {}).get('total', 0)}\n"
                text += f"   🏢 Prostorije osoblja: {today_stats.get('staff_room', {}).get('total', 0)}\n"
                text += f"   📊 Ukupno: {today_stats.get('total', 0)}\n\n"
                
                text += "📆 NEDELJA (7 dana):\n"
                text += f"   🏨 Sobe za goste: {week_stats.get('guest_room', {}).get('total', 0)}\n"
                text += f"   🏢 Prostorije osoblja: {week_stats.get('staff_room', {}).get('total', 0)}\n"
                text += f"   📊 Ukupno: {week_stats.get('total', 0)}\n\n"
                
                text += "📅 MESEC (30 dana):\n"
                text += f"   🏨 Sobe za goste: {month_stats.get('guest_room', {}).get('total', 0)}\n"
                text += f"   🏢 Prostorije osoblja: {month_stats.get('staff_room', {}).get('total', 0)}\n"
                text += f"   📊 Ukupno: {month_stats.get('total', 0)}"
                
                keyboard = [[InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_cleaning")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Add new hotel room (MOVED TO ADMIN - admin_hotel_room_add)
            # elif query.data == "hotel_room_add":
            
            # Toggle hotel room state (MOVED TO ADMIN - admin_hotel_room_toggle_)
            # elif query.data.startswith("hotel_room_toggle_"):
            
            # Edit hotel room (MOVED TO ADMIN - admin_hotel_room_edit_)
            # elif query.data.startswith("hotel_room_edit_"):
            
            # Delete hotel room (MOVED TO ADMIN - admin_hotel_room_delete_)
            # elif query.data.startswith("hotel_room_delete_"):
            
            # Employee room detail view - MUST be LAST after all specific emp_room_* handlers
            elif query.data.startswith("emp_room_"):
                from database import get_room_by_id
                
                room_id = int(query.data.replace("emp_room_", ""))
                room = get_room_by_id(self.db, room_id)
                
                lang = get_user_language(query.from_user.id, self.db)
                
                if not room:
                    await query.edit_message_text(f"❌ {get_text('room_not_found', lang)}")
                    return
                
                # Status icons
                active_icon = "✅" if room['is_active'] == 1 else "❌"
                check_icon = "🔴" if str(room['is_check']) == "1" else "🟢"
                ac_icon = "✅" if str(room['AC']) == "1" else "❌"
                tv_icon = "✅" if str(room['TV']) == "1" else "❌"
                toilet_icon = "✅" if str(room['Toilet']) == "1" else "❌"
                remote_icon = "✅" if str(room['Remote_Control']) == "1" else "❌"
                
                total_capacity = room.get('total_capacity', 2)
                current_guests = room.get('current_guests', 0)
                available = total_capacity - current_guests
                percent = int((current_guests / total_capacity * 100)) if total_capacity > 0 else 0
                
                floor = room['id_room'][:-2] if len(room['id_room']) > 2 else "1"
                
                room_info = f"""🚪 Soba {room['id_room']}

📊 STATUS
{get_text('status_label', lang)}: {active_icon} | {get_text('occupancy_label', lang)}: {check_icon}

{get_text('capacity_label', lang)}
{get_text('capacity_info', lang).format(total_capacity=total_capacity, current_guests=current_guests, available=available)}
{get_text('occupancy_percentage', lang).format(percentage=percent)}

{get_text('equipment_label', lang)}
❄️ {get_text('climate', lang)}: {ac_icon} | 📺 {get_text('tv', lang)}: {tv_icon}
🚽 {get_text('toilet', lang)}: {toilet_icon} | 🎮 {get_text('remote', lang)}: {remote_icon}"""
                
                # Employee can manage all room aspects like admin
                toggle_text = get_text('deactivate', lang) if room['is_active'] == 1 else get_text('activate', lang)
                
                keyboard = [
                    [InlineKeyboardButton(toggle_text, callback_data=f"emp_room_toggle_{room_id}")],
                    [InlineKeyboardButton(get_text('check_in_guests', lang), callback_data=f"emp_room_checkin_{room_id}"),
                     InlineKeyboardButton(get_text('check_out_guests', lang), callback_data=f"emp_room_checkout_{room_id}")],
                    [InlineKeyboardButton(get_text('set_capacity', lang), callback_data=f"emp_room_capacity_{room_id}")],
                    [InlineKeyboardButton(f"❄️ {get_text('climate', lang)} {ac_icon}", callback_data=f"emp_room_equip_AC_{room_id}"),
                     InlineKeyboardButton(f"📺 {get_text('tv', lang)} {tv_icon}", callback_data=f"emp_room_equip_TV_{room_id}")],
                    [InlineKeyboardButton(f"🚽 {get_text('toilet', lang)} {toilet_icon}", callback_data=f"emp_room_equip_Toilet_{room_id}"),
                     InlineKeyboardButton(f"🎮 {get_text('remote', lang)} {remote_icon}", callback_data=f"emp_room_equip_Remote_Control_{room_id}")],
                    [InlineKeyboardButton(get_text('back_to_rooms', lang), callback_data=f"emp_room_floor_{floor}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(room_info, reply_markup=reply_markup)
            
            # ========== Employee Menu Handler ==========
            # My Tasks (& New Task Notification)
            elif query.data == "emp_my_tasks" or query.data == "emp_notifications" or query.data.startswith("emp_tasks_page_"):
                telegram_user_id = update.effective_user.id
                employee = self.db.check_employee_exists(telegram_user_id)
                
                if not employee:
                    await query.edit_message_text("❌ Molimo koristite /start da se prvo registrujete.")
                    return
                
                employee_id, name, department, work_role, gmail, whatsapp = employee
                tasks = self.db.get_tasks_for_employee(telegram_user_id, department)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not tasks:
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(f"{get_text('receive_task', lang)}\n\n{get_text('no_tasks', lang)}", reply_markup=reply_markup)
                    return
                
                # Pagination settings
                TASKS_PER_PAGE = 10
                current_page = 0
                if query.data.startswith("emp_tasks_page_"):
                    current_page = int(query.data.replace("emp_tasks_page_", ""))
                
                # Group tasks by date
                from collections import OrderedDict
                tasks_by_date = OrderedDict()
                for task in tasks:
                    task_id, date, dept, desc, priority, due_date, materials, is_check, is_perform, assignee_name = task
                    date_key = str(date) if date else "N/A"
                    if date_key not in tasks_by_date:
                        tasks_by_date[date_key] = []
                    tasks_by_date[date_key].append(task)
                
                # Flatten into date-grouped list for pagination
                all_items = []  # [(date_header, None) or (None, task)]
                for date_key, date_tasks in tasks_by_date.items():
                    all_items.append((date_key, None))  # date header
                    for t in date_tasks:
                        all_items.append((None, t))  # task item
                
                # Calculate pagination on tasks only (not headers)
                total_tasks = len(tasks)
                total_pages = (total_tasks + TASKS_PER_PAGE - 1) // TASKS_PER_PAGE
                
                # Get tasks for current page
                task_count = 0
                page_items = []
                current_date_header = None
                
                for item in all_items:
                    date_header, task = item
                    if date_header:
                        current_date_header = date_header
                        continue
                    # This is a task
                    if task_count >= current_page * TASKS_PER_PAGE and task_count < (current_page + 1) * TASKS_PER_PAGE:
                        # Add date header if new date group
                        if current_date_header:
                            page_items.append((current_date_header, None))
                            current_date_header = None
                        page_items.append((None, task))
                    elif task_count >= (current_page + 1) * TASKS_PER_PAGE:
                        break
                    if date_header is None:
                        task_count += 1
                        
                # Count unread
                unread_count = sum(1 for t in tasks if str(t[7]) == "0")
                
                start_num = current_page * TASKS_PER_PAGE + 1
                end_num = min((current_page + 1) * TASKS_PER_PAGE, total_tasks)
                
                task_text = f"{get_text('receive_task', lang)}\n\n"
                task_text += f"{get_text('total', lang)}: {total_tasks} | 🆕 {get_text('unread', lang)}: {unread_count}\n"
                task_text += f"📄 {get_text('page', lang)} {current_page + 1}/{total_pages} ({start_num}-{end_num})\n"
                task_text += f"━━━━━━━━━━━━━━━━━━"
                
                keyboard = []
                for item in page_items:
                    date_header, task = item
                    if date_header:
                        # Date header button (non-clickable separator)
                        keyboard.append([InlineKeyboardButton(f"📅 ── {date_header} ──", callback_data="noop")])
                        continue
                    
                    task_id, date, dept, desc, priority, due_date, materials, is_check, is_perform, assignee_name = task
                    priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "🟡")
                    status_emoji = "✅" if str(is_check) == "1" else "🆕"
                    short_desc = desc[:20] + "..." if desc and len(desc) > 20 else (desc or "No description")
                    
                    keyboard.append([InlineKeyboardButton(
                        f"{status_emoji} {priority_emoji} #{task_id} - {short_desc}",
                        callback_data=f"emp_task_{task_id}"
                    )])
                
                # Pagination buttons
                nav_buttons = []
                if current_page > 0:
                    nav_buttons.append(InlineKeyboardButton(f"⬅️ {get_text('prev', lang)}", callback_data=f"emp_tasks_page_{current_page - 1}"))
                if current_page < total_pages - 1:
                    nav_buttons.append(InlineKeyboardButton(f"{get_text('next', lang)} ➡️", callback_data=f"emp_tasks_page_{current_page + 1}"))
                if nav_buttons:
                    keyboard.append(nav_buttons)
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_work_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(task_text, reply_markup=reply_markup)
            
            # View Task Detail
            elif query.data.startswith("emp_task_"):
                task_id = query.data.replace("emp_task_", "")
                task = self.db.get_task_by_id(int(task_id))
                lang = get_user_language(telegram_user_id, self.db)
                
                if not task:
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_my_tasks")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(f"❌ {get_text('task_not_found', lang) if 'task_not_found' in TRANSLATIONS.get(lang, {}) else 'Task not found.'}", reply_markup=reply_markup)
                    return
                
                # task: id, Date, department, assignee_id, assignee_name, description, priority, due_date, is_materials, is_check, is_perform, proof_path, check_admin, created_by, created_at, proof_required
                t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, t_report_notes, t_report_attachment = task
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(t_priority, "🟡")
                priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(t_priority, t_priority)
                status = f"✅ {get_text('status_read', lang)}" if str(t_is_check) == "1" else f"🆕 {get_text('status_pending', lang)}"
                perform_status = f"✅ {get_text('status_completed', lang)}" if str(t_is_perform) == "1" else f"⏳ {get_text('status_pending', lang)}"
                materials_text = get_text('yes', lang) if str(t_materials) == "1" else get_text('no', lang)
                
                # Get tracking info
                tracking_info = self.db.get_task_tracking_info(int(task_id))
                tracking_text = ""
                if tracking_info:
                    not_yet = get_text('not_yet', lang)
                    tracking_text = f"""

📊 {get_text('task_tracking', lang)}:
━━━━━━━━━━━━━━━━━━
� {get_text('notification_sent', lang)}: {tracking_info.get('notification_sent_at') or not_yet}
📬 {get_text('notification_read', lang)}: {tracking_info.get('notification_read_at') or not_yet}
▶️ {get_text('task_started', lang)}: {tracking_info.get('task_started_at') or not_yet}
✅ {get_text('task_completed', lang)}: {tracking_info.get('task_completed_at') or not_yet}
━━━━━━━━━━━━━━━━━━"""
                
                task_detail = f"""📋 {get_text('task_details', lang)} #{t_id}

━━━━━━━━━━━━━━━━━━
📅 {get_text('date', lang)}: {t_date}
🏢 {get_text('department', lang)}: {t_dept}
👤 {get_text('assigned_to', lang)}: {t_assignee_name}
━━━━━━━━━━━━━━━━━━

📝 {get_text('description', lang)}:
{t_desc}

━━━━━━━━━━━━━━━━━━
{priority_emoji} {get_text('priority', lang)}: {priority_display}
📆 {get_text('due_date', lang)}: {t_due_date}
📖 Status: {status}
🔧 {get_text('progress', lang) if 'progress' in TRANSLATIONS.get(lang, {}) else 'Progress'}: {perform_status}
━━━━━━━━━━━━━━━━━━{tracking_text}"""
                
                keyboard = []
                # Show accept button if not yet read
                if str(t_is_check) == "0":
                    keyboard.append([InlineKeyboardButton(f"📥 {get_text('accept_task', lang)}", callback_data=f"emp_accept_{task_id}")])
                
                # My Tasks only allows viewing and accepting (completion in Report Task)
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_my_tasks")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(task_detail, reply_markup=reply_markup)
            
            # Accept Task
            elif query.data.startswith("emp_accept_"):
                from database import start_task
                
                task_id = query.data.replace("emp_accept_", "")
                
                # Get employee name
                employee = self.db.get_employee_info_by_telegram_id(telegram_user_id)
                employee_name = employee.get('name', str(telegram_user_id)) if employee else str(telegram_user_id)
                
                # Use new workflow: start task
                success, message = start_task(
                    db=self.db,
                    task_id=int(task_id),
                    task_table='tbl_tasks',
                    user_id=telegram_user_id,
                    user_name=employee_name
                )
                
                if not success:
                    await query.answer(f"❌ {message}", show_alert=True)
                    return
                
                # Mark task as read (legacy)
                self.db.mark_task_as_read(int(task_id))
                self.db.mark_task_notification_read(int(task_id))
                
                await query.answer("✅ Task started successfully!")
                
                # Return to task detail page
                task = self.db.get_task_by_id(int(task_id))
                
                if task:
                    t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, t_report_notes, t_report_attachment = task
                    
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(t_priority, "🟡")
                    priority_translations = {
                        "Low": get_text('priority_low', lang),
                        "Normal": get_text('priority_normal', lang),
                        "Urgent": get_text('priority_urgent', lang)
                    }
                    priority_text = priority_translations.get(t_priority, t_priority)
                    materials_text = get_text('yes', lang) if str(t_materials) == "1" else get_text('no', lang)
                    perform_status = f"✅ {get_text('completed', lang)}" if str(t_is_perform) == "1" else f"⏳ {get_text('pending', lang)}"
                    
                    task_detail = f"""✅ {get_text('task_accepted', lang)}

📋 {get_text('task', lang)} #{t_id} {get_text('details', lang)}

━━━━━━━━━━━━━━━━━━
📅 {get_text('date', lang)}: {t_date}
🏢 {get_text('department', lang)}: {t_dept}
👤 {get_text('assigned_to', lang)}: {t_assignee_name}
━━━━━━━━━━━━━━━━━━

📝 {get_text('description', lang)}:
{t_desc}

━━━━━━━━━━━━━━━━━━
{priority_emoji} {get_text('priority', lang)}: {priority_text}
📆 {get_text('due_date', lang)}: {t_due_date}
📦 {get_text('materials_needed', lang)}: {materials_text}
📖 {get_text('status', lang)}: ✅ {get_text('accepted', lang)}
🔧 {get_text('progress', lang)}: {perform_status}
━━━━━━━━━━━━━━━━━━"""
                    
                    keyboard = []
                    # After accepting, My Tasks only allows viewing (completion in Report Task)
                    keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back_to_tasks', lang)}", callback_data="emp_my_tasks")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(task_detail, reply_markup=reply_markup)
                else:
                    await query.edit_message_text("❌ Zadatak nije pronađen.")
            
            # Report Task - Show reportable task list
            elif query.data == "emp_report_task" or query.data.startswith("emp_report_task_page_"):
                telegram_user_id = update.effective_user.id
                employee = self.db.check_employee_exists(telegram_user_id)
                
                if not employee:
                    await query.edit_message_text("❌ Molimo koristite /start da se prvo registrujete.")
                    return
                
                employee_id, name, department, work_role, gmail, whatsapp = employee
                
                # Get page number from callback data
                page = 0
                if query.data.startswith("emp_report_task_page_"):
                    page = int(query.data.replace("emp_report_task_page_", ""))
                
                # Pagination settings
                tasks_per_page = 10
                offset = page * tasks_per_page
                
                # Get total count and tasks for current page
                total_tasks = self.db.get_reportable_tasks_count(telegram_user_id, department)
                tasks = self.db.get_reportable_tasks(telegram_user_id, department, limit=tasks_per_page, offset=offset)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if total_tasks == 0:
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_main_menu")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    message_text = f"{get_text('report_task_title', lang)}\n\n{get_text('no_tasks_to_report', lang)}"
                    await query.edit_message_text(message_text, reply_markup=reply_markup)
                    return
                
                # Calculate total pages
                total_pages = (total_tasks + tasks_per_page - 1) // tasks_per_page
                current_page_display = page + 1
                
                task_text = f"{get_text('report_task_title', lang)}\n\n"
                task_text += f"{get_text('you_have', lang)} {total_tasks} {get_text('tasks_suffix', lang)} {get_text('for_reporting', lang)}.\n"
                task_text += f"📄 Page {current_page_display}/{total_pages}\n\n"
                task_text += f"{get_text('select_task_to_complete', lang)}:"
                
                keyboard = []
                for task in tasks:
                    task_id, date, dept, desc, priority, due_date, is_materials, is_check = task
                    
                    priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "🟡")
                    # is_materials: 0 = proof not required, 1 = required
                    proof_emoji = "📷" if str(is_materials) == "0" else "📝"
                    
                    short_desc = desc[:20] + "..." if desc and len(desc) > 20 else (desc or "No description")
                    
                    keyboard.append([InlineKeyboardButton(
                        f"{priority_emoji} {proof_emoji} #{task_id} - {short_desc}",
                        callback_data=f"report_task_{task_id}"
                    )])
                
                # Add pagination buttons
                pagination_row = []
                if page > 0:
                    pagination_row.append(InlineKeyboardButton("⬅️ Previous", callback_data=f"emp_report_task_page_{page-1}"))
                if current_page_display < total_pages:
                    pagination_row.append(InlineKeyboardButton("➡️ Next", callback_data=f"emp_report_task_page_{page+1}"))
                
                if pagination_row:
                    keyboard.append(pagination_row)
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="emp_main_menu")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(task_text, reply_markup=reply_markup)
            
            # Report Task - View task detail and report
            elif query.data.startswith("report_task_"):
                task_id = query.data.replace("report_task_", "")
                lang = get_user_language(telegram_user_id, self.db)
                task = self.db.get_task_by_id(int(task_id))
                
                if not task:
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_report_task")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(f"❌ {get_text('task_not_found', lang)}", reply_markup=reply_markup)
                    return
                
                # task: id, Date, department, assignee_id, assignee_name, description, priority, due_date, is_materials, is_check, is_perform, proof_path, check_admin, created_by, created_at, proof_required, report_notes, report_attachment
                t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, t_report_notes, t_report_attachment = task
                
                # Check if this is a Shift Change Report task - redirect to 7-step template input
                if 'Shift Change Report' in t_desc or 'Izveštaj o promeni smene' in t_desc:
                    from templates import get_shift_report_input_template
                    import re
                    
                    # Extract shift number from description
                    shift_match = re.search(r'Shift (\d+)', t_desc)
                    shift_number = int(shift_match.group(1)) if shift_match else 1
                    
                    # Initialize shift report context
                    self.user_context[telegram_user_id] = self.user_context.get(telegram_user_id, {})
                    self.user_context[telegram_user_id]['reporting_shift'] = shift_number
                    self.user_context[telegram_user_id]['shift_report'] = {}
                    self.user_context[telegram_user_id]['shift_report_step'] = 1
                    self.user_context[telegram_user_id]['awaiting_reservations_count'] = True
                    self.user_context[telegram_user_id]['shift_report_task_id'] = int(task_id)  # Store task ID for completion
                    
                    # Get step 1 template
                    step_template = get_shift_report_input_template(lang, 1)
                    
                    text = f"📋 {get_text('shift_change_report', lang)} - {get_text('shift_number', lang)} {shift_number}\n\n"
                    text += f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"{step_template['title']}\n"
                    text += f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    text += f"{step_template['prompt']}"
                    if step_template.get('hint'):
                        text += f"\n\n💡 {step_template['hint']}"
                    
                    await query.edit_message_text(
                        text,
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="emp_report_task")
                        ]])
                    )
                    return
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(t_priority, "🟡")
                priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(t_priority, t_priority)
                dept_display = get_dept_display(t_dept)
                
                task_detail = f"""📋 {get_text('task', lang)} #{t_id} - {get_text('report', lang)}

━━━━━━━━━━━━━━━━━━
📅 {get_text('date', lang)}: {t_date}
🏢 {get_text('department', lang)}: {dept_display}
👤 {get_text('assigned_to', lang)}: {t_assignee_name}
━━━━━━━━━━━━━━━━━━

📝 {get_text('order', lang)}:
{t_desc}

━━━━━━━━━━━━━━━━━━
{priority_emoji} {get_text('priority', lang)}: {priority_display}
📆 {get_text('due_date', lang)}: {t_due_date}
━━━━━━━━━━━━━━━━━━

✍️ {get_text('enter_task_report', lang)}:
({get_text('describe_what_done', lang)})"""
                
                # Initialize report state
                context.user_data['task_report'] = {
                    'task_id': int(task_id),
                    'step': 'notes'
                }
                
                keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data="emp_report_task")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(task_detail, reply_markup=reply_markup)
            
            # Report Task - Skip attachment and complete
            elif query.data == "report_skip_attachment":
                report_data = context.user_data.get('task_report', {})
                task_id = report_data.get('task_id')
                notes = report_data.get('notes', '')
                lang = get_user_language(telegram_user_id, self.db)
                
                if not task_id:
                    await query.edit_message_text(f"❌ {get_text('invalid_upload_state', lang)}")
                    return
                
                # Use new workflow: complete task with proof validation
                from database import complete_task_with_proof
                
                task = self.db.get_task_by_id(task_id)
                if not task:
                    await query.answer("Task not found", show_alert=True)
                    return
                
                # Get user name
                user_name = query.from_user.full_name or query.from_user.username or "Unknown"
                
                # Complete task using new workflow (will enforce proof requirement)
                success, message = complete_task_with_proof(
                    db=self.db,
                    task_id=task_id,
                    task_table='tbl_tasks',
                    user_id=telegram_user_id,
                    proof_path=None,  # No attachment for skip
                    report_notes=notes,
                    user_name=user_name
                )
                
                if not success:
                    # Proof required - cannot skip
                    await query.answer(f"⛔ {message}", show_alert=True)
                    return
                
                context.user_data.pop('awaiting_report_attachment', None)
                
                # Legacy complete task (for compatibility)
                self.db.complete_task_with_report(task_id, notes, None)
                
                if success:
                    task = self.db.get_task_by_id(task_id)
                    if task:
                        t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, t_report_notes, t_report_attachment = task
                        
                        # Check if this is a Shift Change Report task
                        if 'Shift Change Report' in t_desc or 'Izveštaj o promeni smene' in t_desc:
                            # Extract shift number from description
                            import re
                            shift_match = re.search(r'Shift (\d+)', t_desc)
                            shift_number = int(shift_match.group(1)) if shift_match else 1
                            
                            # Save to tbl_shift_reports
                            from datetime import date
                            self.db.create_shift_report(
                                shift_date=t_date,
                                shift_number=shift_number,
                                employee_id=t_assignee_id,
                                reservations_count=0,
                                arrivals_count=0,
                                cash_amount=0,
                                cash_photo='',
                                pos_report_photo='',
                                store_stock_notes=notes,
                                restaurant_cash_confirmed=False,
                                key_log_notes=notes,
                                tool_log_notes=''
                            )
                            print(f"📋 Shift report saved to tbl_shift_reports for Shift {shift_number}")
                        
                        priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(t_priority, "🟡")
                        priority_display = get_text(f'priority_{t_priority.lower()}', lang) if t_priority else t_priority
                        
                        # Send notification to admin
                        await self.notify_admin_task_completed(task_id, task, notes)
                        
                        # Log task completion event
                        try:
                            event_logger = get_event_logger()
                            event_logger.log_task_completed(
                                user_id=telegram_user_id,
                                user_name=query.from_user.full_name,
                                task_id=t_id,
                                report_notes=notes[:100] if notes else "",
                                has_attachment=False
                            )
                        except Exception as log_error:
                            print(f"Event logging error: {log_error}")
                        
                        success_text = f"""✅ {get_text('task_completed_msg', lang)}

📋 {get_text('task', lang)} #{t_id}
━━━━━━━━━━━━━━━━━━
🏢 {get_text('department', lang)}: {t_dept}
📝 {get_text('task_order', lang)}: {t_desc[:50]}{'...' if len(t_desc) > 50 else ''}
{priority_emoji} {get_text('priority', lang)}: {priority_display}
📄 {get_text('report_label', lang)}: {notes[:50]}{'...' if len(notes) > 50 else ''}
📎 {get_text('attachment', lang)}: {get_text('not_attached', lang)}
━━━━━━━━━━━━━━━━━━

{get_text('admin_notified', lang)}"""
                        
                        keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_report_task")]]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await query.edit_message_text(success_text, reply_markup=reply_markup)
                else:
                    await query.edit_message_text(f"❌ {get_text('error', lang)}")
                
                context.user_data.pop('task_report', None)
            
            # Report Task - Complete with multiple attachments
            elif query.data == "report_complete_with_attachments":
                print(f"🔵 Button clicked: report_complete_with_attachments by user {telegram_user_id}")
                report_data = context.user_data.get('task_report', {})
                task_id = report_data.get('task_id')
                notes = report_data.get('notes', '')
                attachments = report_data.get('attachments', [])
                lang = get_user_language(telegram_user_id, self.db)
                
                print(f"🔵 Task ID: {task_id}, Attachments: {len(attachments)}, Notes: {notes[:50] if notes else 'None'}")
                
                if not task_id:
                    await query.edit_message_text(f"❌ {get_text('invalid_upload_state', lang)}")
                    return
                
                # Get user name
                user_name = query.from_user.full_name or query.from_user.username or "Unknown"
                
                context.user_data.pop('awaiting_report_attachment', None)
                
                # Convert attachments list to JSON string for storage
                import json
                attachments_json = json.dumps(attachments) if attachments else None
                
                print(f"🔵 About to call complete_task_with_proof with attachments_json: {attachments_json}")
                
                # Use new workflow: complete task with proof
                from database import complete_task_with_proof
                
                try:
                    success, message = complete_task_with_proof(
                        db=self.db,
                        task_id=task_id,
                        task_table='tbl_tasks',
                        user_id=telegram_user_id,
                        proof_path=attachments_json,  # Store as JSON
                        report_notes=notes,
                        user_name=user_name
                    )
                    print(f"🔵 complete_task_with_proof returned: success={success}, message={message}")
                except Exception as e:
                    print(f"❌ Exception in complete_task_with_proof: {e}")
                    import traceback
                    traceback.print_exc()
                    await query.answer(f"❌ Error: {str(e)}", show_alert=True)
                    return
                
                if not success:
                    print(f"🔵 Task completion failed: {message}")
                    await query.answer(f"❌ {message}", show_alert=True)
                    return
                
                print(f"🔵 Task completed successfully, proceeding to send confirmation")                # Legacy complete task (for compatibility)
                self.db.complete_task_with_report(task_id, notes, attachments_json)
                
                if success:
                    task = self.db.get_task_by_id(task_id)
                    if task:
                        t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, t_report_notes, t_report_attachment = task
                        
                        # Check if this is a Shift Change Report task
                        if 'Shift Change Report' in t_desc or 'Izveštaj o promeni smene' in t_desc:
                            # Extract shift number from description
                            import re
                            shift_match = re.search(r'Shift (\d+)', t_desc)
                            shift_number = int(shift_match.group(1)) if shift_match else 1
                            
                            # Extract file IDs from attachments (can be dict or string)
                            cash_photo_id = ''
                            pos_photo_id = ''
                            if attachments:
                                if isinstance(attachments[0], dict):
                                    cash_photo_id = attachments[0].get('file_id', '')
                                else:
                                    cash_photo_id = str(attachments[0])
                                if len(attachments) > 1:
                                    if isinstance(attachments[1], dict):
                                        pos_photo_id = attachments[1].get('file_id', '')
                                    else:
                                        pos_photo_id = str(attachments[1])
                            
                            # Save to tbl_shift_reports
                            from datetime import date
                            self.db.create_shift_report(
                                shift_date=t_date,
                                shift_number=shift_number,
                                employee_id=t_assignee_id,
                                reservations_count=0,
                                arrivals_count=0,
                                cash_amount=0,
                                cash_photo=cash_photo_id,
                                pos_report_photo=pos_photo_id,
                                store_stock_notes=notes,
                                restaurant_cash_confirmed=False,
                                key_log_notes=notes,
                                tool_log_notes=''
                            )
                            print(f"📋 Shift report saved to tbl_shift_reports for Shift {shift_number}")
                        
                        priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(t_priority, "🟡")
                        priority_sr = {"Low": "Nizak", "Normal": "Normalan", "Urgent": "Hitan"}.get(t_priority, t_priority)
                        
                        # Send notification to admin with all attachments
                        await self.notify_admin_task_completed_with_multiple_attachments(task_id, task, notes, attachments)
                        
                        lang = get_user_language(telegram_user_id, self.db)
                        file_count = len(attachments)
                        attachment_text = f"{file_count} {get_text('file_added' if file_count == 1 else 'files_added', lang)}"
                        
                        priority_display = get_text(f'priority_{t_priority.lower()}', lang) if t_priority else t_priority
                        
                        success_text = f"""{get_text('task_completed_msg', lang)}

{get_text('task', lang)} #{t_id}
━━━━━━━━━━━━━━━━━━
{get_text('department', lang)}: {t_dept}
{get_text('task_order', lang)}: {t_desc[:50]}{'...' if len(t_desc) > 50 else ''}
{priority_emoji} {get_text('priority', lang)}: {priority_display}
{get_text('report_label', lang)}: {notes[:50]}{'...' if len(notes) > 50 else ''}
📎 {get_text('attachments', lang)}: {attachment_text}
━━━━━━━━━━━━━━━━━━

{get_text('admin_notified', lang)}"""
                        
                        keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back_to', lang)} {get_text('report_task_title', lang)}", callback_data="emp_report_task")]]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await query.edit_message_text(success_text, reply_markup=reply_markup)
                else:
                    await query.edit_message_text("❌ Završavanje zadatka nije uspelo. Molimo pokušajte ponovo.")
                
                context.user_data.pop('task_report', None)
            
            # Report Task - Complete without proof (LEGACY - keeping for compatibility)
            elif query.data.startswith("report_complete_"):
                task_id = int(query.data.replace("report_complete_", ""))
                
                # Complete task (without proof file)
                success = self.db.complete_task_with_proof(task_id, "")
                
                if success:
                    # Get task info
                    task = self.db.get_task_by_id(task_id)
                    if task:
                        t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, t_report_notes, t_report_attachment = task
                        
                        lang = get_user_language(telegram_user_id, self.db)
                        priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(t_priority, "🟡")
                        priority_display = get_text(f'priority_{t_priority.lower()}', lang) if t_priority else t_priority
                        
                        # Send notification to admin
                        await self.notify_admin_task_completed(task_id, task)
                        
                        success_text = f"""{get_text('task_completed_msg', lang)}

{get_text('task', lang)} #{t_id}
━━━━━━━━━━━━━━━━━━
{get_text('department', lang)}: {t_dept}
{get_text('description', lang)}: {t_desc[:50]}{'...' if len(t_desc) > 50 else ''}
{priority_emoji} {get_text('priority', lang)}: {priority_display}
━━━━━━━━━━━━━━━━━━

{get_text('admin_notified', lang)}"""
                        
                        keyboard = [[InlineKeyboardButton("🔙 Nazad na Prijavu zadataka", callback_data="emp_report_task")]]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await query.edit_message_text(success_text, reply_markup=reply_markup)
                else:
                    await query.edit_message_text("❌ Završavanje zadatka nije uspelo. Molimo pokušajte ponovo.")
            
            # ==================== Admin Assignment Management ====================
            
            # Admin - Assignment Management Main Menu
            elif query.data == "admin_manage_assignments":
                telegram_user_id = update.effective_user.id
                
                if not self.db.check_admin(telegram_user_id):
                    await query.edit_message_text("❌ Ova komanda nije dostupna.")
                    return
                
                from database import get_laundry_stats
                
                laundry_stats = get_laundry_stats(self.db)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                text = f"{get_text('manage_all_tasks', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('laundry_tasks', lang)}:\n"
                text += f"   {get_text('status_pending', lang)}: {laundry_stats['Pending']}\n"
                text += f"   {get_text('status_in_progress', lang)}: {laundry_stats['Accepted']}\n"
                text += f"   {get_text('status_completed', lang)}: {laundry_stats['Completed']}\n"
                text += f"   {get_text('total_label', lang)}: {laundry_stats['total']}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{get_text('select_category_for_review', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(get_text('laundry_tasks', lang), callback_data="admin_laundry_tasks")],
                    [InlineKeyboardButton(get_text('kitchen_tasks', lang), callback_data="admin_kitchen_tasks")],
                    [InlineKeyboardButton(get_text('driver_tasks', lang), callback_data="admin_driver_tasks")],
                    [InlineKeyboardButton(get_text('accounting_tasks', lang), callback_data="admin_accounting_tasks")],
                    [InlineKeyboardButton(get_text('all_tasks_statistics', lang), callback_data="admin_assignment_stats")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="actions")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin - Laundry Tasks Management
            elif query.data == "admin_laundry_tasks":
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                if not self.db.check_admin(telegram_user_id):
                    await query.edit_message_text(f"❌ {get_text('no_permission', lang)}")
                    return
                
                text = f"🧺 {get_text('laundry_task_management', lang)}\n\n"
                text += get_text('select_filter', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(f"📥 {get_text('pending', lang)}", callback_data="admin_laundry_filter_Pending"),
                        InlineKeyboardButton(f"🔄 {get_text('in_progress', lang)}", callback_data="admin_laundry_filter_Accepted")
                    ],
                    [
                        InlineKeyboardButton(f"✅ {get_text('completed', lang)}", callback_data="admin_laundry_filter_Completed"),
                        InlineKeyboardButton(f"📊 {get_text('all', lang)}", callback_data="admin_laundry_filter_all")
                    ],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="admin_manage_assignments")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin - Laundry Filter
            elif query.data.startswith("admin_laundry_filter_"):
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                if not self.db.check_admin(telegram_user_id):
                    await query.edit_message_text(f"❌ {get_text('no_permission', lang)}")
                    return
                
                from database import get_all_laundry_tasks
                
                filter_status = query.data.replace("admin_laundry_filter_", "")
                
                if filter_status == "all":
                    tasks = get_all_laundry_tasks(self.db)
                    filter_text = get_text('all_tasks', lang)
                else:
                    tasks = get_all_laundry_tasks(self.db, status=filter_status)
                    status_map = {'Pending': 'pending', 'Accepted': 'in_progress', 'Completed': 'completed'}
                    filter_text = get_text(status_map.get(filter_status, 'all'), lang)
                
                text = f"🧺 {get_text('laundry_tasks', lang)} - {filter_text}\n\n"
                
                if not tasks:
                    text += f"✅ {get_text('no_tasks_in_category', lang)}"
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="admin_laundry_tasks")]]
                else:
                    text += get_text('found_tasks', lang).format(len(tasks)) + "\n\n"
                    
                    keyboard = []
                    for task in tasks[:15]:
                        task_id, room_number, floor, assignee_name, description, due_date, due_time, status, assigned_by_name, assigned_at, accepted_at, completed_at, proof_path, report_notes = task
                        
                        status_icon = "📥" if status == "Pending" else "🔄" if status == "Accepted" else "✅"
                        desc_preview = description[:15] + "..." if len(description) > 15 else description
                        
                        keyboard.append([InlineKeyboardButton(
                            f"{status_icon} {assignee_name}: {desc_preview}",
                            callback_data=f"admin_view_laundry_{task_id}"
                        )])
                    
                    if len(tasks) > 15:
                        text += f"\n⚠️ {get_text('showing_first_15', lang).format(len(tasks))}"
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_laundry_tasks")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin - View Laundry Task Detail
            elif query.data.startswith("admin_view_laundry_"):
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                if not self.db.check_admin(telegram_user_id):
                    await query.edit_message_text("❌ Ova komanda nije dostupna.")
                    return
                
                from database import get_laundry_task_by_id
                
                task_id = int(query.data.replace("admin_view_laundry_", ""))
                task = get_laundry_task_by_id(self.db, task_id)
                
                if not task:
                    await query.answer("❌ Zadatak nije pronađen", show_alert=True)
                    return
                
                status_map = {'Pending': '📥 Na čekanju', 'Accepted': '🔄 U toku', 'Completed': '✅ Završeno'}
                
                text = f"🧺 Detalji zadatka #{task_id}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"📝 Nalog:\n{task['description']}\n\n"
                text += f"👤 Dodeljeno: {task['assignee_name']}\n"
                text += f"⏰ Rok: {task['due_date']} {task['due_time']}\n"
                text += f"📊 Status: {status_map.get(task['status'], task['status'])}\n"
                text += f"👤 Dodelio: {task['assigned_by_name']}\n"
                text += f"📅 Dodeljeno: {task['assigned_at']}\n"
                
                if task['accepted_at']:
                    text += f"✅ Prihvaćeno: {task['accepted_at']}\n"
                
                if task['completed_at']:
                    text += f"🏁 Završeno: {task['completed_at']}\n"
                
                if task['report_notes']:
                    text += f"\n📋 Izveštaj:\n{task['report_notes']}\n"
                
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = []
                
                if task['proof_path']:
                    keyboard.append([InlineKeyboardButton(get_text('view_proof', lang), callback_data=f"admin_laundry_proof_{task_id}")])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_laundry_filter_{task['status']}")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin - View Laundry Proof
            elif query.data.startswith("admin_laundry_proof_"):
                from database import get_laundry_task_by_id
                
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                task_id = int(query.data.replace("admin_laundry_proof_", ""))
                task = get_laundry_task_by_id(self.db, task_id)
                
                proof_path = task.get('proof_path') if task else None
                if proof_path and len(proof_path.strip()) > 0:
                    try:
                        caption = get_text('proof_for_task', lang).replace('{task_id}', str(task_id)) + "\n\n"
                        caption += f"{get_text('completed_by', lang)}: {task['assignee_name']}\n"
                        caption += f"{get_text('time_label', lang)}: {task['completed_at']}"
                        
                        if task['report_notes']:
                            caption += f"\n\n{get_text('report_label', lang)}:\n{task['report_notes']}"
                        
                        try:
                            await self.application.bot.send_photo(
                                chat_id=query.from_user.id,
                                photo=proof_path,
                                caption=caption
                            )
                        except:
                            await self.application.bot.send_document(
                                chat_id=query.from_user.id,
                                document=proof_path,
                                caption=caption
                            )
                        
                        await query.answer(get_text('proof_sent', lang), show_alert=False)
                    except Exception as e:
                        print(f"Error sending admin laundry proof: {e}")
                        await query.answer(get_text('error_sending_proof', lang), show_alert=True)
                else:
                    await query.answer(get_text('proof_not_available', lang), show_alert=True)
            
            # Admin - Assignment Statistics
            elif query.data == "admin_assignment_stats":
                from database import get_laundry_stats
                
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                laundry_stats = get_laundry_stats(self.db)
                
                text = f"{get_text('all_tasks_statistics', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('laundry_tasks_label', lang)}\n"
                text += f"   {get_text('status_pending', lang)}: {laundry_stats['Pending']}\n"
                text += f"   {get_text('status_in_progress', lang)}: {laundry_stats['Accepted']}\n"
                text += f"   {get_text('status_completed', lang)}: {laundry_stats['Completed']}\n"
                text += f"   {get_text('total_label', lang)}: {laundry_stats['total']}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('kitchen_tasks_label', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('driver_tasks_label', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('accounting_tasks_label', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="admin_manage_assignments")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin - Placeholder for other assignment types
            elif query.data in ["admin_kitchen_tasks", "admin_driver_tasks", "admin_accounting_tasks"]:
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                text = f"{get_text('feature_in_development', lang)}\n\n"
                text += get_text('available_soon', lang)
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="admin_manage_assignments")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ========== Finance Callbacks ==========
            # Finance - Record new transaction
            elif query.data == "finance_record":
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                text = f"📝 {get_text('record_transaction', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{get_text('finance_select_type', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(get_text('finance_type_income', lang), callback_data="finance_type_income")],
                    [InlineKeyboardButton(get_text('finance_type_expense', lang), callback_data="finance_type_expense")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_finance")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finance - View today's transactions
            elif query.data == "finance_view_today":
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                from database import get_financial_transactions
                transactions = get_financial_transactions(self.db, period='today', limit=20)
                
                text = f"📊 {get_text('view_transactions', lang)} - {get_text('today_summary', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                if not transactions:
                    text += f"ℹ️ {get_text('no_transactions_today', lang)}\n"
                else:
                    for tx in transactions:
                        tx_emoji = "📈" if tx['type'] == 'income' else "📉"
                        text += f"{tx_emoji} {tx['description'][:25]}\n"
                        text += f"   💰 {tx['amount']:,.2f} RSD | {tx['payment_method']}\n"
                        text += f"   📁 {tx['category']} | {tx['recorded_by']}\n\n"
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_finance")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finance - Weekly report
            elif query.data == "finance_report_week":
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                from database import get_financial_transactions
                transactions = get_financial_transactions(self.db, period='week', limit=50)
                
                # Calculate totals
                total_income = sum(tx['amount'] for tx in transactions if tx['type'] == 'income')
                total_expense = sum(tx['amount'] for tx in transactions if tx['type'] == 'expense')
                net = total_income - total_expense
                
                text = f"📅 {get_text('weekly_report', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"📈 {get_text('income', lang)}: {total_income:,.2f} RSD\n"
                text += f"📉 {get_text('expense', lang)}: {total_expense:,.2f} RSD\n"
                text += f"💵 {get_text('net', lang)}: {net:,.2f} RSD\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                income_count = len([tx for tx in transactions if tx['type'] == 'income'])
                expense_count = len([tx for tx in transactions if tx['type'] == 'expense'])
                text += f"📊 {get_text('transactions', lang)}: {income_count} {get_text('incomes', lang)}, {expense_count} {get_text('expenses', lang)}\n"
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_finance")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finance - Monthly report
            elif query.data == "finance_report_month":
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                from database import get_financial_transactions
                transactions = get_financial_transactions(self.db, period='month', limit=100)
                
                # Calculate totals
                total_income = sum(tx['amount'] for tx in transactions if tx['type'] == 'income')
                total_expense = sum(tx['amount'] for tx in transactions if tx['type'] == 'expense')
                net = total_income - total_expense
                
                text = f"📆 {get_text('monthly_report', lang)}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"📈 {get_text('income', lang)}: {total_income:,.2f} RSD\n"
                text += f"📉 {get_text('expense', lang)}: {total_expense:,.2f} RSD\n"
                text += f"💵 {get_text('net', lang)}: {net:,.2f} RSD\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                # Group by category
                categories = {}
                for tx in transactions:
                    cat = tx['category']
                    if cat not in categories:
                        categories[cat] = {'income': 0, 'expense': 0}
                    if tx['type'] == 'income':
                        categories[cat]['income'] += tx['amount']
                    else:
                        categories[cat]['expense'] += tx['amount']
                
                text += f"📁 {get_text('finance_by_category', lang)}:\n"
                for cat, vals in sorted(categories.items(), key=lambda x: x[1]['income']+x[1]['expense'], reverse=True):
                    if vals['income'] > 0:
                        text += f"   📈 {cat}: {vals['income']:,.2f} RSD\n"
                    if vals['expense'] > 0:
                        text += f"   📉 {cat}: {vals['expense']:,.2f} RSD\n"
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_finance")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finance - Select transaction type (income/expense)
            elif query.data in ["finance_type_income", "finance_type_expense"]:
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                tx_type = "income" if query.data == "finance_type_income" else "expense"
                
                # Store transaction type in user_data
                context.user_data['finance_tx_type'] = tx_type
                
                text = f"📝 {get_text('record_transaction', lang)}\n\n"
                text += f"📌 {get_text('finance_type_label', lang)}: {get_text(f'finance_type_{tx_type}', lang)}\n\n"
                text += f"{get_text('finance_select_category', lang)}"
                
                if tx_type == "income":
                    keyboard = [
                        [InlineKeyboardButton(get_text('finance_cat_room_revenue', lang), callback_data="finance_cat_room_revenue")],
                        [InlineKeyboardButton(get_text('finance_cat_food_beverage', lang), callback_data="finance_cat_food_beverage")],
                        [InlineKeyboardButton(get_text('finance_cat_other_income', lang), callback_data="finance_cat_other_income")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="finance_record")]
                    ]
                else:
                    keyboard = [
                        [InlineKeyboardButton(get_text('finance_cat_purchase', lang), callback_data="finance_cat_purchase")],
                        [InlineKeyboardButton(get_text('finance_cat_utilities', lang), callback_data="finance_cat_utilities")],
                        [InlineKeyboardButton(get_text('finance_cat_salary', lang), callback_data="finance_cat_salary")],
                        [InlineKeyboardButton(get_text('finance_cat_maintenance', lang), callback_data="finance_cat_maintenance")],
                        [InlineKeyboardButton(get_text('finance_cat_tax', lang), callback_data="finance_cat_tax")],
                        [InlineKeyboardButton(get_text('finance_cat_other_expense', lang), callback_data="finance_cat_other_expense")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="finance_record")]
                    ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finance - Category selection
            elif query.data.startswith("finance_cat_"):
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                category = query.data.replace("finance_cat_", "")
                
                # Store category in user_data
                context.user_data['finance_category'] = category
                tx_type = context.user_data.get('finance_tx_type', 'expense')
                
                text = f"📝 {get_text('record_transaction', lang)}\n\n"
                text += f"📌 {get_text('finance_type_label', lang)}: {get_text('finance_type_' + tx_type, lang)}\n"
                text += f"📁 {get_text('finance_category_label', lang)}: {get_text('finance_cat_' + category, lang)}\n\n"
                text += f"💰 {get_text('finance_enter_amount', lang)}"
                
                # Set state for amount input
                context.user_data['awaiting_finance_amount'] = True
                context.user_data['callback_query_data'] = 'emp_work_finance'
                
                keyboard = [[InlineKeyboardButton(get_text('finance_cancel', lang), callback_data="emp_work_finance")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finance - Payment method selection
            elif query.data.startswith("finance_pay_"):
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                payment_method = query.data.replace("finance_pay_", "")
                payment_methods = {"cash": "Gotovina", "card": "Kartica", "bank": "Banka"}
                payment_name = payment_methods.get(payment_method, payment_method)
                
                # Store payment method and move to attachment step
                context.user_data['finance_payment'] = payment_method
                context.user_data['awaiting_finance_attachment'] = True
                
                # Get all transaction data for display
                tx_type = context.user_data.get('finance_tx_type', 'expense')
                category = context.user_data.get('finance_category', 'other')
                amount = context.user_data.get('finance_amount', 0)
                description = context.user_data.get('finance_description', '')
                
                text = f"📝 {get_text('record_transaction', lang)}\n\n"
                text += f"📌 {get_text('finance_type_label', lang)}: {get_text('finance_type_' + tx_type, lang)}\n"
                text += f"📁 {get_text('finance_category_label', lang)}: {get_text('finance_cat_' + category, lang)}\n"
                text += f"💰 {get_text('finance_amount_label', lang)}: {amount:,.2f} RSD\n"
                text += f"📝 {get_text('finance_description_label', lang)}: {description}\n"
                text += f"💳 {get_text('finance_payment_label', lang)}: {payment_name}\n\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"📎 {get_text('finance_attach_proof', lang)}\n"
                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"⏭️ {get_text('finance_skip_attach', lang)}", callback_data="finance_save_noattach")],
                    [InlineKeyboardButton(get_text('finance_cancel', lang), callback_data="emp_work_finance")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Finance - Save without attachment
            elif query.data == "finance_save_noattach":
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get all transaction data
                tx_type = context.user_data.get('finance_tx_type', 'expense')
                category = context.user_data.get('finance_category', 'other')
                amount = context.user_data.get('finance_amount', 0)
                description = context.user_data.get('finance_description', '')
                payment_method = context.user_data.get('finance_payment', 'cash')
                payment_methods = {"cash": "Gotovina", "card": "Kartica", "bank": "Banka"}
                payment_name = payment_methods.get(payment_method, payment_method)
                
                # Save transaction to database
                from database import record_financial_transaction
                
                employee = self.db.check_employee_exists(telegram_user_id)
                recorded_by_name = employee[1] if employee else "Unknown"
                
                tx_data = {
                    'transaction_type': tx_type,
                    'category': category,
                    'description': description,
                    'amount': amount,
                    'payment_method': payment_name,
                    'vendor_client': '',
                    'reference_number': '',
                    'recorded_by': str(telegram_user_id),
                    'recorded_by_name': recorded_by_name,
                    'attachment_file_id': None,
                    'attachment_type': None
                }
                
                tx_id = record_financial_transaction(self.db, tx_data)
                
                if tx_id:
                    text = f"✅ {get_text('finance_saved_success', lang).format(tx_id)}\n\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"📌 {get_text('finance_type_label', lang)}: {get_text(f'finance_type_{tx_type}', lang)}\n"
                    text += f"📁 {get_text('finance_category_label', lang)}: {get_text(f'finance_cat_{category}', lang)}\n"
                    text += f"💰 {get_text('finance_amount_label', lang)}: {amount:,.2f} RSD\n"
                    text += f"📝 {get_text('finance_description_label', lang)}: {description}\n"
                    text += f"💳 {get_text('finance_payment_label', lang)}: {payment_name}\n"
                    text += f"📎 {get_text('attachment', lang)}: ❌ {get_text('no_attachment', lang)}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"\n⚠️ {get_text('finance_no_proof_warning', lang)}"
                else:
                    text = "❌ Greška prilikom čuvanja transakcije."
                
                # Clear user_data
                for key in ['finance_tx_type', 'finance_category', 'finance_amount', 'finance_description', 'finance_payment', 'awaiting_finance_attachment']:
                    context.user_data.pop(key, None)
                
                keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_finance")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin - Pending reports list with date pagination
            elif query.data == "admin_pending_reports" or query.data.startswith("admin_reports_page_") or query.data.startswith("admin_reports_date_"):
                telegram_user_id = update.effective_user.id
                
                if not self.db.check_admin(telegram_user_id):
                    await query.edit_message_text("❌ Ova komanda nije dostupna.")
                    return
                
                pending_reports = self.db.get_pending_admin_reports()
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not pending_reports:
                    keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="back_to_admin")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    message_text = f"{get_text('pending_reports_title', lang)}\n\n{get_text('no_pending_reports', lang)}"
                    await query.edit_message_text(message_text, reply_markup=reply_markup)
                    return
                
                # Group reports by date
                from collections import OrderedDict
                from datetime import datetime as dt
                reports_by_date = OrderedDict()
                for report in pending_reports:
                    task_id, date, dept, assignee_id, assignee_name, desc, priority, due_date, materials, proof_path = report
                    if date:
                        if isinstance(date, dt):
                            date_key = date.strftime('%Y-%m-%d')
                        else:
                            date_key = str(date)[:10]
                    else:
                        date_key = "N/A"
                    if date_key not in reports_by_date:
                        reports_by_date[date_key] = []
                    reports_by_date[date_key].append(report)
                
                # Sort dates in descending order (newest first)
                sorted_dates = sorted(reports_by_date.keys(), reverse=True)
                
                # Get current date page
                current_date_idx = 0
                if query.data.startswith("admin_reports_date_"):
                    current_date_idx = int(query.data.replace("admin_reports_date_", ""))
                
                if current_date_idx >= len(sorted_dates):
                    current_date_idx = 0
                
                current_date = sorted_dates[current_date_idx]
                current_reports = reports_by_date[current_date]
                
                total_reports = len(pending_reports)
                total_dates = len(sorted_dates)
                date_report_count = len(current_reports)
                
                report_text = f"📋 {get_text('pending_reports_title', lang)}\n\n"
                report_text += f"📊 {get_text('you_have_reports', lang).replace('{count}', str(total_reports))}\n"
                report_text += f"━━━━━━━━━━━━━━━━━━"
                
                keyboard = []
                
                # Date navigation header
                date_nav = []
                if current_date_idx > 0:
                    date_nav.append(InlineKeyboardButton("◀️", callback_data=f"admin_reports_date_{current_date_idx - 1}"))
                date_nav.append(InlineKeyboardButton(f"📅 {current_date} ({date_report_count})", callback_data="noop"))
                if current_date_idx < total_dates - 1:
                    date_nav.append(InlineKeyboardButton("▶️", callback_data=f"admin_reports_date_{current_date_idx + 1}"))
                keyboard.append(date_nav)
                
                # Reports for current date
                for report in current_reports:
                    task_id, date, dept, assignee_id, assignee_name, desc, priority, due_date, materials, proof_path = report
                    priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "🟡")
                    short_desc = desc[:18] + "..." if desc and len(desc) > 18 else (desc or "N/A")
                    
                    keyboard.append([InlineKeyboardButton(
                        f"{priority_emoji} #{task_id} - {assignee_name}: {short_desc}",
                        callback_data=f"admin_view_report_{task_id}"
                    )])
                
                # Date page indicator
                if total_dates > 1:
                    keyboard.append([InlineKeyboardButton(f"📆 {current_date_idx + 1}/{total_dates} {get_text('dates', lang)}", callback_data="noop")])
                
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="back_to_admin")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(report_text, reply_markup=reply_markup)
            
            # Admin - View report detail
            elif query.data.startswith("admin_view_report_"):
                task_id = int(query.data.replace("admin_view_report_", ""))
                task = self.db.get_task_by_id(task_id)
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if not task:
                    await query.edit_message_text(f"❌ {get_text('task_not_found', lang)}")
                    return
                
                # Unpack with report_notes and report_attachment
                t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, report_notes, report_attachment = task
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(t_priority, "🟡")
                priority_display = get_text(f'priority_{t_priority.lower()}', lang) if t_priority else t_priority
                
                # Translated department display
                dept_display = get_dept_display(t_dept)
                unassigned_text = get_text('unassigned', lang) if lang == 'en' else "Nedodeljeno"
                assignee_display = unassigned_text if t_assignee_name == "Unassigned" else t_assignee_name
                
                # Parse attachments if exists
                attachments = []
                if report_attachment:
                    try:
                        import json
                        attachments = json.loads(report_attachment)
                    except:
                        # Legacy single attachment
                        attachments = [{'file_id': report_attachment, 'type': 'photo'}]
                
                attachment_count = len(attachments) if attachments else 0
                attachment_text = f"{attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}" if attachment_count > 0 else 'Nema'
                
                report_text = f"""📥 Izveštaj o zadatku #{t_id}

━━━━━━━━━━━━━━━━━━
📅 {get_text('date', lang)}: {t_date}
🏢 {get_text('department', lang)}: {dept_display}
👤 {get_text('completed_by_label', lang)}: {assignee_display}
{priority_emoji} {get_text('priority', lang)}: {priority_display}
📆 {get_text('due_date', lang)}: {t_due_date}
━━━━━━━━━━━━━━━━━━

📝 {get_text('description', lang)}:
{t_desc}"""
                
                if report_notes:
                    report_text += f"""

📄 Izveštaj:
{report_notes}"""
                
                report_text += f"""

━━━━━━━━━━━━━━━━━━
📎 Prilozi: {attachment_text}
━━━━━━━━━━━━━━━━━━"""
                
                keyboard = [
                    [InlineKeyboardButton(get_text('confirm_task', lang), callback_data=f"admin_confirm_{task_id}")],
                    [InlineKeyboardButton(get_text('back_to_reports', lang), callback_data="admin_pending_reports")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                # Send main report message
                await query.edit_message_text(report_text, reply_markup=reply_markup)
                
                # Send attachments as media group
                if attachments:
                    from telegram import InputMediaPhoto, InputMediaVideo
                    
                    media_group = []
                    documents = []
                    
                    for idx, attachment in enumerate(attachments):
                        file_id = attachment.get('file_id')
                        file_type = attachment.get('type', 'photo')
                        
                        if not file_id:
                            continue
                        
                        caption = f"📎 {attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}" if idx == 0 else None
                        
                        if file_type == 'photo':
                            media_group.append(InputMediaPhoto(media=file_id, caption=caption))
                        elif file_type == 'video':
                            media_group.append(InputMediaVideo(media=file_id, caption=caption))
                        elif file_type == 'document':
                            documents.append(file_id)
                    
                    # Send media group (photos/videos together)
                    if media_group:
                        try:
                            await self.application.bot.send_media_group(
                                chat_id=update.effective_user.id,
                                media=media_group
                            )
                        except Exception as e:
                            print(f"❌ Failed to send media group: {e}")
                    
                    # Send documents individually
                    for idx, doc_id in enumerate(documents, 1):
                        try:
                            await self.application.bot.send_document(
                                chat_id=update.effective_user.id,
                                document=doc_id,
                                caption=f"📎 Dokument {idx}/{len(documents)}"
                            )
                        except Exception as e:
                            print(f"❌ Failed to send document {idx}: {e}")
            
            # Admin - Confirm task (check_admin=1)
            elif query.data.startswith("admin_confirm_"):
                task_id = int(query.data.replace("admin_confirm_", ""))
                
                telegram_user_id = update.effective_user.id
                if not self.db.check_admin(telegram_user_id):
                    await query.edit_message_text("❌ Ova komanda nije dostupna.")
                    return
                
                # Process task confirmation
                success = self.db.confirm_task_by_admin(task_id)
                
                if success:
                    task = self.db.get_task_by_id(task_id)
                    if task:
                        t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, t_report_notes, t_report_attachment = task
                        
                        # Log task confirmation event
                        try:
                            event_logger = get_event_logger()
                            event_logger.log_task_confirmed(
                                admin_id=telegram_user_id,
                                admin_name=query.from_user.full_name,
                                task_id=t_id,
                                employee_name=t_assignee_name
                            )
                        except Exception as log_error:
                            print(f"Event logging error: {log_error}")
                        
                        # Serbian translation
                        dept_display = get_dept_display(t_dept)
                        lang = get_user_language(telegram_user_id, self.db)
                        assignee_display = get_text('unassigned', lang) if t_assignee_name == "Unassigned" else t_assignee_name
                        
                        success_text = f"""{get_text('task_confirmed', lang)}

{get_text('task_marked_completed', lang).replace('{task_id}', str(t_id))}

{get_text('assignee_label', lang)}: {assignee_display}
{get_text('department', lang)}: {dept_display}
{get_text('description', lang)}: {t_desc[:50]}{'...' if len(t_desc) > 50 else ''}"""
                        
                        keyboard = [[InlineKeyboardButton(get_text('back_to_reports', lang), callback_data="admin_pending_reports")]]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        
                        # Send as new message (media messages can't be edited)
                        try:
                            await query.edit_message_text(success_text, reply_markup=reply_markup)
                        except:
                            await self.application.bot.send_message(
                                chat_id=update.effective_user.id,
                                text=success_text,
                                reply_markup=reply_markup
                            )
                else:
                    await query.edit_message_text("❌ Potvrđivanje zadatka nije uspelo. Molimo pokušajte ponovo.")
            
            # Admin - Approve task (new workflow)
            elif query.data.startswith("approve_task_"):
                task_id = int(query.data.replace("approve_task_", ""))
                
                telegram_user_id = update.effective_user.id
                if not self.db.check_admin(telegram_user_id):
                    await query.answer("❌ Ova komanda nije dostupna.", show_alert=True)
                    return
                
                # Update task status to 'completed'
                try:
                    from database import validate_task_status_transition, record_task_status_change
                    
                    # Get current task status
                    self.db.cursor.execute("SELECT status, assignee_id FROM tbl_tasks WHERE id = %s", (task_id,))
                    result = self.db.cursor.fetchone()
                    if not result:
                        await query.answer("❌ Task not found", show_alert=True)
                        return
                    
                    current_status, assignee_id = result[0], result[1]
                    
                    # Validate transition
                    is_valid, error_msg = validate_task_status_transition(current_status, 'completed')
                    if not is_valid:
                        await query.answer(f"❌ {error_msg}", show_alert=True)
                        return
                    
                    # Update status to completed
                    self.db.cursor.execute("""
                        UPDATE tbl_tasks 
                        SET status = 'completed', 
                            check_admin = 1,
                            completed_at = CURRENT_TIMESTAMP
                        WHERE id = %s
                    """, (task_id,))
                    
                    # Record status change
                    admin_name = query.from_user.full_name or query.from_user.username or "Admin"
                    record_task_status_change(
                        self.db, task_id, 'tbl_tasks', 
                        current_status, 'completed',
                        telegram_user_id, admin_name, 
                        "Task approved by admin"
                    )
                    
                    self.db.connection.commit()
                    
                    # Log event
                    try:
                        event_logger = get_event_logger()
                        task = self.db.get_task_by_id(task_id)
                        if task:
                            t_assignee_name = task[4]
                            event_logger.log_task_confirmed(
                                admin_id=telegram_user_id,
                                admin_name=admin_name,
                                task_id=task_id,
                                employee_name=t_assignee_name
                            )
                    except Exception as log_error:
                        print(f"Event logging error: {log_error}")
                    
                    # Notify employee about approval
                    if assignee_id:
                        employee_lang = get_user_language(assignee_id, self.db)
                        approval_message = f"""{get_text('task_approved_notification', employee_lang)}

{get_text('task', employee_lang)} #{task_id}
━━━━━━━━━━━━━━━━━━
{get_text('task_approved_by_admin', employee_lang)}

✅ {get_text('status', employee_lang)}: {get_text('completed', employee_lang)}"""
                        
                        try:
                            await self.application.bot.send_message(
                                chat_id=assignee_id,
                                text=approval_message
                            )
                        except Exception as e:
                            print(f"❌ Failed to notify employee {assignee_id}: {e}")
                    
                    # Update admin's message
                    admin_lang = get_user_language(telegram_user_id, self.db)
                    success_text = f"""{get_text('task_approved_by_admin', admin_lang)}

{get_text('task', admin_lang)} #{task_id}
━━━━━━━━━━━━━━━━━━
✅ {get_text('status', admin_lang)}: {get_text('completed', admin_lang)}
👤 {get_text('approved_by', admin_lang) if admin_lang == 'en' else 'Одобрио'}: {admin_name}"""
                    
                    keyboard = [[InlineKeyboardButton(get_text('back_to_reports', admin_lang), callback_data="admin_pending_reports")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    try:
                        await query.edit_message_text(success_text, reply_markup=reply_markup)
                    except:
                        await self.application.bot.send_message(
                            chat_id=telegram_user_id,
                            text=success_text,
                            reply_markup=reply_markup
                        )
                    
                    await query.answer(f"✅ {get_text('task_approved_by_admin', admin_lang)}", show_alert=False)
                    
                except Exception as e:
                    print(f"❌ Error approving task: {e}")
                    import traceback
                    traceback.print_exc()
                    await query.answer(f"❌ Error: {str(e)}", show_alert=True)
            
            # Admin - Reject task (new workflow)
            elif query.data.startswith("reject_task_"):
                task_id = int(query.data.replace("reject_task_", ""))
                
                telegram_user_id = update.effective_user.id
                if not self.db.check_admin(telegram_user_id):
                    await query.answer("❌ Ova komanda nije dostupna.", show_alert=True)
                    return
                
                # Store task_id in user context and prompt for rejection reason
                context.user_data['pending_rejection_task_id'] = task_id
                context.user_data['awaiting_rejection_reason'] = True
                
                admin_lang = get_user_language(telegram_user_id, self.db)
                prompt_text = f"""{get_text('task_rejected_by_admin', admin_lang)}

{get_text('task', admin_lang)} #{task_id}
━━━━━━━━━━━━━━━━━━
{get_text('rejection_reason', admin_lang)}:

📝 {get_text('enter_rejection_reason', admin_lang) if admin_lang == 'en' else 'Унесите разлог одбијања:'}"""
                
                keyboard = [[InlineKeyboardButton(get_text('cancel', admin_lang), callback_data="cancel_rejection")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                try:
                    await query.edit_message_text(prompt_text, reply_markup=reply_markup)
                except:
                    await self.application.bot.send_message(
                        chat_id=telegram_user_id,
                        text=prompt_text,
                        reply_markup=reply_markup
                    )
                
                await query.answer()
            
            # Admin - Cancel rejection
            elif query.data == "cancel_rejection":
                context.user_data.pop('pending_rejection_task_id', None)
                context.user_data.pop('awaiting_rejection_reason', None)
                
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                await query.edit_message_text(
                    f"{get_text('cancel', lang)} ✅",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('back_to_reports', lang), callback_data="admin_pending_reports")
                    ]])
                )
            
            # My Profile
            elif query.data == "emp_profile":
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                employee = self.db.check_employee_exists(telegram_user_id)
                
                if employee:
                    employee_id, name, department, work_role, gmail, whatsapp = employee
                    dept_display = get_dept_display(department, lang)
                    
                    # Display contact info with "not set" message if empty
                    gmail = gmail or get_text('not_set', lang)
                    whatsapp = whatsapp or get_text('not_set', lang)
                    work_role = work_role or get_text('not_set', lang)
                    
                    profile_text = f"""{get_text('my_profile', lang)}

━━━━━━━━━━━━━━━━━━
📋 {get_text('personal_info', lang)}
━━━━━━━━━━━━━━━━━━
• {get_text('employee_id', lang)}: {employee_id}
• {get_text('name', lang)}: {name}
• {get_text('department', lang)}: {dept_display}
• {get_text('work_role', lang)}: {work_role}
• {get_text('telegram_id', lang)}: {telegram_user_id}

━━━━━━━━━━━━━━━━━━
📧 {get_text('contact_details', lang)}
━━━━━━━━━━━━━━━━━━
• Gmail: {gmail}
• WhatsApp: {whatsapp}
━━━━━━━━━━━━━━━━━━"""
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('edit_name', lang), callback_data="emp_profile_edit_name"),
                         InlineKeyboardButton(get_text('edit_department', lang), callback_data="emp_profile_edit_dept")],
                        [InlineKeyboardButton(get_text('edit_work_role', lang), callback_data="emp_profile_edit_role"),
                         InlineKeyboardButton(get_text('edit_contact', lang), callback_data="emp_settings_contact")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="emp_main_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(profile_text, reply_markup=reply_markup)
                else:
                    await query.edit_message_text(f"❌ {get_text('not_registered', lang)}")
            
            # Profile Edit - Name
            elif query.data == "emp_profile_edit_name":
                lang = get_user_language(telegram_user_id, self.db)
                employee = self.db.check_employee_exists(telegram_user_id)
                
                if employee:
                    employee_id, name, department, work_role, gmail, whatsapp = employee
                    context.user_data['awaiting_name_change'] = True
                    
                    keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data="emp_profile")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await query.edit_message_text(
                        f"{get_text('change_name', lang)}\n\n{get_text('name', lang)}: {name}\n\n{get_text('enter_new_name', lang)}",
                        reply_markup=reply_markup
                    )
            
            # Profile Edit - Department
            elif query.data == "emp_profile_edit_dept":
                lang = get_user_language(telegram_user_id, self.db)
                departments = self.db.get_departments(exclude_management=False)
                
                keyboard = []
                for dept_id, dept_name, dept_content in departments:
                    emoji = get_dept_emoji(dept_name)
                    dept_display = get_dept_display(dept_name, lang)
                    keyboard.append([InlineKeyboardButton(
                        f"{emoji} {dept_display}",
                        callback_data=f"emp_profile_set_dept_{dept_name}"
                    )])
                
                keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="emp_profile")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(
                    f"{get_text('change_department', lang)}\n\n{get_text('select_new_department', lang)}",
                    reply_markup=reply_markup
                )
            
            # Profile Set Department
            elif query.data.startswith("emp_profile_set_dept_"):
                dept_name = query.data.replace("emp_profile_set_dept_", "")
                lang = get_user_language(telegram_user_id, self.db)
                
                if self.db.update_employee_department(telegram_user_id, dept_name):
                    await query.answer(get_text('department_updated', lang), show_alert=True)
                    # Refresh profile
                    await self.show_employee_profile(query, telegram_user_id)
                else:
                    await query.answer("❌ Error", show_alert=True)
            
            # Profile Edit - Work Role
            elif query.data == "emp_profile_edit_role":
                lang = get_user_language(telegram_user_id, self.db)
                from database import get_all_work_roles
                
                work_roles = get_all_work_roles(self.db)
                
                if work_roles:
                    keyboard = []
                    row = []
                    for role_id, role_name, description, created_at in work_roles:
                        role_emoji = get_role_emoji(role_name)
                        role_display = get_work_role_display(role_name, lang)
                        row.append(InlineKeyboardButton(
                            f"{role_emoji} {role_display}",
                            callback_data=f"emp_profile_set_role_{role_name}"
                        ))
                        if len(row) == 3:
                            keyboard.append(row)
                            row = []
                    if row:  # Add remaining buttons
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="emp_profile")])
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await query.edit_message_text(
                        f"{get_text('change_work_role', lang)}\n\n{get_text('select_new_work_role', lang)}",
                        reply_markup=reply_markup
                    )
                else:
                    await query.answer("No work roles available", show_alert=True)
            
            # Profile Set Work Role
            elif query.data.startswith("emp_profile_set_role_"):
                role_name = query.data.replace("emp_profile_set_role_", "")
                lang = get_user_language(telegram_user_id, self.db)
                
                if self.db.update_employee_work_role(telegram_user_id, role_name):
                    await query.answer(get_text('work_role_updated', lang), show_alert=True)
                    # Refresh profile
                    await self.show_employee_profile(query, telegram_user_id)
                else:
                    await query.answer("❌ Error", show_alert=True)
            
            # Employee Settings
            elif query.data == "emp_settings":
                lang = get_user_language(telegram_user_id, self.db)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('language_settings', lang), callback_data="emp_settings_language")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="emp_main_menu")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(
                    f"{get_text('settings', lang)}\n\n{get_text('select_action', lang)}", 
                    reply_markup=reply_markup
                )
            
            # Employee Language Settings
            elif query.data == "emp_settings_language":
                lang = get_user_language(telegram_user_id, self.db)
                languages = get_available_languages()
                
                current_lang_name = languages.get(lang, '🇷🇸 Srpski')
                
                keyboard = []
                for lang_code, lang_name in languages.items():
                    keyboard.append([InlineKeyboardButton(
                        f"{'✅ ' if lang_code == lang else ''}{lang_name}",
                        callback_data=f"emp_set_language_{lang_code}"
                    )])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="emp_settings")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(
                    f"{get_text('select_language', lang)}\n\n{get_text('current_language', lang)}: {current_lang_name}",
                    reply_markup=reply_markup
                )
            
            # Employee Set Language
            elif query.data.startswith("emp_set_language_"):
                new_lang = query.data.replace("emp_set_language_", "")
                set_user_language(telegram_user_id, new_lang, self.db)
                
                await query.answer(get_text('language_changed', new_lang), show_alert=True)
                
                # Refresh language settings menu
                languages = get_available_languages()
                current_lang_name = languages.get(new_lang, '🇷🇸 Srpski')
                
                keyboard = []
                for lang_code, lang_name in languages.items():
                    keyboard.append([InlineKeyboardButton(
                        f"{'✅ ' if lang_code == new_lang else ''}{lang_name}",
                        callback_data=f"emp_set_language_{lang_code}"
                    )])
                
                keyboard.append([InlineKeyboardButton(get_text('back', new_lang), callback_data="emp_settings")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(
                    f"{get_text('select_language', new_lang)}\n\n{get_text('current_language', new_lang)}: {current_lang_name}",
                    reply_markup=reply_markup
                )
            
            # Employee Contact Information Settings
            elif query.data == "emp_settings_contact":
                lang = get_user_language(telegram_user_id, self.db)
                contact_info = self.db.get_employee_contact_info(telegram_user_id)
                
                gmail = contact_info['gmail'] or get_text('not_set', lang)
                whatsapp = contact_info['whatsapp'] or get_text('not_set', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('gmail_settings', lang), callback_data="emp_settings_gmail")],
                    [InlineKeyboardButton(get_text('whatsapp_settings', lang), callback_data="emp_settings_whatsapp")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="emp_settings")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                text = f"""{get_text('contact_info', lang)}

━━━━━━━━━━━━━━━━━━
📧 {get_text('current_gmail', lang)}: {gmail}
📱 {get_text('current_whatsapp', lang)}: {whatsapp}
━━━━━━━━━━━━━━━━━━"""
                
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Employee Gmail Settings
            elif query.data == "emp_settings_gmail":
                lang = get_user_language(telegram_user_id, self.db)
                contact_info = self.db.get_employee_contact_info(telegram_user_id)
                gmail = contact_info['gmail'] or get_text('not_set', lang)
                
                context.user_data['awaiting_gmail'] = True
                
                keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data="emp_settings_contact")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(
                    f"{get_text('set_gmail', lang)}\n\n{get_text('current_gmail', lang)}: {gmail}\n\n{get_text('enter_gmail', lang)}",
                    reply_markup=reply_markup
                )
            
            # Employee WhatsApp Settings
            elif query.data == "emp_settings_whatsapp":
                lang = get_user_language(telegram_user_id, self.db)
                contact_info = self.db.get_employee_contact_info(telegram_user_id)
                whatsapp = contact_info['whatsapp'] or get_text('not_set', lang)
                
                context.user_data['awaiting_whatsapp'] = True
                
                keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data="emp_settings_contact")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(
                    f"{get_text('set_whatsapp', lang)}\n\n{get_text('current_whatsapp', lang)}: {whatsapp}\n\n{get_text('enter_whatsapp', lang)}",
                    reply_markup=reply_markup
                )
            
            # ==================== EMPLOYEE COMPLAINT HANDLERS ====================
            
            # Employee Complaint Menu
            elif query.data == "emp_complaint":
                telegram_user_id = update.effective_user.id
                employee = self.db.check_employee_exists(telegram_user_id)
                
                if employee:
                    # Get user's complaints
                    my_complaints = self.db.get_user_complaints(telegram_user_id, 5)
                    
                    text = """� Pritužbe

Ovde možete prijaviti pritužbu ili problem administratoru.
Možete dodati tekst i priložiti fotografiju ili dokument.

"""
                    lang = get_user_language(telegram_user_id, self.db)
                    if my_complaints:
                        text += f"📋 Vaše poslednje pritužbe ({len(my_complaints)}):\n"
                        for c in my_complaints:
                            status = "✅ Potvrđeno" if c['confirmed'] else "⏳ Na čekanju"
                            text += f"• {c['complaint_date']}: {status}\n"
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('new_complaint', lang), callback_data="complaint_new")],
                        [InlineKeyboardButton(get_text('my_complaints', lang), callback_data="complaint_my_list")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="emp_main_menu")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.edit_message_text("❌ Morate biti registrovani da biste prijavili pritužbu.")
            
            # New Complaint - Ask for text
            elif query.data == "complaint_new":
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                employee = self.db.check_employee_exists(telegram_user_id)
                
                if employee:
                    context.user_data['complaint'] = {
                        'step': 'text',
                        'telegram_user_id': telegram_user_id,
                        'employee_id': employee[0],
                        'name': employee[1],
                        'department': employee[2]
                    }
                    
                    text = """📝 Nova pritužba - Korak 1/2

Molimo unesite opis vaše pritužbe ili problema:

(Pošaljite tekstualnu poruku)"""
                    
                    keyboard = [[InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_complaint")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.edit_message_text("❌ Greška: Zaposleni nije pronađen.")
            
            # Skip media attachment
            elif query.data == "complaint_skip_media":
                if 'complaint' in context.user_data and context.user_data['complaint'].get('text'):
                    from datetime import datetime
                    complaint_data = context.user_data['complaint']
                    
                    # Create complaint without media
                    complaint_id = self.db.create_complaint(
                        telegram_user_id=complaint_data['telegram_user_id'],
                        department=complaint_data['department'],
                        name=complaint_data['name'],
                        complaint_text=complaint_data['text'],
                        media_type=None,
                        media_file_id=None
                    )
                    
                    if complaint_id:
                        # Clear complaint data
                        del context.user_data['complaint']
                        
                        # Notify admin with urgent notification and view button
                        try:
                            admins = self.db.get_all_admins()
                            for admin in admins:
                                try:
                                    notification_text = f"""🚨 NOVA PRITUŽBA! 🚨

📋 Pritužba #{complaint_id}
👤 Zaposleni: {complaint_data['name']}
🏢 Odeljenje: {get_dept_display(complaint_data['department'])}
📅 Datum: {datetime.now().strftime('%Y-%m-%d %H:%M')}

📝 Sadržaj pritužbe:
{complaint_data['text']}"""
                                    
                                    admin_keyboard = InlineKeyboardMarkup([
                                        [InlineKeyboardButton("✅ Potvrdi", callback_data=f"complaint_confirm_{complaint_id}"),
                                         InlineKeyboardButton("👁 Detalji", callback_data=f"complaint_view_{complaint_id}")]
                                    ])
                                    
                                    await self.application.bot.send_message(
                                        chat_id=admin[0],
                                        text=notification_text,
                                        reply_markup=admin_keyboard,
                                        disable_notification=False  # Ensure notification sound
                                    )
                                except:
                                    pass
                        except:
                            pass
                        
                        lang = get_user_language(telegram_user_id, self.db)
                        text = f"""✅ Pritužba uspešno poslata!

📋 ID pritužbe: #{complaint_id}
📅 Datum: {datetime.now().strftime('%Y-%m-%d %H:%M')}

{get_text('complaint_forwarded_to_admin', lang)}
Dobićete obaveštenje kada bude potvrđena."""
                        
                        keyboard = [[InlineKeyboardButton(get_text('back', lang), callback_data="emp_complaint")]]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await query.edit_message_text(text, reply_markup=reply_markup)
                    else:
                        lang = get_user_language(telegram_user_id, self.db)
                        await query.edit_message_text("❌ Greška pri kreiranju pritužbe. Pokušajte ponovo.")
                else:
                    await query.edit_message_text("❌ Nema podataka o pritužbi. Pokušajte ponovo.")
            
            # My Complaints List
            elif query.data == "complaint_my_list":
                telegram_user_id = update.effective_user.id
                complaints = self.db.get_user_complaints(telegram_user_id, 20)
                
                lang = get_user_language(telegram_user_id, self.db)
                if complaints:
                    text = f"{get_text('my_complaints', lang)} ({len(complaints)})\n\n"
                    for c in complaints:
                        status = "✅ Potvrđeno" if c['confirmed'] else "⏳ Na čekanju"
                        media = f" 📎 {c['media_type']}" if c['media_type'] else ""
                        text += f"#{c['id']} | {c['complaint_date']} | {status}{media}\n"
                        text += f"   └ {c['complaint_text'][:50]}{'...' if len(c['complaint_text']) > 50 else ''}\n\n"
                else:
                    text = f"{get_text('my_complaints', lang)}\n\nNemate nijednu pritužbu."
                
                keyboard = [
                    [InlineKeyboardButton(get_text('new_complaint', lang), callback_data="complaint_new")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="emp_complaint")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ==================== ADMIN COMPLAINT HANDLERS ====================
            
            # Admin Complaints List
            elif query.data == "admin_complaints":
                complaints = self.db.get_all_complaints(30)
                unconfirmed = self.db.get_unconfirmed_complaints()
                
                if complaints:
                    text = f"""📢 Upravljanje pritužbama

📊 Statistika:
• Ukupno: {len(complaints)}
• Na čekanju: {unconfirmed}
• Potvrđeno: {len(complaints) - unconfirmed}

Izaberite pritužbu za detalje:
"""
                    keyboard = []
                    for c in complaints[:15]:  # Show max 15
                        status = "✅" if c['confirmed'] else "⏳"
                        media = "📎" if c['media_type'] else ""
                        btn_text = f"{status} #{c['id']} {c['name']} {media}"
                        keyboard.append([InlineKeyboardButton(btn_text, callback_data=f"complaint_view_{c['id']}")])
                    
                    keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data="back_to_admin")])
                else:
                    text = "📢 Upravljanje pritužbama\n\nNema pritužbi."
                    keyboard = [[InlineKeyboardButton("🔙 Nazad", callback_data="back_to_admin")]]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # View Complaint Detail
            elif query.data.startswith("complaint_view_"):
                complaint_id = int(query.data.replace("complaint_view_", ""))
                complaint = self.db.get_complaint_by_id(complaint_id)
                
                if complaint:
                    dept_display = get_dept_display(complaint['department'])
                    status = "✅ Potvrđeno" if complaint['confirmed'] else "⏳ Na čekanju"
                    media_info = f"\n📎 Prilog: {complaint['media_type']}" if complaint['media_type'] else ""
                    confirmed_info = f"\n✅ Potvrdio: {complaint['confirmed_at']}" if complaint['confirmed'] else ""
                    
                    text = f"""📢 Pritužba #{complaint['id']}

👤 Zaposleni: {complaint['name']}
🏢 Odeljenje: {dept_display}
📅 Datum: {complaint['complaint_date']}
⏰ Vreme: {complaint['created_at']}
📋 Status: {status}{confirmed_info}{media_info}

📝 Opis pritužbe:
{complaint['complaint_text']}
"""
                    
                    keyboard = []
                    
                    # If has media, add view media button
                    if complaint['media_file_id']:
                        keyboard.append([InlineKeyboardButton("📎 Prikaži prilog", callback_data=f"complaint_media_{complaint_id}")])
                    
                    # If not confirmed, add confirm button
                    if not complaint['confirmed']:
                        keyboard.append([InlineKeyboardButton("✅ Potvrdi pritužbu", callback_data=f"complaint_confirm_{complaint_id}")])
                    
                    keyboard.append([InlineKeyboardButton("🔙 Nazad", callback_data="admin_complaints")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
                else:
                    await query.answer("Pritužba nije pronađena.", show_alert=True)
            
            # View Complaint Media
            elif query.data.startswith("complaint_media_"):
                complaint_id = int(query.data.replace("complaint_media_", ""))
                complaint = self.db.get_complaint_by_id(complaint_id)
                
                media_file_id = complaint.get('media_file_id') if complaint else None
                if media_file_id and len(media_file_id.strip()) > 0:
                    try:
                        media_type = complaint['media_type']
                        
                        caption = f"📢 Pritužba #{complaint_id}\nPrilog od {complaint['name']}"
                        
                        if media_type == 'photo':
                            await self.application.bot.send_photo(
                                chat_id=update.effective_user.id,
                                photo=media_file_id,
                                caption=caption
                            )
                        elif media_type == 'document':
                            await self.application.bot.send_document(
                                chat_id=update.effective_user.id,
                                document=media_file_id,
                                caption=caption
                            )
                        elif media_type == 'video':
                            await self.application.bot.send_video(
                                chat_id=update.effective_user.id,
                                video=media_file_id,
                                caption=caption
                            )
                        
                        await query.answer("Prilog je poslat.")
                    except Exception as e:
                        print(f"Error sending complaint media: {e}")
                        await query.answer(f"Greška pri slanju priloga: {str(e)}", show_alert=True)
                else:
                    await query.answer("Nema priloga za ovu pritužbu.", show_alert=True)
            
            # Confirm Complaint
            elif query.data.startswith("complaint_confirm_"):
                complaint_id = int(query.data.replace("complaint_confirm_", ""))
                admin_id = update.effective_user.id
                
                success = self.db.mark_complaint_confirmed(complaint_id, admin_id)
                
                if success:
                    complaint = self.db.get_complaint_by_id(complaint_id)
                    
                    # Notify employee
                    if complaint:
                        try:
                            user_lang = get_user_language(complaint['telegram_user_id'], self.db)
                            message_text = f"{get_text('complaint_confirmed_by_admin', user_lang).replace('{complaint_id}', str(complaint_id))}\n\n{get_text('thank_you_for_feedback', user_lang)}"
                            await self.application.bot.send_message(
                                chat_id=complaint['telegram_user_id'],
                                text=message_text
                            )
                        except:
                            pass
                    
                    await query.answer("✅ Pritužba je potvrđena!", show_alert=True)
                    
                    # Return to admin main menu
                    employee_info = self.db.get_employee_info(admin_id)
                    if employee_info:
                        employee_id = employee_info['employee_id']
                        name = employee_info['name']
                        department = employee_info['department']
                        dept_display = get_dept_display(department)
                        
                        pending_reports = self.db.get_pending_admin_reports()
                        pending_complaints = self.db.get_unconfirmed_complaints()
                        
                        lang = get_user_language(admin_id, self.db)
                        
                        welcome_text = f"""🎉 Dobrodošli, Administratore!

👤 Vaši podaci:
• Ime: {name}
• ID zaposlenog: {employee_id}
• Odeljenje: {dept_display} (Admin)
• Telegram ID: {admin_id}

Imate pun pristup svim funkcijama sistema."""
                        
                        if pending_reports:
                            welcome_text += f"\n\n🔔 Imate {len(pending_reports)} izveštaj(a) o zadacima na čekanju!"
                        if pending_complaints:
                            welcome_text += f"\n📢 Imate {pending_complaints} pritužbi na čekanju!"
                        
                        # Improved button layout - 2 columns for better UX
                        keyboard = [
                            [InlineKeyboardButton(get_text('dashboard', lang), callback_data="dashboard"),
                             InlineKeyboardButton(get_text('actions', lang), callback_data="actions")],
                            [InlineKeyboardButton(f"📥 {get_text('reports', lang)} ({len(pending_reports)})" if pending_reports else f"📥 {get_text('reports', lang)}", callback_data="admin_pending_reports"),
                             InlineKeyboardButton(f"📢 {get_text('complaints', lang)} ({pending_complaints})" if pending_complaints else f"📢 {get_text('complaints', lang)}", callback_data="admin_complaints")],
                            [InlineKeyboardButton(get_text('settings', lang), callback_data="settings"),
                             InlineKeyboardButton(get_text('information', lang), callback_data="information")]
                        ]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        
                        try:
                            await query.edit_message_caption(caption=welcome_text, reply_markup=reply_markup)
                        except:
                            try:
                                await query.edit_message_text(welcome_text, reply_markup=reply_markup)
                            except:
                                await self.application.bot.send_message(
                                    chat_id=admin_id,
                                    text=welcome_text,
                                    reply_markup=reply_markup
                                )
                else:
                    await query.answer("Greška pri potvrđivanju pritužbe.", show_alert=True)
            
            # ==================== END COMPLAINT HANDLERS ====================
            
            # Back to Employee Main Menu
            elif query.data == "emp_main_menu":
                telegram_user_id = update.effective_user.id
                employee = self.db.check_employee_exists(telegram_user_id)
                
                if employee:
                    employee_id, name, department, work_role, gmail, whatsapp = employee
                    lang = get_user_language(telegram_user_id, self.db)
                    dept_display = get_dept_display(department, lang)
                    
                    # Get unread task count
                    unread_count = self.db.get_unread_task_count(telegram_user_id, department)
                    notification_text = get_text('new_task_notification_count', lang).format(unread_count) if unread_count > 0 else get_text('new_task_notification', lang)
                    
                    # Get reportable task count
                    reportable_tasks = self.db.get_reportable_tasks(telegram_user_id, department)
                    report_count = len(reportable_tasks)
                    report_text = get_text('report_task_count', lang).format(report_count) if report_count > 0 else get_text('report_task', lang)
                    
                    welcome_text = f"""{get_text('welcome_back', lang).format(name)}

{get_text('your_info', lang)}
{get_text('employee_id_label', lang)}: {employee_id}
• {get_text('department', lang)}: {dept_display}

{get_text('select_option', lang)}"""
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('tasks', lang), callback_data="emp_my_tasks"),
                         InlineKeyboardButton(report_text, callback_data="emp_report_task")],
                        [InlineKeyboardButton(notification_text, callback_data="emp_notifications")],
                        [InlineKeyboardButton(get_text('schedule', lang), callback_data="emp_schedule_menu"),
                         InlineKeyboardButton(get_text('complaint', lang), callback_data="emp_complaint")],
                        [InlineKeyboardButton(get_text('profile', lang), callback_data="emp_profile"),
                         InlineKeyboardButton(get_text('settings', lang), callback_data="emp_settings")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(welcome_text, reply_markup=reply_markup)
                else:
                    await query.edit_message_text("❌ Molimo koristite /start da se prvo registrujete.")
            
            # Settings Menu
            elif query.data == "settings":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Check if user is admin or employee
                if self.db.check_admin(telegram_user_id):
                    # Get current settings
                    hotel_settings = self.db.get_hotel_settings()
                    ai_enabled = hotel_settings.get('ai_analysis_enabled', False)
                    
                    # Admin settings
                    keyboard = [
                        [InlineKeyboardButton(get_text('language_settings', lang), callback_data="settings_language")],
                        [InlineKeyboardButton(f"🕐 {get_text('shift_settings', lang)}", callback_data="settings_shift")],
                        [InlineKeyboardButton(f"👥 {get_text('shift_management', lang)}", callback_data="shift_management")],
                        [InlineKeyboardButton(f"🤖 {get_text('ai_analysis_settings', lang)}", callback_data="settings_ai")],
                        [InlineKeyboardButton(f"🔔 {get_text('notification_settings', lang)}", callback_data="settings_notifications")],
                        [InlineKeyboardButton(f"📋 Action History", callback_data="action_history_menu")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="back_to_admin")]
                    ]
                else:
                    # Employee settings - redirect to emp_settings
                    query.data = "emp_settings"
                    await self.button_handler(update, context)
                    return
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                try:
                    await query.edit_message_text(
                        f"{get_text('settings', lang)}\n\n{get_text('select_action', lang)}", 
                        reply_markup=reply_markup
                    )
                except Exception as edit_error:
                    # If message has media (no text to edit), send new message
                    if "no text in the message" in str(edit_error).lower():
                        await query.message.reply_text(
                            f"{get_text('settings', lang)}\n\n{get_text('select_action', lang)}", 
                            reply_markup=reply_markup
                        )
                    else:
                        raise edit_error
            
            # Language Settings
            elif query.data == "settings_language":
                lang = get_user_language(telegram_user_id, self.db)
                languages = get_available_languages()
                
                current_lang_name = languages.get(lang, '🇷🇸 Srpski')
                
                keyboard = []
                for lang_code, lang_name in languages.items():
                    keyboard.append([InlineKeyboardButton(
                        f"{'✅ ' if lang_code == lang else ''}{lang_name}",
                        callback_data=f"set_language_{lang_code}"
                    )])
                
                keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="settings")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(
                    f"{get_text('select_language', lang)}\n\n{get_text('current_language', lang)}: {current_lang_name}",
                    reply_markup=reply_markup
                )
            
            # Set Language
            elif query.data.startswith("set_language_"):
                new_lang = query.data.replace("set_language_", "")
                set_user_language(telegram_user_id, new_lang, self.db)
                
                await query.answer(get_text('language_changed', new_lang), show_alert=True)
                
                # Refresh language settings menu
                languages = get_available_languages()
                current_lang_name = languages.get(new_lang, '🇷🇸 Srpski')
                
                keyboard = []
                for lang_code, lang_name in languages.items():
                    keyboard.append([InlineKeyboardButton(
                        f"{'✅ ' if lang_code == new_lang else ''}{lang_name}",
                        callback_data=f"set_language_{lang_code}"
                    )])
                
                keyboard.append([InlineKeyboardButton(get_text('back', new_lang), callback_data="settings")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(
                    f"{get_text('select_language', new_lang)}\n\n{get_text('current_language', new_lang)}: {current_lang_name}",
                    reply_markup=reply_markup
                )
            
            # ==================== Shift Settings Handlers ====================
            
            # Shift Settings Main Menu
            elif query.data == "settings_shift":
                from database import get_shift_settings
                
                lang = get_user_language(telegram_user_id, self.db)
                settings = get_shift_settings(self.db)
                
                text = f"🕐 {get_text('shift_settings', lang)}\n\n"
                text += f"📊 {get_text('current_shifts', lang)}: 3 (A, B, C)\n\n"
                
                if settings:
                    # Display current shift times
                    for i in range(1, 4):  # Always 3 shifts
                        start = settings.get(f'shift_{i}_start', '--:--')
                        end = settings.get(f'shift_{i}_end', '--:--')
                        shift_letter = ['A', 'B', 'C'][i-1]
                        text += f"  {shift_letter}️⃣ {start} - {end}\n"
                else:
                    text += f"⚠️ {get_text('no_shift_settings', lang)}\n"
                    text += f"  A️⃣ 08:00 - 16:00 ({get_text('default', lang)})\n"
                    text += f"  B️⃣ 16:00 - 00:00 ({get_text('default', lang)})\n"
                    text += f"  C️⃣ 00:00 - 08:00 ({get_text('default', lang)})\n"
                
                text += f"\n💡 {get_text('auto_24_hours', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(f"✏️ {get_text('edit_shift_times', lang)}", callback_data="shift_edit_start")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="settings")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Edit Shift Start Times
            elif query.data == "shift_edit_start":
                from database import get_shift_settings
                
                lang = get_user_language(telegram_user_id, self.db)
                settings = get_shift_settings(self.db)
                
                # Initialize context with current or default times
                if telegram_user_id not in self.user_context:
                    self.user_context[telegram_user_id] = {}
                
                if settings:
                    self.user_context[telegram_user_id]['shift_starts'] = [
                        settings.get('shift_1_start', '08:00'),
                        settings.get('shift_2_start', '16:00'),
                        settings.get('shift_3_start', '00:00')
                    ]
                else:
                    self.user_context[telegram_user_id]['shift_starts'] = ['08:00', '16:00', '00:00']
                
                current_starts = self.user_context[telegram_user_id]['shift_starts']
                
                text = f"✏️ {get_text('edit_shift_times', lang)}\n\n"
                text += f"� {get_text('enter_start_times_only', lang)}\n"
                text += f"💡 {get_text('end_times_auto_calculated', lang)}\n\n"
                text += f"{get_text('current_settings', lang)}:\n"
                text += f"  A️⃣ {get_text('starts_at', lang)}: {current_starts[0]}\n"
                text += f"  B️⃣ {get_text('starts_at', lang)}: {current_starts[1]}\n"
                text += f"  C️⃣ {get_text('starts_at', lang)}: {current_starts[2]}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"✏️ {get_text('edit_shift', lang)} A", callback_data="shift_edit_A")],
                    [InlineKeyboardButton(f"✏️ {get_text('edit_shift', lang)} B", callback_data="shift_edit_B")],
                    [InlineKeyboardButton(f"✏️ {get_text('edit_shift', lang)} C", callback_data="shift_edit_C")],
                    [InlineKeyboardButton(f"💾 {get_text('save_settings', lang)}", callback_data="shift_save_new")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="settings_shift")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Edit Individual Shift (A, B, or C)
            elif query.data.startswith("shift_edit_"):
                lang = get_user_language(telegram_user_id, self.db)
                shift_letter = query.data.replace("shift_edit_", "")
                
                if shift_letter in ['A', 'B', 'C']:
                    shift_index = ['A', 'B', 'C'].index(shift_letter)
                    
                    if telegram_user_id not in self.user_context:
                        self.user_context[telegram_user_id] = {}
                    
                    self.user_context[telegram_user_id]['editing_shift_letter'] = shift_letter
                    self.user_context[telegram_user_id]['editing_shift_index'] = shift_index
                    self.user_context[telegram_user_id]['awaiting_shift_start'] = True
                    
                    current_time = self.user_context[telegram_user_id].get('shift_starts', ['08:00', '16:00', '00:00'])[shift_index]
                    
                    text = f"✏️ {get_text('edit_shift', lang)} {shift_letter}\n\n"
                    text += f"{get_text('current_start_time', lang)}: {current_time}\n\n"
                    text += f"{get_text('enter_start_time', lang)} (HH:MM):\n"
                    text += f"📌 {get_text('example', lang)}: 08:00, 16:00, 23:30"
                    
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="shift_edit_start")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Save New Shift Settings (with auto-calculated end times)
            elif query.data == "shift_save_new":
                from database import save_shift_settings
                
                lang = get_user_language(telegram_user_id, self.db)
                
                shift_starts = self.user_context.get(telegram_user_id, {}).get('shift_starts', ['08:00', '16:00', '00:00'])
                
                # Prepare shifts list for save_shift_settings
                # Format: [(start1, None), (start2, None), (start3, None)]
                # End times will be auto-calculated by save_shift_settings
                shifts = [(start, None) for start in shift_starts]
                
                if save_shift_settings(self.db, 3, shifts):
                    # Get the saved settings to show actual end times
                    from database import get_shift_settings
                    saved = get_shift_settings(self.db)
                    
                    text = f"✅ {get_text('shift_saved', lang)}\n\n"
                    text += f"📊 3 {get_text('shifts', lang)} (A, B, C)\n\n"
                    
                    if saved:
                        for i in range(1, 4):
                            start = saved.get(f'shift_{i}_start', '--:--')
                            end = saved.get(f'shift_{i}_end', '--:--')
                            shift_letter = ['A', 'B', 'C'][i-1]
                            text += f"  {shift_letter}️⃣ {start} - {end}\n"
                    
                    text += f"\n💡 {get_text('end_times_auto_calculated', lang)}"
                else:
                    text = f"❌ {get_text('error_saving', lang)}"
                
                # Clean up context
                if telegram_user_id in self.user_context:
                    self.user_context[telegram_user_id].pop('shift_starts', None)
                    self.user_context[telegram_user_id].pop('editing_shift_letter', None)
                    self.user_context[telegram_user_id].pop('editing_shift_index', None)
                
                keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="settings_shift")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Old shift_save handler - redirect to shift_save_new
            elif query.data == "shift_save":
                from database import save_shift_settings
                
                lang = get_user_language(telegram_user_id, self.db)
                
                shift_count = self.user_context.get(telegram_user_id, {}).get('shift_count', 2)
                shifts = self.user_context.get(telegram_user_id, {}).get('shifts', [])
                
                if save_shift_settings(self.db, shift_count, shifts):
                    text = f"✅ {get_text('shift_saved', lang)}\n\n"
                    text += f"📊 {get_text('total_shifts', lang)}: {shift_count}\n"
                    for i, (start, end) in enumerate(shifts, 1):
                        text += f"  {i}️⃣ {start} - {end}\n"
                else:
                    text = f"❌ {get_text('error_saving', lang)}"
                
                # Clean up context
                if telegram_user_id in self.user_context:
                    self.user_context[telegram_user_id].pop('shift_count', None)
                    self.user_context[telegram_user_id].pop('shifts', None)
                
                keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="settings_shift")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ==================== AI Analysis Settings Handlers ====================
            
            # AI Analysis Settings Menu
            elif query.data == "settings_ai":
                lang = get_user_language(telegram_user_id, self.db)
                hotel_settings = self.db.get_hotel_settings()
                ai_enabled = hotel_settings.get('ai_analysis_enabled', False)
                
                toggle_emoji = "✅" if ai_enabled else "⬜"
                
                text = f"🤖 {get_text('ai_analysis_settings', lang)}\n\n"
                
                if ai_enabled:
                    if lang == 'sr':
                        text += f"{toggle_emoji} AI Analiza: UKLJUČENA\n\n"
                        text += "📌 Kada je uključeno:\n"
                        text += "• Automatska AI analiza pri slanju izveštaja\n"
                        text += "• Rezultati se šalju menadžeru automatski\n"
                        text += "• Smanjuje ručni rad menadžera\n"
                    else:
                        text += f"{toggle_emoji} AI Analysis: ENABLED\n\n"
                        text += "📌 When enabled:\n"
                        text += "• Automatic AI analysis on report submission\n"
                        text += "• Results are sent to managers automatically\n"
                        text += "• Reduces manager's manual work\n"
                else:
                    if lang == 'sr':
                        text += f"{toggle_emoji} AI Analiza: ISKLJUČENA\n\n"
                        text += "📌 Kada je isključeno:\n"
                        text += "• Podaci se čuvaju bez automatske analize\n"
                        text += "• Menadžer pregleda izveštaje ručno\n"
                    else:
                        text += f"{toggle_emoji} AI Analysis: DISABLED\n\n"
                        text += "📌 When disabled:\n"
                        text += "• Data is saved without automatic analysis\n"
                        text += "• Manager reviews reports manually\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"{toggle_emoji} {'Uključi/Isključi AI' if lang == 'sr' else 'Enable/Disable AI'}", callback_data="toggle_ai_analysis")],
                    [InlineKeyboardButton(f"� {get_text('back', lang)}", callback_data="settings")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Toggle AI Analysis
            elif query.data == "toggle_ai_analysis":
                lang = get_user_language(telegram_user_id, self.db)
                hotel_settings = self.db.get_hotel_settings()
                current_state = hotel_settings.get('ai_analysis_enabled', False)
                new_state = not current_state
                
                self.db.update_hotel_settings(ai_analysis_enabled=new_state)
                
                if new_state:
                    await query.answer(get_text('ai_analysis_on', lang), show_alert=True)
                else:
                    await query.answer(get_text('ai_analysis_off', lang), show_alert=True)
                
                # Refresh the menu - rebuild AI settings view
                ai_enabled = new_state
                toggle_emoji = "✅" if ai_enabled else "⬜"
                
                text = f"🤖 {get_text('ai_analysis_settings', lang)}\n\n"
                
                if ai_enabled:
                    if lang == 'sr':
                        text += f"{toggle_emoji} AI Analiza: UKLJUČENA\n\n"
                        text += "📌 Kada je uključeno:\n"
                        text += "• Automatska AI analiza pri slanju izveštaja\n"
                        text += "• Rezultati se šalju menadžeru automatski\n"
                        text += "• Smanjuje ručni rad menadžera\n"
                    else:
                        text += f"{toggle_emoji} AI Analysis: ENABLED\n\n"
                        text += "📌 When enabled:\n"
                        text += "• Automatic AI analysis on report submission\n"
                        text += "• Results are sent to managers automatically\n"
                        text += "• Reduces manager's manual work\n"
                else:
                    if lang == 'sr':
                        text += f"{toggle_emoji} AI Analiza: ISKLJUČENA\n\n"
                        text += "📌 Kada je isključeno:\n"
                        text += "• Podaci se čuvaju bez automatske analize\n"
                        text += "• Menadžer pregleda izveštaje ručno\n"
                    else:
                        text += f"{toggle_emoji} AI Analysis: DISABLED\n\n"
                        text += "📌 When disabled:\n"
                        text += "• Data is saved without automatic analysis\n"
                        text += "• Manager reviews reports manually\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"{toggle_emoji} {'Uključi/Isključi AI' if lang == 'sr' else 'Enable/Disable AI'}", callback_data="toggle_ai_analysis")],
                    [InlineKeyboardButton(f"� {get_text('back', lang)}", callback_data="settings")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ==================== SHIFT MANAGEMENT ====================
            # Shift Management Main Menu
            elif query.data == "shift_management":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get current shift status
                summary = get_shift_status_summary(self.db)
                
                shift_icons = {'A': '🌅', 'B': '🌆', 'C': '🌙'}
                shift_names = {
                    'A': get_text('shift_a_morning', lang),
                    'B': get_text('shift_b_evening', lang), 
                    'C': get_text('shift_c_night', lang)
                }
                
                current_shift = summary.get('current_shift', 'N/A')
                current_time = summary.get('current_time', '--:--')
                
                text = f"""👥 **{get_text('shift_management', lang)}**

🕐 {get_text('current_time', lang)}: {current_time}
{shift_icons.get(current_shift, '⏰')} {get_text('current_shift', lang)}: **{current_shift}** - {shift_names.get(current_shift, 'Unknown')}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
                
                # Add quick stats
                departments = summary.get('departments', {})
                if departments:
                    for dept_name, dept_data in departments.items():
                        on_shift = dept_data.get('on_shift_count', 0)
                        total = on_shift + dept_data.get('off_shift_count', 0)
                        text += f"\n📊 {dept_name}: " + get_text('working_now', lang).format(count=on_shift, total=total)
                else:
                    text += f"\n⚠️ {get_text('no_shift_assignments', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(f"📋 {get_text('view_shift_status', lang)}", callback_data="shift_view_status")],
                    [InlineKeyboardButton(f"➕ {get_text('assign_employee', lang)}", callback_data="shift_assign_menu")],
                    [InlineKeyboardButton(f"📜 {get_text('shift_history', lang)}", callback_data="shift_history")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="settings")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
            # View Shift Status (Detailed)
            elif query.data == "shift_view_status":
                lang = get_user_language(telegram_user_id, self.db)
                
                summary = get_shift_status_summary(self.db)
                
                shift_icons = {'A': '🌅', 'B': '🌆', 'C': '🌙'}
                shift_names = {
                    'A': get_text('shift_a_morning', lang),
                    'B': get_text('shift_b_evening', lang), 
                    'C': get_text('shift_c_night', lang)
                }
                
                current_shift = summary.get('current_shift', 'N/A')
                current_time = summary.get('current_time', '--:--')
                
                text = f"""📋 **{get_text('detailed_shift_status', lang)}**

🕐 {get_text('current_time', lang)}: {current_time}
{shift_icons.get(current_shift, '⏰')} {get_text('current_shift', lang)}: **{current_shift}** - {shift_names.get(current_shift, 'Unknown')}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
                
                departments = summary.get('departments', {})
                if departments:
                    for dept_name, dept_data in departments.items():
                        text += f"\n📊 **{dept_name}**\n"
                        text += f"   🟢 {get_text('on_shift', lang)}: " + get_text('employees_count', lang).format(count=dept_data.get('on_shift_count', 0)) + "\n"
                        text += f"   ⏭️ {get_text('off_shift', lang)}: " + get_text('employees_count', lang).format(count=dept_data.get('off_shift_count', 0)) + "\n"
                        total_emps = dept_data.get('A', 0) + dept_data.get('B', 0) + dept_data.get('C', 0)
                        text += f"   {get_text('total_employees', lang)}: {total_emps}\n"
                        text += f"   {get_text('distribution', lang)}: A:{dept_data.get('A', 0)} | B:{dept_data.get('B', 0)} | C:{dept_data.get('C', 0)}\n"
                    
                    # Get ON-SHIFT employees
                    text += "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"👥 **{get_text('on_shift_employees', lang)}:**\n\n"
                    
                    for dept_name in ['Reception', 'Restaurant']:
                        if dept_name in departments:
                            on_shift_emps = get_on_shift_employees(self.db, dept_name)
                            if on_shift_emps:
                                text += f"**{dept_name}:**\n"
                                for emp in on_shift_emps:
                                    text += f"  • {emp['name']} ({emp['employee_id']}) - Shift {emp['shift_type']}\n"
                                text += "\n"
                else:
                    text += f"\n⚠️ {get_text('no_shift_assignments', lang)}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"🔄 {get_text('refresh', lang)}", callback_data="shift_view_status")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="shift_management")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
            # Assign Shift Menu - Select Department
            elif query.data == "shift_assign_menu":
                lang = get_user_language(telegram_user_id, self.db)
                
                text = f"➕ **{get_text('assign_shift', lang)}**\n\n{get_text('select_department', lang)}:"
                
                keyboard = [
                    [InlineKeyboardButton("🏨 Reception", callback_data="shift_assign_dept_Reception")],
                    [InlineKeyboardButton("🍽️ Restaurant", callback_data="shift_assign_dept_Restaurant")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="shift_management")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
            # Select Employee from Department
            elif query.data.startswith("shift_assign_dept_"):
                lang = get_user_language(telegram_user_id, self.db)
                department = query.data.replace("shift_assign_dept_", "")
                
                # Get all employees from tbl_employeer table
                employees = self.db.execute_query("""
                    SELECT employee_id, name, work_role, telegram_user_id
                    FROM tbl_employeer
                    WHERE department = %s
                    ORDER BY employee_id
                """, (department,))
                
                if not employees or len(employees) == 0:
                    text = f"⚠️ **{get_text('no_employees_in_dept', lang)}**\n\n{department}"
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="shift_assign_menu")]]
                else:
                    text = f"👥 **{get_text('select_employee', lang)}**\n\n📍 {department}\n\n"
                    
                    keyboard = []
                    for emp in employees:
                        emp_id = emp[0]
                        emp_name = emp[1]
                        work_role = emp[2] if emp[2] else ""
                        
                        # Check if employee already has shift
                        from shift_operations import get_employee_shift_info
                        shift_info = get_employee_shift_info(self.db, emp_id)
                        
                        if shift_info:
                            shift_type = shift_info['shift_type']
                            button_text = f"{emp_name} ({emp_id}) - Shift {shift_type}"
                        else:
                            button_text = f"{emp_name} ({emp_id})"
                        
                        if work_role:
                            button_text += f" [{work_role}]"
                        
                        keyboard.append([InlineKeyboardButton(
                            button_text, 
                            callback_data=f"shift_select_emp_{department}_{emp_id}"
                        )])
                    
                    keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="shift_assign_menu")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
            # Select Shift Type for Employee
            elif query.data.startswith("shift_select_emp_"):
                lang = get_user_language(telegram_user_id, self.db)
                parts = query.data.replace("shift_select_emp_", "").split("_")
                department = parts[0]
                employee_id = "_".join(parts[1:])  # Handle IDs like REST_001
                
                # Get employee info
                emp_info = self.db.execute_query("""
                    SELECT name, work_role, telegram_user_id
                    FROM tbl_employeer
                    WHERE employee_id = %s
                """, (employee_id,))
                
                if not emp_info or len(emp_info) == 0:
                    await query.answer("❌ Employee not found", show_alert=True)
                    return
                
                emp_name = emp_info[0][0]
                work_role = emp_info[0][1] if emp_info[0][1] else ""
                emp_telegram_id = emp_info[0][2]
                
                # Get current shift if any
                from shift_operations import get_employee_shift_info, get_available_shifts, get_shift_info
                shift_info = get_employee_shift_info(self.db, employee_id)
                
                current_shift_text = ""
                if shift_info:
                    current_shift = shift_info['shift_type']
                    current_shift_text = f"\n{get_text('current_shift_info', lang).format(shift=current_shift)}"
                else:
                    current_shift_text = f"\n{get_text('current_shift_info', lang).format(shift=get_text('not_assigned', lang))}"
                
                text = f"⏰ **{get_text('select_shift_type', lang)}**\n\n"
                text += get_text('employee_info', lang).format(name=emp_name, id=employee_id)
                if work_role:
                    text += f" [{work_role}]"
                text += current_shift_text
                text += f"\n\n{get_text('select_department', lang)}: {department}"
                
                # Get available shifts from configuration
                available_shifts = get_available_shifts()
                
                keyboard = []
                for shift_type in available_shifts:
                    shift_cfg = get_shift_info(shift_type)
                    if shift_cfg:
                        icon = shift_cfg['icon']
                        name = shift_cfg['name']
                        time_range = f"{shift_cfg['start']}-{shift_cfg['end']}"
                        
                        # Translate shift name
                        shift_key = f"shift_{shift_type.lower()}_morning"
                        if shift_type == 'B':
                            shift_key = f"shift_{shift_type.lower()}_evening"
                        elif shift_type == 'C':
                            shift_key = f"shift_{shift_type.lower()}_night"
                        
                        shift_name = get_text(shift_key, lang)
                        
                        button_text = f"{icon} {shift_type}: {shift_name}"
                        keyboard.append([InlineKeyboardButton(
                            button_text,
                            callback_data=f"shift_confirm_{department}_{employee_id}_{shift_type}"
                        )])
                
                # Add remove shift option if employee has a shift
                if shift_info:
                    keyboard.append([InlineKeyboardButton(
                        f"❌ {get_text('remove_shift', lang)}",
                        callback_data=f"shift_remove_{department}_{employee_id}"
                    )])
                
                keyboard.append([InlineKeyboardButton(
                    f"🔙 {get_text('back', lang)}",
                    callback_data=f"shift_assign_dept_{department}"
                )])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
            # Confirm and Assign Shift
            elif query.data.startswith("shift_confirm_"):
                lang = get_user_language(telegram_user_id, self.db)
                parts = query.data.replace("shift_confirm_", "").split("_")
                department = parts[0]
                shift_type = parts[-1]
                employee_id = "_".join(parts[1:-1])
                
                # Get employee info
                emp_info = self.db.execute_query("""
                    SELECT name, telegram_user_id
                    FROM tbl_employeer
                    WHERE employee_id = %s
                """, (employee_id,))
                
                if not emp_info or len(emp_info) == 0:
                    await query.answer("❌ Employee not found", show_alert=True)
                    return
                
                emp_name = emp_info[0][0]
                emp_telegram_id = emp_info[0][1] if emp_info[0][1] else 0
                
                # Assign shift
                from shift_operations import assign_shift_to_employee
                success = assign_shift_to_employee(
                    self.db, employee_id, emp_telegram_id, 
                    shift_type, department, emp_name
                )
                
                if success:
                    await query.answer(f"✅ {get_text('shift_assigned_success', lang)}", show_alert=True)
                    
                    # Show success message and return to employee list
                    # Get employees for this department
                    employees = self.db.execute_query("""
                        SELECT employee_id, name, work_role, telegram_user_id
                        FROM tbl_employeer
                        WHERE department = %s
                        ORDER BY employee_id
                    """, (department,))
                    
                    if employees and len(employees) > 0:
                        text = f"✅ **{get_text('shift_assigned_success', lang)}**\n\n"
                        text += f"👤 {emp_name} ({employee_id}) → Shift {shift_type}\n\n"
                        text += f"👥 **{get_text('select_employee', lang)}**\n\n📍 {department}\n\n"
                        
                        keyboard = []
                        for emp in employees:
                            emp_id = emp[0]
                            emp_name_list = emp[1]
                            work_role = emp[2] if emp[2] else ""
                            
                            # Check if employee already has shift
                            from shift_operations import get_employee_shift_info
                            shift_info = get_employee_shift_info(self.db, emp_id)
                            
                            if shift_info:
                                shift_type_display = shift_info['shift_type']
                                button_text = f"{emp_name_list} ({emp_id}) - Shift {shift_type_display}"
                            else:
                                button_text = f"{emp_name_list} ({emp_id})"
                            
                            if work_role:
                                button_text += f" [{work_role}]"
                            
                            keyboard.append([InlineKeyboardButton(
                                button_text, 
                                callback_data=f"shift_select_emp_{department}_{emp_id}"
                            )])
                        
                        keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="shift_assign_menu")])
                        
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
                    else:
                        await query.edit_message_text(
                            f"✅ **{get_text('shift_assigned_success', lang)}**\n\n"
                            f"👤 {emp_name} ({employee_id})\n"
                            f"⏰ Shift {shift_type}",
                            parse_mode='Markdown'
                        )
                else:
                    await query.answer(f"❌ {get_text('shift_update_failed', lang)}", show_alert=True)
            
            # Remove Shift from Employee
            elif query.data.startswith("shift_remove_"):
                lang = get_user_language(telegram_user_id, self.db)
                parts = query.data.replace("shift_remove_", "").split("_")
                department = parts[0]
                employee_id = "_".join(parts[1:])
                
                # Get employee info
                emp_info = self.db.execute_query("""
                    SELECT name
                    FROM tbl_employeer
                    WHERE employee_id = %s
                """, (employee_id,))
                
                if not emp_info or len(emp_info) == 0:
                    await query.answer("❌ Employee not found", show_alert=True)
                    return
                
                emp_name = emp_info[0][0]
                
                # Remove shift
                from shift_operations import remove_shift_from_employee
                success = remove_shift_from_employee(self.db, employee_id)
                
                if success:
                    await query.answer(f"✅ {get_text('shift_removed', lang)}", show_alert=True)
                    
                    # Show success message and return to employee list
                    # Get employees for this department
                    employees = self.db.execute_query("""
                        SELECT employee_id, name, work_role, telegram_user_id
                        FROM tbl_employeer
                        WHERE department = %s
                        ORDER BY employee_id
                    """, (department,))
                    
                    if employees and len(employees) > 0:
                        text = f"✅ **{get_text('shift_removed', lang)}**\n\n"
                        text += f"👤 {emp_name} ({employee_id})\n\n"
                        text += f"👥 **{get_text('select_employee', lang)}**\n\n📍 {department}\n\n"
                        
                        keyboard = []
                        for emp in employees:
                            emp_id = emp[0]
                            emp_name_list = emp[1]
                            work_role = emp[2] if emp[2] else ""
                            
                            # Check if employee already has shift
                            from shift_operations import get_employee_shift_info
                            shift_info = get_employee_shift_info(self.db, emp_id)
                            
                            if shift_info:
                                shift_type_display = shift_info['shift_type']
                                button_text = f"{emp_name_list} ({emp_id}) - Shift {shift_type_display}"
                            else:
                                button_text = f"{emp_name_list} ({emp_id})"
                            
                            if work_role:
                                button_text += f" [{work_role}]"
                            
                            keyboard.append([InlineKeyboardButton(
                                button_text, 
                                callback_data=f"shift_select_emp_{department}_{emp_id}"
                            )])
                        
                        keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="shift_assign_menu")])
                        
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
                    else:
                        await query.edit_message_text(
                            f"✅ **{get_text('shift_removed', lang)}**\n\n"
                            f"👤 {emp_name} ({employee_id})",
                            parse_mode='Markdown'
                        )
                else:
                    await query.answer(f"❌ {get_text('shift_update_failed', lang)}", show_alert=True)
            
            # Shift History
            elif query.data == "shift_history":
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get all active shift assignments
                shift_records = self.db.execute_query("""
                    SELECT s.employee_id, s.employee_name, s.shift_type, s.department,
                           e.work_role
                    FROM tbl_employee_shifts s
                    LEFT JOIN tbl_employeer e ON s.employee_id = e.employee_id
                    WHERE s.is_active = 1
                    ORDER BY s.department, s.shift_type, s.employee_id
                """)
                
                from shift_operations import get_shift_info
                
                text = f"📜 **{get_text('shift_history', lang)}**\n\n"
                
                if shift_records and len(shift_records) > 0:
                    text += f"� {get_text('total_employees', lang)}: {len(shift_records)}\n\n"
                    
                    # Group by department
                    current_dept = None
                    for record in shift_records:
                        emp_id, emp_name, shift_type, dept, work_role = record
                        
                        if dept != current_dept:
                            current_dept = dept
                            text += f"\n📍 **{dept}**\n"
                            text += "━━━━━━━━━━━━━━━━━━━━\n"
                        
                        # Get shift info
                        shift_cfg = get_shift_info(shift_type)
                        shift_icon = shift_cfg['icon'] if shift_cfg else '⏰'
                        
                        # Translate shift name
                        shift_key = f"shift_{shift_type.lower()}_morning"
                        if shift_type == 'B':
                            shift_key = f"shift_{shift_type.lower()}_evening"
                        elif shift_type == 'C':
                            shift_key = f"shift_{shift_type.lower()}_night"
                        shift_name = get_text(shift_key, lang)
                        
                        text += f"{shift_icon} **{shift_type}** - {shift_name}\n"
                        text += f"   👤 {emp_name} ({emp_id})"
                        if work_role:
                            text += f" - {work_role}"
                        text += "\n"
                    
                    text += f"\n━━━━━━━━━━━━━━━━━━━━\n"
                    
                    # Add shift statistics
                    text += f"\n📊 **{get_text('distribution', lang)}**:\n"
                    
                    shift_counts = self.db.execute_query("""
                        SELECT shift_type, COUNT(*) as count
                        FROM tbl_employee_shifts
                        WHERE is_active = 1
                        GROUP BY shift_type
                        ORDER BY shift_type
                    """)
                    
                    if shift_counts:
                        for shift_type, count in shift_counts:
                            text += f"   Shift {shift_type}: {count} {get_text('employees_count', lang).format(count=count)}\n"
                    
                else:
                    text += f"⚠️ {get_text('no_shift_assignments', lang)}\n"
                    text += f"\n💡 {get_text('assign_employee', lang)}: Settings → Shift Management → ➕ Assign Employee"
                
                keyboard = [
                    [InlineKeyboardButton(f"🔄 {get_text('refresh', lang)}", callback_data="shift_history")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="shift_management")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
            # ==================== END SHIFT MANAGEMENT ====================
            
            # Notification Settings Menu
            elif query.data == "settings_notifications":
                lang = get_user_language(telegram_user_id, self.db)
                hotel_settings = self.db.get_hotel_settings()
                email_enabled = hotel_settings.get('email_notifications_enabled', False)
                whatsapp_enabled = hotel_settings.get('whatsapp_notifications_enabled', False)
                
                email_status = get_text('email_notifications_enabled', lang) if email_enabled else get_text('email_notifications_disabled', lang)
                whatsapp_status = get_text('whatsapp_notifications_enabled', lang) if whatsapp_enabled else get_text('whatsapp_notifications_disabled', lang)
                
                email_emoji = "✅" if email_enabled else "⬜"
                whatsapp_emoji = "✅" if whatsapp_enabled else "⬜"
                
                text = f"🔔 {get_text('notification_settings', lang)}\n\n"
                text += f"{email_emoji} {email_status}\n"
                text += f"{whatsapp_emoji} {whatsapp_status}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"{email_emoji} {get_text('email_notifications', lang)}", callback_data="toggle_email_notifications")],
                    [InlineKeyboardButton(f"{whatsapp_emoji} {get_text('whatsapp_notifications', lang)}", callback_data="toggle_whatsapp_notifications")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="settings")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Toggle Email Notifications
            elif query.data == "toggle_email_notifications":
                lang = get_user_language(telegram_user_id, self.db)
                hotel_settings = self.db.get_hotel_settings()
                current_state = hotel_settings.get('email_notifications_enabled', False)
                new_state = not current_state
                
                self.db.update_hotel_settings(email_notifications_enabled=new_state)
                
                if new_state:
                    await query.answer(get_text('email_on', lang), show_alert=True)
                else:
                    await query.answer(get_text('email_off', lang), show_alert=True)
                
                # Refresh notification settings
                hotel_settings = self.db.get_hotel_settings()
                email_enabled = hotel_settings.get('email_notifications_enabled', False)
                whatsapp_enabled = hotel_settings.get('whatsapp_notifications_enabled', False)
                
                email_status = get_text('email_notifications_enabled', lang) if email_enabled else get_text('email_notifications_disabled', lang)
                whatsapp_status = get_text('whatsapp_notifications_enabled', lang) if whatsapp_enabled else get_text('whatsapp_notifications_disabled', lang)
                
                email_emoji = "✅" if email_enabled else "⬜"
                whatsapp_emoji = "✅" if whatsapp_enabled else "⬜"
                
                text = f"🔔 {get_text('notification_settings', lang)}\n\n"
                text += f"{email_emoji} {email_status}\n"
                text += f"{whatsapp_emoji} {whatsapp_status}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"{email_emoji} {get_text('email_notifications', lang)}", callback_data="toggle_email_notifications")],
                    [InlineKeyboardButton(f"{whatsapp_emoji} {get_text('whatsapp_notifications', lang)}", callback_data="toggle_whatsapp_notifications")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="settings")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Toggle WhatsApp Notifications
            elif query.data == "toggle_whatsapp_notifications":
                lang = get_user_language(telegram_user_id, self.db)
                hotel_settings = self.db.get_hotel_settings()
                current_state = hotel_settings.get('whatsapp_notifications_enabled', False)
                new_state = not current_state
                
                self.db.update_hotel_settings(whatsapp_notifications_enabled=new_state)
                
                if new_state:
                    await query.answer(get_text('whatsapp_on', lang), show_alert=True)
                else:
                    await query.answer(get_text('whatsapp_off', lang), show_alert=True)
                
                # Refresh notification settings
                hotel_settings = self.db.get_hotel_settings()
                email_enabled = hotel_settings.get('email_notifications_enabled', False)
                whatsapp_enabled = hotel_settings.get('whatsapp_notifications_enabled', False)
                
                email_status = get_text('email_notifications_enabled', lang) if email_enabled else get_text('email_notifications_disabled', lang)
                whatsapp_status = get_text('whatsapp_notifications_enabled', lang) if whatsapp_enabled else get_text('whatsapp_notifications_disabled', lang)
                
                email_emoji = "✅" if email_enabled else "⬜"
                whatsapp_emoji = "✅" if whatsapp_enabled else "⬜"
                
                text = f"🔔 {get_text('notification_settings', lang)}\n\n"
                text += f"{email_emoji} {email_status}\n"
                text += f"{whatsapp_emoji} {whatsapp_status}\n"
                
                keyboard = [
                    [InlineKeyboardButton(f"{email_emoji} {get_text('email_notifications', lang)}", callback_data="toggle_email_notifications")],
                    [InlineKeyboardButton(f"{whatsapp_emoji} {get_text('whatsapp_notifications', lang)}", callback_data="toggle_whatsapp_notifications")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="settings")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # ==================== ACTION HISTORY HANDLERS ====================
            
            # Action History Menu
            elif query.data == "action_history_menu":
                from database import get_action_dates
                
                lang = get_user_language(telegram_user_id, self.db)
                dates = get_action_dates(self.db, limit=30)
                
                text = "📋 <b>Action History</b>\n\n"
                text += "📅 Select a date to view actions:\n"
                text += "🏢 Or filter by department\n\n"
                
                keyboard = []
                
                # Date buttons (3 per row)
                date_row = []
                for date_info in dates[:12]:
                    date = date_info['date']
                    count = date_info['count']
                    # Convert date to string if it's a date object
                    date_str = str(date) if not isinstance(date, str) else date
                    short_date = date_str[5:]  # MM-DD format
                    date_row.append(InlineKeyboardButton(
                        f"📅 {short_date} ({count})",
                        callback_data=f"action_date_{date_str}_1"
                    ))
                    if len(date_row) == 3:
                        keyboard.append(date_row)
                        date_row = []
                if date_row:
                    keyboard.append(date_row)
                
                if not dates:
                    text += "No action history found.\n"
                
                # Department filter buttons
                keyboard.append([InlineKeyboardButton("🏢 Filter by Department", callback_data="action_dept_filter")])
                keyboard.append([InlineKeyboardButton("📊 All History (Today)", callback_data=f"action_date_all_1")])
                keyboard.append([InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="settings")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='HTML')
            
            # Department filter menu
            elif query.data == "action_dept_filter":
                lang = get_user_language(telegram_user_id, self.db)
                
                departments = self.db.get_departments()
                
                text = "📋 <b>Action History</b>\n\n"
                text += "🏢 Select department to filter:\n\n"
                
                keyboard = []
                for dept in departments:
                    dept_id, dept_name = dept[0], dept[1]
                    keyboard.append([InlineKeyboardButton(
                        f"🏢 {dept_name}",
                        callback_data=f"action_dept_{dept_name}_1"
                    )])
                
                keyboard.append([InlineKeyboardButton("📊 All Departments", callback_data="action_date_all_1")])
                keyboard.append([InlineKeyboardButton("🔙 Back", callback_data="action_history_menu")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='HTML')
            
            # View Actions by Department with pagination
            elif query.data.startswith("action_dept_"):
                from database import get_action_history_by_date
                
                lang = get_user_language(telegram_user_id, self.db)
                parts = query.data.replace("action_dept_", "").rsplit("_", 1)
                dept_name = parts[0]
                page = int(parts[1]) if len(parts) > 1 else 1
                
                # Get all actions and filter by department
                all_actions = get_action_history_by_date(self.db, None, limit=500)
                actions = [a for a in all_actions if a.get('department') == dept_name]
                
                # Pagination
                items_per_page = 15
                total_pages = max(1, (len(actions) + items_per_page - 1) // items_per_page)
                page = max(1, min(page, total_pages))
                start_idx = (page - 1) * items_per_page
                end_idx = min(start_idx + items_per_page, len(actions))
                page_actions = actions[start_idx:end_idx]
                
                text = f"📋 <b>Action History - {dept_name}</b>\n"
                text += f"📄 Page {page}/{total_pages} (Total: {len(actions)})\n"
                text += f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                for action in page_actions:
                    timestamp = action['timestamp']
                    # timestamp may be a datetime object or a string
                    if hasattr(timestamp, 'strftime'):
                        date_part = timestamp.strftime('%Y-%m-%d')
                        time_part = timestamp.strftime('%H:%M')
                    else:
                        date_part = str(timestamp).split(' ')[0] if ' ' in str(timestamp) else str(timestamp)
                        time_part = str(timestamp).split(' ')[1][:5] if ' ' in str(timestamp) else ''
                    name = action['employee_name']
                    action_type = action['action_type']
                    # action_detail may be JSONB (dict) or string
                    raw_detail = action['action_detail']
                    if raw_detail:
                        detail = str(raw_detail)[:30] if isinstance(raw_detail, (dict, list)) else raw_detail[:30]
                    else:
                        detail = ''
                    
                    text += f"🕐 {date_part} {time_part}\n"
                    text += f"   👤 {name}: {action_type}\n"
                    if detail:
                        text += f"   📌 {detail}\n"
                    text += "\n"
                
                if not page_actions:
                    text += "No actions found.\n"
                
                keyboard = []
                # Pagination
                if total_pages > 1:
                    nav_row = []
                    if page > 1:
                        nav_row.append(InlineKeyboardButton("⬅️ Prev", callback_data=f"action_dept_{dept_name}_{page-1}"))
                    nav_row.append(InlineKeyboardButton(f"📄 {page}/{total_pages}", callback_data="noop"))
                    if page < total_pages:
                        nav_row.append(InlineKeyboardButton("Next ➡️", callback_data=f"action_dept_{dept_name}_{page+1}"))
                    keyboard.append(nav_row)
                
                keyboard.append([InlineKeyboardButton("🏢 Departments", callback_data="action_dept_filter")])
                keyboard.append([InlineKeyboardButton("🔙 Back", callback_data="action_history_menu")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='HTML')
            
            # View Actions by Date with pagination
            elif query.data.startswith("action_date_"):
                from database import get_action_history_by_date, get_action_statistics
                
                lang = get_user_language(telegram_user_id, self.db)
                parts = query.data.replace("action_date_", "").rsplit("_", 1)
                date = parts[0]
                page = int(parts[1]) if len(parts) > 1 else 1
                
                # Get actions
                if date == "all":
                    actions = get_action_history_by_date(self.db, None, limit=500)
                    title = "All History"
                else:
                    actions = get_action_history_by_date(self.db, date, limit=500)
                    title = date
                
                # Pagination
                items_per_page = 15
                total_pages = max(1, (len(actions) + items_per_page - 1) // items_per_page)
                page = max(1, min(page, total_pages))
                start_idx = (page - 1) * items_per_page
                end_idx = min(start_idx + items_per_page, len(actions))
                page_actions = actions[start_idx:end_idx]
                
                text = f"📋 <b>Action History - {title}</b>\n"
                text += f"📄 Page {page}/{total_pages} (Total: {len(actions)})\n"
                text += f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                # Action type emoji mapping
                action_emoji = {
                    'create': '➕',
                    'update': '✏️',
                    'delete': '🗑️',
                    'complete': '✅',
                    'accept': '👍',
                    'reject': '❌',
                    'confirm': '✔️',
                    'login': '🔐',
                    'logout': '🚪',
                    'check_in': '📥',
                    'check_out': '📤',
                    'assign': '📌',
                    'send': '📧',
                    'view': '👁️',
                    'error': '⚠️'
                }
                
                for action in page_actions:
                    timestamp = action['timestamp']
                    timestamp_str = str(timestamp) if not isinstance(timestamp, str) else timestamp
                    date_part = timestamp_str.split(' ')[0] if ' ' in timestamp_str else timestamp_str
                    time_part = timestamp_str.split(' ')[1][:5] if ' ' in timestamp_str else ''
                    name = action['employee_name']
                    dept = action.get('department', '')
                    action_type = action['action_type']
                    entity_type = action.get('entity_type', '')
                    entity_id = action.get('entity_id', '')
                    
                    # Get appropriate emoji
                    emoji = action_emoji.get(action_type, '📋')
                    
                    # Format entity information
                    entity_info = ''
                    if entity_type and entity_id:
                        entity_info = f" #{entity_id}"
                    
                    # Parse action_detail for meaningful information
                    raw_detail = action['action_detail']
                    detail_text = ''
                    
                    if raw_detail:
                        if isinstance(raw_detail, dict):
                            # Extract meaningful keys
                            if 'description' in raw_detail:
                                detail_text = raw_detail['description'][:40]
                            elif 'status' in raw_detail:
                                detail_text = f"Status: {raw_detail['status']}"
                            elif 'result' in raw_detail and raw_detail['result'] != 'success':
                                detail_text = f"Result: {raw_detail['result']}"
                            elif action_type == 'login':
                                detail_text = f"Dept: {raw_detail.get('department', 'N/A')}"
                            else:
                                # Show first relevant key-value pair
                                for key in ['task_id', 'event_name', 'report_notes', 'stock', 'assignee']:
                                    if key in raw_detail:
                                        detail_text = f"{key}: {str(raw_detail[key])[:30]}"
                                        break
                        else:
                            detail_text = str(raw_detail)[:40]
                    
                    # Build action line
                    text += f"🕐 {time_part} - <b>{name}</b>"
                    if dept:
                        text += f" ({dept})"
                    text += f"\n   {emoji} <b>{action_type.upper()}</b>"
                    
                    if entity_type:
                        text += f" {entity_type}"
                    if entity_info:
                        text += entity_info
                    if detail_text:
                        text += f"\n   💬 {detail_text}"
                    
                    text += "\n\n"
                
                if not page_actions:
                    text += "No actions found.\n"
                
                keyboard = []
                # Pagination
                if total_pages > 1:
                    nav_row = []
                    if page > 1:
                        nav_row.append(InlineKeyboardButton("⬅️ Prev", callback_data=f"action_date_{date}_{page-1}"))
                    nav_row.append(InlineKeyboardButton(f"📄 {page}/{total_pages}", callback_data="noop"))
                    if page < total_pages:
                        nav_row.append(InlineKeyboardButton("Next ➡️", callback_data=f"action_date_{date}_{page+1}"))
                    keyboard.append(nav_row)
                
                keyboard.append([InlineKeyboardButton("🏢 Filter by Dept", callback_data="action_dept_filter")])
                keyboard.append([InlineKeyboardButton("🔙 Back", callback_data="action_history_menu")])
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='HTML')
            
            # Legacy view_actions handler (redirect to new)
            elif query.data.startswith("view_actions_"):
                date = query.data.replace("view_actions_", "")
                query.data = f"action_date_{date}_1"
                await self.button_handler(update, context)
                return
            
            # ==================== END ACTION HISTORY ====================
            
            # ==================== Shift Report Handlers ====================
            
            # Start shift report now (from notification with task ID)
            elif query.data.startswith("shift_report_now_"):
                from templates import get_shift_report_input_template
                
                lang = get_user_language(telegram_user_id, self.db)
                # Format: shift_report_now_{shift_number}_{task_id}
                parts = query.data.replace("shift_report_now_", "").split("_")
                shift_number = int(parts[0])
                task_id = int(parts[1]) if len(parts) > 1 and parts[1] != '0' else None
                
                # Get employee department
                employee = self.db.check_employee_exists(telegram_user_id)
                department = 'Reception'  # Default
                if employee:
                    department = employee[2] if employee[2] else 'Reception'  # employee[2] is department
                
                # Store shift number, task ID, and department in context
                if telegram_user_id not in self.user_context:
                    self.user_context[telegram_user_id] = {}
                self.user_context[telegram_user_id]['reporting_shift'] = shift_number
                self.user_context[telegram_user_id]['shift_report'] = {}
                self.user_context[telegram_user_id]['shift_report_step'] = 1
                self.user_context[telegram_user_id]['shift_report_department'] = department
                if task_id:
                    self.user_context[telegram_user_id]['shift_report_task_id'] = task_id
                
                # Get template for step 1 based on department
                step_template = get_shift_report_input_template(lang, 1, department)
                
                text = f"📋 {get_text('shift_change_report', lang)} - {get_text('shift_number', lang)} {shift_number}\n"
                text += f"🏢 Department: {department}\n\n"
                text += f"━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{step_template['title']}\n"
                text += f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{step_template['prompt']}"
                if step_template.get('hint'):
                    text += f"\n\n💡 {step_template['hint']}"
                
                keyboard = [[InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                # Set awaiting flag based on department and step 1 field
                if department == 'Restaurant':
                    self.user_context[telegram_user_id]['awaiting_guests_served'] = True
                else:  # Reception
                    self.user_context[telegram_user_id]['awaiting_reservations_count'] = True
                    
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Report later - dismiss notification
            elif query.data == "shift_report_later":
                lang = get_user_language(telegram_user_id, self.db)
                await query.edit_message_text(
                    f"⏰ {get_text('report_later_message', lang)}\n\n"
                    f"📋 Use /start → {get_text('report_task', lang)} or {get_text('new_task_notification', lang)}"
                )
            
            # Shift notification acknowledged (for restaurant employees)
            elif query.data == "shift_notif_ack":
                lang = get_user_language(telegram_user_id, self.db)
                await query.edit_message_text(
                    f"✅ {get_text('notification_acknowledged', lang)}\n\n"
                    f"ℹ️ {get_text('reception_handling_report', lang)}"
                )
            
            # Go to main menu - show main menu directly
            elif query.data == "go_main_menu":
                lang = get_user_language(telegram_user_id, self.db)
                # Send a new message with the main menu
                await query.message.reply_text(
                    f"🏠 {get_text('main_menu', lang)}\n\n"
                    f"💡 Type /start to see the full menu.",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔄 /start", callback_data="emp_start_menu")
                    ]])
                )
            
            # Employee start menu via button - show employee menu
            elif query.data == "emp_start_menu" or query.data == "cmd_start":
                # Get employee info and show main menu (same as start_command)
                employee = self.db.check_employee_exists(telegram_user_id)
                if employee:
                    employee_id, name, department, work_role, gmail, whatsapp = employee
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    # Get unread task count
                    unread_count = self.db.get_unread_task_count(telegram_user_id, department)
                    notification_text = get_text('new_task_notification_count', lang).format(unread_count) if unread_count > 0 else get_text('new_task_notification', lang)
                    
                    # Get reportable task count
                    reportable_tasks = self.db.get_reportable_tasks(telegram_user_id, department)
                    report_count = len(reportable_tasks)
                    report_text = get_text('report_task_count', lang).format(report_count) if report_count > 0 else get_text('report_task', lang)
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('tasks', lang), callback_data="emp_work_menu"),
                         InlineKeyboardButton(report_text, callback_data="emp_report_task")],
                        [InlineKeyboardButton(notification_text, callback_data="emp_notifications")],
                        [InlineKeyboardButton(get_text('schedule', lang), callback_data="emp_schedule_menu"),
                         InlineKeyboardButton(get_text('complaint', lang), callback_data="emp_complaint")],
                        [InlineKeyboardButton(get_text('profile', lang), callback_data="emp_profile"),
                         InlineKeyboardButton(get_text('settings', lang), callback_data="emp_settings")]
                    ]
                    # Add Service Contacts button for Reception department
                    if department == 'Reception':
                        keyboard.insert(3, [InlineKeyboardButton(f"📞 {get_text('service_contacts', lang)}", callback_data="admin_contacts")])
                    
                    await query.message.reply_text(
                        f"🏨 {get_text('welcome_back', lang).format(name)}\n\n{get_text('select_option', lang)}",
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                else:
                    await query.message.reply_text("💡 Type /start to see the main menu.")
            
            # Start shift report submission
            elif query.data.startswith("shift_report_start_"):
                from templates import get_shift_report_input_template
                
                lang = get_user_language(telegram_user_id, self.db)
                shift_number = int(query.data.replace("shift_report_start_", ""))
                
                # Store shift number in context
                if telegram_user_id not in self.user_context:
                    self.user_context[telegram_user_id] = {}
                self.user_context[telegram_user_id]['reporting_shift'] = shift_number
                self.user_context[telegram_user_id]['shift_report'] = {}
                self.user_context[telegram_user_id]['shift_report_step'] = 1
                
                # Get template for step 1
                step_template = get_shift_report_input_template(lang, 1)
                
                text = f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_number}\n\n"
                text += f"━━━━━━━━━━━━━━━━━━━━━━\n"
                text += f"{step_template['title']}\n"
                text += f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += f"{step_template['prompt']}"
                
                keyboard = [[InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                self.user_context[telegram_user_id]['awaiting_reservations_count'] = True
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Remind later for shift report
            elif query.data.startswith("shift_report_remind_"):
                import asyncio
                
                lang = get_user_language(telegram_user_id, self.db)
                shift_number = int(query.data.replace("shift_report_remind_", ""))
                
                await query.edit_message_text(
                    f"⏰ {get_text('reminder_set', lang)} (15 min)\n\n{get_text('shift_number', lang)}: {shift_number}"
                )
                
                # Schedule reminder after 15 minutes
                async def send_reminder():
                    await asyncio.sleep(15 * 60)  # 15 minutes
                    try:
                        await self.send_shift_report_request(shift_number, "Reminder")
                    except:
                        pass
                
                asyncio.create_task(send_reminder())
            
            # Admin Contact Information Settings
            elif query.data == "settings_contact":
                lang = get_user_language(telegram_user_id, self.db)
                contact_info = self.db.get_employee_contact_info(telegram_user_id)
                
                gmail = contact_info['gmail'] or get_text('not_set', lang)
                whatsapp = contact_info['whatsapp'] or get_text('not_set', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('gmail_settings', lang), callback_data="settings_gmail")],
                    [InlineKeyboardButton(get_text('whatsapp_settings', lang), callback_data="settings_whatsapp")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="information")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                text = f"""{get_text('contact_info', lang)}

━━━━━━━━━━━━━━━━━━
📧 {get_text('current_gmail', lang)}: {gmail}
📱 {get_text('current_whatsapp', lang)}: {whatsapp}
━━━━━━━━━━━━━━━━━━"""
                
                await query.edit_message_text(text, reply_markup=reply_markup)
            
            # Admin Gmail Settings
            elif query.data == "settings_gmail":
                lang = get_user_language(telegram_user_id, self.db)
                contact_info = self.db.get_employee_contact_info(telegram_user_id)
                gmail = contact_info['gmail'] or get_text('not_set', lang)
                
                context.user_data['awaiting_gmail'] = True
                
                keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data="settings_contact")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(
                    f"{get_text('set_gmail', lang)}\n\n{get_text('current_gmail', lang)}: {gmail}\n\n{get_text('enter_gmail', lang)}",
                    reply_markup=reply_markup
                )
            
            # Admin WhatsApp Settings
            elif query.data == "settings_whatsapp":
                lang = get_user_language(telegram_user_id, self.db)
                contact_info = self.db.get_employee_contact_info(telegram_user_id)
                whatsapp = contact_info['whatsapp'] or get_text('not_set', lang)
                
                context.user_data['awaiting_whatsapp'] = True
                
                keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data="settings_contact")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(
                    f"{get_text('set_whatsapp', lang)}\n\n{get_text('current_whatsapp', lang)}: {whatsapp}\n\n{get_text('enter_whatsapp', lang)}",
                    reply_markup=reply_markup
                )
            
            elif query.data == "information":
                # Admin Profile Page
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                
                if not self.db.check_admin(telegram_user_id):
                    await query.edit_message_text(f"❌ {get_text('no_permission', lang)}")
                    return
                
                employee = self.db.check_employee_exists(telegram_user_id)
                
                if employee:
                    employee_id, name, department, work_role, gmail, whatsapp = employee
                    dept_display = get_dept_display(department, lang)
                    
                    # Display contact info with "not set" message if empty
                    gmail = gmail or get_text('not_set', lang)
                    whatsapp = whatsapp or get_text('not_set', lang)
                    work_role = work_role or get_text('not_set', lang)
                    
                    profile_text = f"""{get_text('my_profile', lang)}

━━━━━━━━━━━━━━━━━━
📋 {get_text('personal_info', lang)}
━━━━━━━━━━━━━━━━━━
• {get_text('employee_id', lang)}: {employee_id}
• {get_text('name', lang)}: {name}
• {get_text('department', lang)}: {dept_display}
• {get_text('work_role', lang)}: {work_role}
• {get_text('telegram_id', lang)}: {telegram_user_id}

━━━━━━━━━━━━━━━━━━
📧 {get_text('contact_details', lang)}
━━━━━━━━━━━━━━━━━━
• Gmail: {gmail}
• WhatsApp: {whatsapp}
━━━━━━━━━━━━━━━━━━"""
                    
                    keyboard = [
                        [InlineKeyboardButton(get_text('edit_name', lang), callback_data="admin_profile_edit_name"),
                         InlineKeyboardButton(get_text('edit_department', lang), callback_data="admin_profile_edit_dept")],
                        [InlineKeyboardButton(get_text('edit_work_role', lang), callback_data="admin_profile_edit_role"),
                         InlineKeyboardButton(get_text('edit_contact', lang), callback_data="settings_contact")],
                        [InlineKeyboardButton(get_text('back', lang), callback_data="back_to_admin")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await query.edit_message_text(profile_text, reply_markup=reply_markup)
                else:
                    await query.edit_message_text(f"❌ {get_text('not_registered', lang)}")
            
            # Admin Profile Edit - Name
            elif query.data == "admin_profile_edit_name":
                lang = get_user_language(telegram_user_id, self.db)
                
                if not self.db.check_admin(telegram_user_id):
                    await query.edit_message_text(f"❌ {get_text('no_permission', lang)}")
                    return
                
                employee = self.db.check_employee_exists(telegram_user_id)
                
                if employee:
                    employee_id, name, department, work_role, gmail, whatsapp = employee
                    context.user_data['awaiting_admin_name_change'] = True
                    
                    keyboard = [[InlineKeyboardButton(get_text('cancel', lang), callback_data="information")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await query.edit_message_text(
                        f"{get_text('change_name', lang)}\n\n{get_text('name', lang)}: {name}\n\n{get_text('enter_new_name', lang)}",
                        reply_markup=reply_markup
                    )
            
            # Admin Profile Edit - Department
            elif query.data == "admin_profile_edit_dept":
                lang = get_user_language(telegram_user_id, self.db)
                
                if not self.db.check_admin(telegram_user_id):
                    await query.edit_message_text(f"❌ {get_text('no_permission', lang)}")
                    return
                
                departments = self.db.get_departments(exclude_management=False)
                
                keyboard = []
                for dept_id, dept_name, dept_content in departments:
                    emoji = get_dept_emoji(dept_name)
                    dept_display = get_dept_display(dept_name, lang)
                    keyboard.append([InlineKeyboardButton(
                        f"{emoji} {dept_display}",
                        callback_data=f"admin_profile_set_dept_{dept_name}"
                    )])
                
                keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="information")])
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await query.edit_message_text(
                    f"{get_text('change_department', lang)}\n\n{get_text('select_new_department', lang)}",
                    reply_markup=reply_markup
                )
            
            # Admin Profile Set Department
            elif query.data.startswith("admin_profile_set_dept_"):
                dept_name = query.data.replace("admin_profile_set_dept_", "")
                lang = get_user_language(telegram_user_id, self.db)
                
                if not self.db.check_admin(telegram_user_id):
                    await query.answer(f"❌ {get_text('no_permission', lang)}", show_alert=True)
                    return
                
                if self.db.update_employee_department(telegram_user_id, dept_name):
                    await query.answer(get_text('department_updated', lang), show_alert=True)
                    # Return to information page
                    await self.button_handler(update, context)
                    # Manually trigger information page refresh
                    query.data = "information"
                    await self.button_handler(update, context)
                else:
                    await query.answer("❌ Error", show_alert=True)
            
            # Admin Profile Edit - Work Role
            elif query.data == "admin_profile_edit_role":
                lang = get_user_language(telegram_user_id, self.db)
                
                if not self.db.check_admin(telegram_user_id):
                    await query.edit_message_text(f"❌ {get_text('no_permission', lang)}")
                    return
                
                from database import get_all_work_roles
                
                work_roles = get_all_work_roles(self.db)
                
                if work_roles:
                    keyboard = []
                    row = []
                    for role_id, role_name, description, created_at in work_roles:
                        role_emoji = get_role_emoji(role_name)
                        role_display = get_work_role_display(role_name, lang)
                        row.append(InlineKeyboardButton(
                            f"{role_emoji} {role_display}",
                            callback_data=f"admin_profile_set_role_{role_name}"
                        ))
                        if len(row) == 3:
                            keyboard.append(row)
                            row = []
                    if row:  # Add remaining buttons
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="information")])
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await query.edit_message_text(
                        f"{get_text('change_work_role', lang)}\n\n{get_text('select_new_work_role', lang)}",
                        reply_markup=reply_markup
                    )
                else:
                    await query.answer("No work roles available", show_alert=True)
            
            # Admin Profile Set Work Role
            elif query.data.startswith("admin_profile_set_role_"):
                role_name = query.data.replace("admin_profile_set_role_", "")
                lang = get_user_language(telegram_user_id, self.db)
                
                if not self.db.check_admin(telegram_user_id):
                    await query.answer(f"❌ {get_text('no_permission', lang)}", show_alert=True)
                    return
                
                if self.db.update_employee_work_role(telegram_user_id, role_name):
                    await query.answer(get_text('work_role_updated', lang), show_alert=True)
                    # Return to information page
                    query.data = "information"
                    await self.button_handler(update, context)
                else:
                    await query.answer("❌ Error", show_alert=True)
        except Exception as e:
            import traceback
            from telegram.error import TimedOut, BadRequest, NetworkError
            
            # Check if it's a timeout or network error
            if isinstance(e, (TimedOut, NetworkError)):
                print(f"⚠️ Network/Timeout error in button_handler: {e}")
                # Don't show error to user for network issues, just log it
                # The operation might have succeeded on server side
            elif isinstance(e, BadRequest) and "Message is not modified" in str(e):
                # Ignore "Message is not modified" error - this happens when user clicks same button twice
                print(f"ℹ️ Message not modified (same content): {e}")
            else:
                print(f"❌ Error in button_handler: {e}")
                traceback.print_exc()
                try:
                    lang = get_user_language(update.effective_user.id, self.db) if update.effective_user else 'en'
                    await query.edit_message_text(get_text('error_occurred', lang))
                except:
                    pass
    
    async def rooms_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Get room list"""
        try:
            rooms = self.db.execute_query("SELECT * FROM rooms")
            
            if not rooms:
                await update.message.reply_text("🏨 Nema registrovanih soba.")
                return
            
            message = "🏨 Lista soba:\n\n"
            for room in rooms:
                room_id, room_number, room_type, price, status = room
                message += f"Broj sobe: {room_number}\n"
                message += f"Tip: {room_type}\n"
                message += f"Cena: ${price}\n"
                message += f"Status: {status}\n"
                message += "-" * 30 + "\n"
            
            await update.message.reply_text(message)
        except Exception as e:
            print(f"❌ Error in rooms_command: {e}")
            try:
                await update.message.reply_text("⚠️ Došlo je do greške pri učitavanju liste soba. Molimo pokušajte ponovo.")
            except:
                pass
    
    async def handle_media(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle media (photo/document) - for proof file upload or complaint attachment"""
        try:
            telegram_user_id = update.effective_user.id
            
            # ========== Finance Transaction Proof Attachment ==========
            if context.user_data.get('awaiting_finance_attachment'):
                from database import record_financial_transaction
                
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get attachment info
                attachment_file_id = None
                attachment_type = None
                
                if update.message.photo:
                    attachment_file_id = update.message.photo[-1].file_id
                    attachment_type = 'photo'
                elif update.message.document:
                    attachment_file_id = update.message.document.file_id
                    attachment_type = 'document'
                
                if not attachment_file_id:
                    await update.message.reply_text(
                        f"❌ {get_text('invalid_attachment', lang)}\n\n"
                        f"📎 {get_text('finance_attach_proof', lang)}",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"⏭️ {get_text('finance_skip_attach', lang)}", callback_data="finance_save_noattach")],
                            [InlineKeyboardButton(get_text('finance_cancel', lang), callback_data="emp_work_finance")]
                        ])
                    )
                    return
                
                # Get all transaction data
                tx_type = context.user_data.get('finance_tx_type', 'expense')
                category = context.user_data.get('finance_category', 'other')
                amount = context.user_data.get('finance_amount', 0)
                description = context.user_data.get('finance_description', '')
                payment_method = context.user_data.get('finance_payment', 'cash')
                payment_methods = {"cash": "Gotovina", "card": "Kartica", "bank": "Banka"}
                payment_name = payment_methods.get(payment_method, payment_method)
                
                employee = self.db.check_employee_exists(telegram_user_id)
                recorded_by_name = employee[1] if employee else "Unknown"
                
                tx_data = {
                    'transaction_type': tx_type,
                    'category': category,
                    'description': description,
                    'amount': amount,
                    'payment_method': payment_name,
                    'vendor_client': '',
                    'reference_number': '',
                    'recorded_by': str(telegram_user_id),
                    'recorded_by_name': recorded_by_name,
                    'attachment_file_id': attachment_file_id,
                    'attachment_type': attachment_type
                }
                
                tx_id = record_financial_transaction(self.db, tx_data)
                
                # Clear user_data
                for key in ['finance_tx_type', 'finance_category', 'finance_amount', 'finance_description', 'finance_payment', 'awaiting_finance_attachment']:
                    context.user_data.pop(key, None)
                
                if tx_id:
                    text = f"✅ {get_text('finance_saved_success', lang).format(tx_id)}\n\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"📌 {get_text('finance_type_label', lang)}: {get_text(f'finance_type_{tx_type}', lang)}\n"
                    text += f"📁 {get_text('finance_category_label', lang)}: {get_text(f'finance_cat_{category}', lang)}\n"
                    text += f"💰 {get_text('finance_amount_label', lang)}: {amount:,.2f} RSD\n"
                    text += f"📝 {get_text('finance_description_label', lang)}: {description}\n"
                    text += f"💳 {get_text('finance_payment_label', lang)}: {payment_name}\n"
                    text += f"📎 {get_text('attachment', lang)}: ✅ {get_text('proof_attached', lang)}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    
                    await update.message.reply_text(
                        text,
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_finance")
                        ]])
                    )
                else:
                    await update.message.reply_text(
                        "❌ Greška prilikom čuvanja transakcije.",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="emp_work_finance")
                        ]])
                    )
                return
            
            # ========== Event READY Confirmation Photo ==========
            if context.user_data.get('event_ready_confirmation'):
                from database import confirm_event_ready, get_event_by_id
                
                lang = get_user_language(telegram_user_id, self.db)
                ready_data = context.user_data['event_ready_confirmation']
                
                if update.message.photo:
                    photo_id = update.message.photo[-1].file_id
                    
                    # Confirm READY with proof
                    confirm_event_ready(self.db, ready_data['history_id'], telegram_user_id, photo_id)
                    
                    event = get_event_by_id(self.db, ready_data['event_id'])
                    context.user_data['event_ready_confirmation'] = None
                    
                    await update.message.reply_text(
                        f"✅ {get_text('ready', lang)}\n\n"
                        f"📌 {event['event_name'] if event else 'Event'}\n"
                        f"📅 {event['event_date'] if event else ''} {event['event_time'] if event else ''}\n"
                        f"🏢 {ready_data['department']}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="emp_start_menu")
                        ]])
                    )
                    return
                else:
                    await update.message.reply_text(
                        "❌ Please send a photo as proof",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="cancel_event_ready")
                        ]])
                    )
                    return
            
            # ========== Shift Report: Cash Photo Upload ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_cash_pos_photo'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_cash_pos_photo'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get file ID
                if update.message.photo:
                    file_id = update.message.photo[-1].file_id
                elif update.message.document:
                    file_id = update.message.document.file_id
                else:
                    await update.message.reply_text(
                        "❌ Please send a photo",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_cash_pos_photo'] = True
                    return
                
                self.user_context[telegram_user_id]['shift_report']['cash_photo'] = file_id
                self.user_context[telegram_user_id]['shift_report_step'] = 4
                self.user_context[telegram_user_id]['awaiting_hotel_register_photo'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                step_template = get_shift_report_input_template(lang, 4)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ Cash & POS Report: Photo received\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== Shift Report: Hotel Register Photo Upload ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_hotel_register_photo'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_hotel_register_photo'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                # Get file ID
                if update.message.photo:
                    file_id = update.message.photo[-1].file_id
                elif update.message.document:
                    file_id = update.message.document.file_id
                else:
                    await update.message.reply_text(
                        "❌ Please send a photo",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_hotel_register_photo'] = True
                    return
                
                self.user_context[telegram_user_id]['shift_report']['hotel_register_photo'] = file_id
                self.user_context[telegram_user_id]['shift_report_step'] = 5
                self.user_context[telegram_user_id]['awaiting_store_stock_notes'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                step_template = get_shift_report_input_template(lang, 5)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ Hotel Register: Photo received\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== Key Management: Proof Upload for Taking ==========
            if context.user_data.get('awaiting_key_proof'):
                from database import create_key_record
                context.user_data['awaiting_key_proof'] = False
                
                room_id = context.user_data.get('key_taking_room_id')
                room_name = context.user_data.get('key_taking_room_name')
                purpose = context.user_data.get('key_purpose')
                
                # Get file ID based on media type
                taken_photo = None
                taken_video = None
                media_type = None
                
                if update.message.photo:
                    taken_photo = update.message.photo[-1].file_id
                    media_type = 'photo'
                elif update.message.video:
                    taken_video = update.message.video.file_id
                    media_type = 'video'
                elif update.message.document:
                    # Check if it's a video document
                    if update.message.document.mime_type and 'video' in update.message.document.mime_type:
                        taken_video = update.message.document.file_id
                        media_type = 'video'
                    else:
                        taken_photo = update.message.document.file_id
                        media_type = 'document'
                
                # Use selected employee info (from key_emp_ selection)
                emp_name = context.user_data.get('key_taking_emp_name')
                emp_telegram_id = context.user_data.get('key_taking_emp_telegram_id')
                emp_department = context.user_data.get('key_taking_emp_department')
                
                if not emp_name:
                    # Fallback to receptionist info
                    emp_info = self.db.get_employee_info(telegram_user_id)
                    if emp_info:
                        emp_name = emp_info['name']
                        emp_telegram_id = telegram_user_id
                        emp_department = emp_info.get('department', 'Unknown')
                    else:
                        emp_name = update.effective_user.first_name or "Unknown"
                        emp_telegram_id = telegram_user_id
                        emp_department = "Unknown"
                
                record_id = create_key_record(
                    self.db, room_id, room_name, emp_name,
                    emp_telegram_id, purpose,
                    taken_photo=taken_photo, taken_video=taken_video,
                    created_by=telegram_user_id
                )
                
                if record_id:
                    from datetime import datetime
                    now = datetime.now()
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    proof_text = f"📸 {get_text('photo', lang)}" if taken_photo else f"🎥 {get_text('video', lang)}"
                    dept_emoji = get_dept_emoji(emp_department)
                    dept_display = get_dept_display(emp_department, lang)
                    
                    await update.message.reply_text(
                        f"{get_text('key_taken', lang)}\n\n"
                        f"{get_text('room', lang)}: {room_name}\n"
                        f"{get_text('person', lang)}: {emp_name}\n"
                        f"{dept_emoji} {get_text('department', lang)}: {dept_display}\n"
                        f"{get_text('purpose', lang)}: {purpose}\n"
                        f"{proof_text}: {get_text('attached', lang)}\n"
                        f"{get_text('time', lang)}: {now.strftime('%d.%m.%Y %H:%M')}\n\n"
                        f"{get_text('remember_return', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('key_management', lang)}", callback_data="reception_keys")
                        ]])
                    )
                else:
                    lang = get_user_language(telegram_user_id, self.db)
                    await update.message.reply_text(
                        f"❌ {get_text('error_creating_record', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_keys")
                        ]])
                    )
                
                # Clean up context
                context.user_data.pop('key_taking_room_id', None)
                context.user_data.pop('key_taking_room_name', None)
                context.user_data.pop('key_purpose', None)
                context.user_data.pop('key_taking_emp_id', None)
                context.user_data.pop('key_taking_emp_name', None)
                context.user_data.pop('key_taking_emp_telegram_id', None)
                context.user_data.pop('key_taking_emp_department', None)
                return
            
            # ========== Key Management: Proof Upload for Returning ==========
            if context.user_data.get('awaiting_key_return_proof'):
                from database import return_key
                context.user_data['awaiting_key_return_proof'] = False
                
                record_id = context.user_data.get('key_returning_record_id')
                
                # Get file ID based on media type
                returned_photo = None
                returned_video = None
                
                if update.message.photo:
                    returned_photo = update.message.photo[-1].file_id
                elif update.message.video:
                    returned_video = update.message.video.file_id
                elif update.message.document:
                    if update.message.document.mime_type and 'video' in update.message.document.mime_type:
                        returned_video = update.message.document.file_id
                    else:
                        returned_photo = update.message.document.file_id
                
                success = return_key(self.db, record_id, returned_photo, returned_video)
                
                if success:
                    lang = get_user_language(telegram_user_id, self.db)
                    proof_text = f"📸 {get_text('photo', lang)}" if returned_photo else f"🎥 {get_text('video', lang)}"
                    
                    await update.message.reply_text(
                        f"{get_text('key_returned', lang)}\n\n"
                        f"{proof_text}: {get_text('attached', lang)}\n\n"
                        f"{get_text('thank_for_key_return', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('key_management', lang)}", callback_data="reception_keys")
                        ]])
                    )
                else:
                    lang = get_user_language(telegram_user_id, self.db)
                    await update.message.reply_text(
                        f"❌ {get_text('error_returning_key', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_keys")
                        ]])
                    )
                
                # Clean up context
                context.user_data.pop('key_returning_record_id', None)
                return
            
            # ========== Tool Management: Proof Upload for Borrowing ==========
            if context.user_data.get('awaiting_tool_proof'):
                from database import borrow_tool
                context.user_data['awaiting_tool_proof'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                tool_id = context.user_data.get('tool_borrowing_id')
                tool_name = context.user_data.get('tool_borrowing_name')
                quantity = context.user_data.get('tool_borrowing_qty', 1)
                purpose = context.user_data.get('tool_purpose')
                emp_name = context.user_data.get('tool_borrowing_emp_name')
                emp_telegram_id = context.user_data.get('tool_borrowing_emp_telegram_id')
                emp_department = context.user_data.get('tool_borrowing_emp_department')
                
                # Get file ID
                taken_photo = None
                taken_video = None
                
                if update.message.photo:
                    taken_photo = update.message.photo[-1].file_id
                elif update.message.video:
                    taken_video = update.message.video.file_id
                elif update.message.document:
                    if update.message.document.mime_type and 'video' in update.message.document.mime_type:
                        taken_video = update.message.document.file_id
                    else:
                        taken_photo = update.message.document.file_id
                
                record_id = borrow_tool(
                    self.db, tool_id, tool_name, quantity,
                    emp_name, emp_telegram_id, purpose,
                    taken_photo=taken_photo, taken_video=taken_video,
                    created_by=telegram_user_id
                )
                
                if record_id:
                    from datetime import datetime
                    now = datetime.now()
                    
                    proof_text = f"📸 {get_text('photo', lang)}" if taken_photo else f"🎥 {get_text('video', lang)}"
                    dept_emoji = get_dept_emoji(emp_department) if emp_department else "👤"
                    dept_display = get_dept_display(emp_department) if emp_department else ""
                    
                    await update.message.reply_text(
                        f"✅ {get_text('tool_borrowed_success', lang)}\n\n"
                        f"🔧 {get_text('tool_name', lang)}: {tool_name}\n"
                        f"📦 {get_text('quantity', lang)}: {quantity}\n"
                        f"👤 {get_text('person', lang)}: {emp_name}\n"
                        f"{dept_emoji} {get_text('department', lang)}: {dept_display}\n"
                        f"📝 {get_text('purpose', lang)}: {purpose}\n"
                        f"{proof_text}: {get_text('attached', lang)}\n"
                        f"🕐 {get_text('time', lang)}: {now.strftime('%d.%m.%Y %H:%M')}\n\n"
                        f"⚠️ {get_text('dont_forget_return', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('tool_management', lang)}", callback_data="reception_tools")
                        ]])
                    )
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('borrow_error', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_tools")
                        ]])
                    )
                
                # Clean up context
                for key in list(context.user_data.keys()):
                    if key.startswith('tool_'):
                        context.user_data.pop(key, None)
                return
            
            # ========== Tool Management: Proof Upload for Returning ==========
            if context.user_data.get('awaiting_tool_return_proof'):
                from database import return_tool
                context.user_data['awaiting_tool_return_proof'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                record_id = context.user_data.get('tool_returning_record_id')
                
                # Get file ID
                returned_photo = None
                returned_video = None
                
                if update.message.photo:
                    returned_photo = update.message.photo[-1].file_id
                elif update.message.video:
                    returned_video = update.message.video.file_id
                elif update.message.document:
                    if update.message.document.mime_type and 'video' in update.message.document.mime_type:
                        returned_video = update.message.document.file_id
                    else:
                        returned_photo = update.message.document.file_id
                
                success = return_tool(self.db, record_id, returned_photo, returned_video)
                
                if success:
                    proof_text = f"📸 {get_text('photo', lang)}" if returned_photo else f"🎥 {get_text('video', lang)}"
                    
                    await update.message.reply_text(
                        f"✅ {get_text('tool_returned_success', lang)}\n\n"
                        f"{proof_text}: {get_text('attached', lang)}\n\n"
                        f"{get_text('thank_for_return', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('tool_management', lang)}", callback_data="reception_tools")
                        ]])
                    )
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('return_error', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_tools")
                        ]])
                    )
                
                context.user_data.pop('tool_returning_record_id', None)
                return
            
            # ========== Cleaning: Photo Upload (store in context only) ==========
            if context.user_data.get('awaiting_clean_photo'):
                # Just store the photo/video file ID, don't save to DB yet
                photo = None
                video = None
                
                if update.message.photo:
                    photo = update.message.photo[-1].file_id
                elif update.message.video:
                    video = update.message.video.file_id
                elif update.message.document:
                    if update.message.document.mime_type and 'video' in update.message.document.mime_type:
                        video = update.message.document.file_id
                    else:
                        photo = update.message.document.file_id
                
                if photo:
                    context.user_data['clean_photo'] = photo
                if video:
                    context.user_data['clean_video'] = video
                
                room_number = context.user_data.get('clean_room_number', 'Unknown')
                room_id = context.user_data.get('clean_room_id', 0)
                clean_type = context.user_data.get('clean_type', 'guest_room')
                
                proof_text = "📸 Fotografija primljena" if photo else "🎥 Video primljen"
                
                callback_prefix = "guest" if clean_type == 'guest_room' else "staff"
                
                await update.message.reply_text(
                    f"✅ {proof_text}!\n\n"
                    f"🚪 Soba: {room_number}\n\n"
                    f"Pritisnite 'Potvrdi čišćenje' za snimanje izveštaja.",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("✅ Potvrdi čišćenje", callback_data=f"clean_confirm_{callback_prefix}_{room_id}")],
                        [InlineKeyboardButton("🔙 Nazad", callback_data="emp_work_cleaning")]
                    ])
                )
                return
            
            # ========== Repair Report: Media Upload ==========
            repair_report = context.user_data.get('repair_report', {})
            if context.user_data.get('awaiting_repair_report_media') or repair_report.get('step') == 'media':
                task_id = context.user_data.get('awaiting_repair_report_media') or repair_report.get('task_id')
                
                if task_id:
                    file_id = None
                    file_type = None
                    media_type = None
                    
                    if update.message.photo:
                        file_id = update.message.photo[-1].file_id
                        file_type = "📸 Fotografija"
                        media_type = "photo"
                    elif update.message.video:
                        file_id = update.message.video.file_id
                        file_type = "🎥 Video"
                        media_type = "video"
                    elif update.message.document:
                        file_id = update.message.document.file_id
                        if update.message.document.mime_type and 'video' in update.message.document.mime_type:
                            file_type = "🎥 Video"
                            media_type = "video"
                        else:
                            file_type = "📄 Dokument"
                            media_type = "document"
                    
                    if file_id:
                        from database import complete_repair_task, get_repair_task_by_id
                        
                        report_notes = repair_report.get('notes', '')
                        
                        if complete_repair_task(self.db, task_id, report_notes, 
                                               proof_media_type=media_type, proof_file_id=file_id):
                            task = get_repair_task_by_id(self.db, task_id)
                            
                            # Notify assigner with media
                            try:
                                notification_text = f"""🔧 Popravka završena!

🚪 Soba: {task[2]}
📋 Vrsta: {task[7]}
👤 Tehničar: {task[5]}
🕐 Završeno: {task[18]}"""
                                
                                if report_notes:
                                    notification_text += f"\n\n📋 Izveštaj:\n{report_notes}"
                                
                                notification_text += f"\n\n📎 Dokaz: {file_type}"
                                
                                if media_type == 'photo':
                                    await self.application.bot.send_photo(
                                        chat_id=task[14],  # assigned_by
                                        photo=file_id,
                                        caption=notification_text
                                    )
                                elif media_type == 'video':
                                    await self.application.bot.send_video(
                                        chat_id=task[14],
                                        video=file_id,
                                        caption=notification_text
                                    )
                                else:
                                    await self.application.bot.send_document(
                                        chat_id=task[14],
                                        document=file_id,
                                        caption=notification_text
                                    )
                            except Exception as e:
                                print(f"Failed to send repair completion notification: {e}")
                            
                            await update.message.reply_text(
                                f"✅ Popravka uspešno završena!\n\n"
                                f"🚪 Soba: {task[2]}\n"
                                f"📋 Izveštaj: {report_notes if report_notes else 'Bez izveštaja'}\n"
                                f"📎 Dokaz: {file_type}\n",
                                reply_markup=InlineKeyboardMarkup([[
                                    InlineKeyboardButton("🔙 Moji zadaci", callback_data="my_repair_tasks")
                                ]])
                            )
                        else:
                            await update.message.reply_text(
                                "❌ Greška pri završavanju popravke",
                                reply_markup=InlineKeyboardMarkup([[
                                    InlineKeyboardButton("🔙 Nazad", callback_data=f"repair_task_{task_id}")
                                ]])
                            )
                        
                        # Clean up context
                        context.user_data.pop('repair_report', None)
                        context.user_data.pop('awaiting_repair_report_media', None)
                        return
            
            # ========== Laundry Report: Media Upload ==========
            # Check for laundry report media - either explicit awaiting or if in notes step (user uploaded photo directly)
            laundry_report = context.user_data.get('laundry_report', {})
            if context.user_data.get('awaiting_laundry_report_media') or laundry_report.get('step') in ['notes', 'media']:
                task_id = context.user_data.get('awaiting_laundry_report_media') or laundry_report.get('task_id')
                
                if not task_id:
                    # No valid laundry task context, skip to next handler
                    pass
                else:
                    file_id = None
                    file_type = None
                    
                    if update.message.photo:
                        file_id = update.message.photo[-1].file_id
                        file_type = "📸 Fotografija"
                    elif update.message.document:
                        file_id = update.message.document.file_id
                        file_type = "📄 Dokument"
                    elif update.message.video:
                        file_id = update.message.video.file_id
                        file_type = "🎥 Video"
                
                    if file_id:
                        from database import complete_laundry_task, get_laundry_task_by_id
                        
                        report_notes = context.user_data.get('laundry_report', {}).get('notes', '')
                        
                        if complete_laundry_task(self.db, task_id, file_id, report_notes):
                            task = get_laundry_task_by_id(self.db, task_id)
                        
                        # Get reporter info
                        telegram_user_id = update.message.from_user.id
                        reporter_info = self.db.get_employee_info(telegram_user_id)
                        reporter_name = reporter_info['name'] if reporter_info else task['assignee_name']
                        
                        # Notify assigner with media
                        try:
                            notification_text = f"""✅ Zadatak za veš završen!

� Nalog: {task['description'][:100]}...
👤 Završio: {reporter_name}
🕐 Vreme: {task['completed_at']}"""
                            
                            if report_notes:
                                notification_text += f"\n\n� Izveštaj:\n{report_notes}"
                            
                            notification_text += f"\n\n📎 Dokaz: {file_type}"
                            
                            if '📸' in file_type:
                                await self.application.bot.send_photo(
                                    chat_id=task['assigned_by'],
                                    photo=file_id,
                                    caption=notification_text
                                )
                            elif '🎥' in file_type:
                                await self.application.bot.send_video(
                                    chat_id=task['assigned_by'],
                                    video=file_id,
                                    caption=notification_text
                                )
                            else:
                                await self.application.bot.send_document(
                                    chat_id=task['assigned_by'],
                                    document=file_id,
                                    caption=notification_text
                                )
                        except Exception as e:
                            print(f"Failed to send completion notification: {e}")
                        
                        await update.message.reply_text(
                            "✅ Zadatak uspešno završen!\n\n"
                            f"� Nalog: {task['description'][:50]}...\n"
                            f"� Dokaz: {file_type}\n"
                            f"🕐 Završeno: {task['completed_at']}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton("🔙 Nazad", callback_data="my_laundry_tasks")
                            ]])
                        )
                    else:
                        await update.message.reply_text(
                            "❌ Greška pri završavanju zadatka",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton("🔙 Nazad", callback_data="my_laundry_tasks")
                            ]])
                        )
                    
                    context.user_data.pop('awaiting_laundry_report_media', None)
                    context.user_data.pop('laundry_report', None)
                    return
            
            # ========== Restaurant Report: Media Upload ==========
            restaurant_report = context.user_data.get('restaurant_report', {})
            if context.user_data.get('awaiting_restaurant_report_media') or restaurant_report.get('step') in ['notes', 'media']:
                task_id = context.user_data.get('awaiting_restaurant_report_media') or restaurant_report.get('task_id')
                
                if not task_id:
                    pass
                else:
                    file_id = None
                    file_type = None
                    
                    if update.message.photo:
                        file_id = update.message.photo[-1].file_id
                        file_type = "📸 Fotografija"
                    elif update.message.document:
                        file_id = update.message.document.file_id
                        file_type = "📄 Dokument"
                    elif update.message.video:
                        file_id = update.message.video.file_id
                        file_type = "🎥 Video"
                
                    if file_id:
                        from database import complete_restaurant_task, get_restaurant_task_by_id
                        
                        report_notes = context.user_data.get('restaurant_report', {}).get('notes', '')
                        
                        if complete_restaurant_task(self.db, task_id, file_id, report_notes):
                            task = get_restaurant_task_by_id(self.db, task_id)
                        
                        telegram_user_id = update.message.from_user.id
                        reporter_info = self.db.get_employee_info(telegram_user_id)
                        reporter_name = reporter_info['name'] if reporter_info else task['assignee_name']
                        
                        # Notify assigner with media
                        try:
                            notification_text = f"""📋 Zadatak za kuhinju završen!

📝 Zadatak: {task['description'][:100]}...
👤 Završio: {reporter_name}
🕐 Vreme: {task['completed_at']}"""
                            
                            if report_notes:
                                notification_text += f"\n\n📋 Izveštaj:\n{report_notes}"
                            
                            notification_text += f"\n\n📎 Dokaz: {file_type}"
                            
                            if '📸' in file_type:
                                await self.application.bot.send_photo(
                                    chat_id=task['assigned_by'],
                                    photo=file_id,
                                    caption=notification_text
                                )
                            elif '🎥' in file_type:
                                await self.application.bot.send_video(
                                    chat_id=task['assigned_by'],
                                    video=file_id,
                                    caption=notification_text
                                )
                            else:
                                await self.application.bot.send_document(
                                    chat_id=task['assigned_by'],
                                    document=file_id,
                                    caption=notification_text
                                )
                        except Exception as e:
                            print(f"Failed to send completion notification: {e}")
                        
                        await update.message.reply_text(
                            f"✅ Zadatak uspešno završen!\n\n"
                            f"📝 Zadatak: {task['description'][:50]}...\n"
                            f"📎 Dokaz: {file_type}\n"
                            f"🕐 Završeno: {task['completed_at']}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton("🔙 Nazad", callback_data="my_restaurant_tasks")
                            ]])
                        )
                    else:
                        await update.message.reply_text(
                            "❌ Greška pri završavanju zadatka",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton("🔙 Nazad", callback_data="my_restaurant_tasks")
                            ]])
                        )
                    
                    context.user_data.pop('awaiting_restaurant_report_media', None)
                    context.user_data.pop('restaurant_report', None)
                    return
            
            # ========== Driver Report: Media Upload ==========
            driver_report = context.user_data.get('driver_report', {})
            if context.user_data.get('awaiting_driver_report_media') or driver_report.get('step') in ['notes', 'media']:
                task_id = context.user_data.get('awaiting_driver_report_media') or driver_report.get('task_id')
                
                if not task_id:
                    pass
                else:
                    file_id = None
                    file_type = None
                    
                    if update.message.photo:
                        file_id = update.message.photo[-1].file_id
                        file_type = "📸 Fotografija"
                    elif update.message.document:
                        file_id = update.message.document.file_id
                        file_type = "📄 Dokument"
                    elif update.message.video:
                        file_id = update.message.video.file_id
                        file_type = "🎥 Video"
                
                    if file_id:
                        from database import complete_delivery_task, get_delivery_task_by_id
                        
                        report_notes = context.user_data.get('driver_report', {}).get('notes', '')
                        
                        if complete_delivery_task(self.db, task_id, report_notes, file_id, file_type):
                            task = get_delivery_task_by_id(self.db, task_id)
                        
                        telegram_user_id = update.message.from_user.id
                        reporter_info = self.db.get_employee_info(telegram_user_id)
                        reporter_name = reporter_info['name'] if reporter_info else task['assignee_name']
                        
                        # Notify assigner with media
                        try:
                            notification_text = f"""🚗 Zadatak za vozača završen!

📝 Zadatak: {task['description'][:100]}...
👤 Završio: {reporter_name}
🕐 Vreme: {task['completed_at']}"""
                            
                            if report_notes:
                                notification_text += f"\n\n📋 Izveštaj:\n{report_notes}"
                            
                            notification_text += f"\n\n📎 Dokaz: {file_type}"
                            
                            if '📸' in file_type:
                                await self.application.bot.send_photo(
                                    chat_id=task['assigned_by'],
                                    photo=file_id,
                                    caption=notification_text
                                )
                            elif '🎥' in file_type:
                                await self.application.bot.send_video(
                                    chat_id=task['assigned_by'],
                                    video=file_id,
                                    caption=notification_text
                                )
                            else:
                                await self.application.bot.send_document(
                                    chat_id=task['assigned_by'],
                                    document=file_id,
                                    caption=notification_text
                                )
                        except Exception as e:
                            print(f"Failed to send completion notification: {e}")
                        
                        await update.message.reply_text(
                            f"✅ Zadatak uspešno završen!\n\n"
                            f"📝 Zadatak: {task['description'][:50]}...\n"
                            f"📎 Dokaz: {file_type}\n"
                            f"🕐 Završeno: {task['completed_at']}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton("🔙 Nazad", callback_data="my_delivery_tasks")
                            ]])
                        )
                    else:
                        await update.message.reply_text(
                            "❌ Greška pri završavanju zadatka",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton("🔙 Nazad", callback_data="my_delivery_tasks")
                            ]])
                        )
                    
                    context.user_data.pop('awaiting_driver_report_media', None)
                    context.user_data.pop('driver_report', None)
                    return
            
            # ========== Accounting Report: Media Upload ==========
            accounting_report = context.user_data.get('accounting_report', {})
            if context.user_data.get('awaiting_accounting_report_media') or accounting_report.get('step') in ['notes', 'media']:
                task_id = context.user_data.get('awaiting_accounting_report_media') or accounting_report.get('task_id')
                
                if not task_id:
                    pass
                else:
                    file_id = None
                    file_type = None
                    
                    if update.message.photo:
                        file_id = update.message.photo[-1].file_id
                        file_type = "📸 Fotografija"
                    elif update.message.document:
                        file_id = update.message.document.file_id
                        file_type = "📄 Dokument"
                    elif update.message.video:
                        file_id = update.message.video.file_id
                        file_type = "🎥 Video"
                
                    if file_id:
                        from database import complete_accounting_task, get_accounting_task_by_id
                        
                        report_notes = context.user_data.get('accounting_report', {}).get('notes', '')
                        
                        if complete_accounting_task(self.db, task_id, report_notes, file_id, file_type):
                            task = get_accounting_task_by_id(self.db, task_id)
                        
                        telegram_user_id = update.message.from_user.id
                        reporter_info = self.db.get_employee_info(telegram_user_id)
                        reporter_name = reporter_info['name'] if reporter_info else task['assignee_name']
                        
                        # Notify assigner with media
                        try:
                            notification_text = f"""💰 Zadatak za računovodstvo završen!

📝 Zadatak: {task['description'][:100]}...
👤 Završio: {reporter_name}
🕐 Vreme: {task['completed_at']}"""
                            
                            if report_notes:
                                notification_text += f"\n\n📋 Izveštaj:\n{report_notes}"
                            
                            notification_text += f"\n\n📎 Dokaz: {file_type}"
                            
                            if '📸' in file_type:
                                await self.application.bot.send_photo(
                                    chat_id=task['assigned_by'],
                                    photo=file_id,
                                    caption=notification_text
                                )
                            elif '🎥' in file_type:
                                await self.application.bot.send_video(
                                    chat_id=task['assigned_by'],
                                    video=file_id,
                                    caption=notification_text
                                )
                            else:
                                await self.application.bot.send_document(
                                    chat_id=task['assigned_by'],
                                    document=file_id,
                                    caption=notification_text
                                )
                        except Exception as e:
                            print(f"Failed to send completion notification: {e}")
                        
                        await update.message.reply_text(
                            f"✅ Zadatak uspešno završen!\n\n"
                            f"📝 Zadatak: {task['description'][:50]}...\n"
                            f"📎 Dokaz: {file_type}\n"
                            f"🕐 Završeno: {task['completed_at']}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton("🔙 Nazad", callback_data="my_accounting_tasks")
                            ]])
                        )
                    else:
                        await update.message.reply_text(
                            "❌ Greška pri završavanju zadatka",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton("🔙 Nazad", callback_data="my_accounting_tasks")
                            ]])
                        )
                    
                    context.user_data.pop('awaiting_accounting_report_media', None)
                    context.user_data.pop('accounting_report', None)
                    return
            
            # ========== Driver Assignment: Attachment Upload ==========
            if context.user_data.get('awaiting_driver_attachment'):
                file_id = None
                file_type = None
                
                if update.message.photo:
                    file_id = update.message.photo[-1].file_id
                    file_type = "photo"
                elif update.message.document:
                    file_id = update.message.document.file_id
                    file_type = "document"
                elif update.message.video:
                    file_id = update.message.video.file_id
                    file_type = "video"
                
                if file_id:
                    # Append to attachments list
                    if 'driver_assign' not in context.user_data:
                        context.user_data['driver_assign'] = {}
                    if 'attachments' not in context.user_data['driver_assign']:
                        context.user_data['driver_assign']['attachments'] = []
                    
                    context.user_data['driver_assign']['attachments'].append({
                        'file_id': file_id,
                        'type': file_type
                    })
                    
                    attachment_count = len(context.user_data['driver_assign']['attachments'])
                    lang = get_user_language(telegram_user_id, self.db)
                    file_word = get_text('file_added', lang) if attachment_count == 1 else get_text('files_added', lang)
                    
                    # Show confirmation message
                    await update.message.reply_text(
                        f"✅ Prilog dodat! ({attachment_count} {file_word})\n"
                        f"{get_text('add_more_or_finish', lang)}",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"{get_text('finish_and_send', lang)}", callback_data="driver_finish_attachments")],
                            [InlineKeyboardButton("⏭️ Preskoči prilog", callback_data="driver_skip_attachment")],
                            [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_driver")]
                        ])
                    )
                    return
            
            # ========== Accounting Assignment: Attachment Upload ==========
            if context.user_data.get('awaiting_accounting_attachment'):
                file_id = None
                file_type = None
                
                if update.message.photo:
                    file_id = update.message.photo[-1].file_id
                    file_type = "photo"
                elif update.message.document:
                    file_id = update.message.document.file_id
                    file_type = "document"
                elif update.message.video:
                    file_id = update.message.video.file_id
                    file_type = "video"
                
                if file_id:
                    # Append to attachments list
                    if 'accounting_assign' not in context.user_data:
                        context.user_data['accounting_assign'] = {}
                    if 'attachments' not in context.user_data['accounting_assign']:
                        context.user_data['accounting_assign']['attachments'] = []
                    
                    context.user_data['accounting_assign']['attachments'].append({
                        'file_id': file_id,
                        'type': file_type
                    })
                    
                    attachment_count = len(context.user_data['accounting_assign']['attachments'])
                    lang = get_user_language(telegram_user_id, self.db)
                    file_word = get_text('file_added', lang) if attachment_count == 1 else get_text('files_added', lang)
                    
                    # Show confirmation message
                    await update.message.reply_text(
                        f"✅ Prilog dodat! ({attachment_count} {file_word})\n"
                        f"{get_text('add_more_or_finish', lang)}",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"{get_text('finish_and_send', lang)}", callback_data="accounting_finish_attachments")],
                            [InlineKeyboardButton("⏭️ Preskoči prilog", callback_data="accounting_skip_attachment")],
                            [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_accounting")]
                        ])
                    )
                    return
                    
            # ========== Restaurant Assignment: Attachment Upload ==========
            if context.user_data.get('awaiting_restaurant_attachment'):
                file_id = None
                file_type = None
                lang = get_user_language(telegram_user_id, self.db)
                
                if update.message.photo:
                    file_id = update.message.photo[-1].file_id
                    file_type = "photo"
                elif update.message.document:
                    file_id = update.message.document.file_id
                    file_type = "document"
                elif update.message.video:
                    file_id = update.message.video.file_id
                    file_type = "video"
                
                if file_id:
                    # Append to attachments list
                    if 'restaurant_assign' not in context.user_data:
                        context.user_data['restaurant_assign'] = {}
                    if 'attachments' not in context.user_data['restaurant_assign']:
                        context.user_data['restaurant_assign']['attachments'] = []
                    
                    context.user_data['restaurant_assign']['attachments'].append({
                        'file_id': file_id,
                        'type': file_type
                    })
                    
                    attachment_count = len(context.user_data['restaurant_assign']['attachments'])
                    lang = get_user_language(telegram_user_id, self.db)
                    file_word = get_text('file_added', lang) if attachment_count == 1 else get_text('files_added', lang)
                    
                    # Show confirmation message
                    await update.message.reply_text(
                        f"✅ Prilog dodat! ({attachment_count} {file_word})\n"
                        f"{get_text('add_more_or_finish', lang)}",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"{get_text('finish_and_send', lang)}", callback_data="restaurant_finish_attachments")],
                            [InlineKeyboardButton("⏭️ Preskoči prilog", callback_data="rest_skip_media")],
                            [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_kitchen")]
                        ])
                    )
                else:
                    await update.message.reply_text(
                        "❌ Nije moguće obraditi datoteku. Pošaljite fotografiju, video ili dokument.\n\n"
                        "Ili pritisnite dugme za preskakanje:",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("⏭️ Preskoči prilog", callback_data="rest_skip_media")],
                            [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_kitchen")]
                        ])
                    )
                return
                    
            # ========== Laundry Assignment: Attachment Upload ==========
            if context.user_data.get('awaiting_laundry_attachment'):
                file_id = None
                file_type = None
                
                if update.message.photo:
                    file_id = update.message.photo[-1].file_id
                    file_type = "photo"
                elif update.message.document:
                    file_id = update.message.document.file_id
                    file_type = "document"
                elif update.message.video:
                    file_id = update.message.video.file_id
                    file_type = "video"
                
                if file_id:
                    # Append to attachments list
                    if 'laundry_assign' not in context.user_data:
                        context.user_data['laundry_assign'] = {}
                    if 'attachments' not in context.user_data['laundry_assign']:
                        context.user_data['laundry_assign']['attachments'] = []
                    
                    context.user_data['laundry_assign']['attachments'].append({
                        'file_id': file_id,
                        'type': file_type
                    })
                    
                    attachment_count = len(context.user_data['laundry_assign']['attachments'])
                    lang = get_user_language(telegram_user_id, self.db)
                    file_word = get_text('file_added', lang) if attachment_count == 1 else get_text('files_added', lang)
                    
                    # Show confirmation message
                    await update.message.reply_text(
                        f"✅ Prilog dodat! ({attachment_count} {file_word})\n"
                        f"{get_text('add_more_or_finish', lang)}",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"{get_text('finish_and_send', lang)}", callback_data="laundry_finish_attachments")],
                            [InlineKeyboardButton("⏭️ Preskoči prilog", callback_data="laundry_skip_media")],
                            [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_laundry")]
                        ])
                    )
                else:
                    await update.message.reply_text(
                        "❌ Nije moguće obraditi datoteku. Pošaljite fotografiju, video ili dokument.\n\n"
                        "Ili pritisnite dugme za preskakanje:",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("⏭️ Preskoči prilog", callback_data="laundry_skip_media")],
                            [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_laundry")]
                        ])
                    )
                return
            
            # ========== Task Assignment: Attachment Upload ==========
            if context.user_data.get('awaiting_task_attachment'):
                file_id = None
                file_type_key = None
                
                # Get user language
                lang = get_user_language(telegram_user_id, self.db)
                
                if update.message.photo:
                    file_id = update.message.photo[-1].file_id
                    file_type_key = "photo"
                elif update.message.document:
                    file_id = update.message.document.file_id
                    file_type_key = "document"
                elif update.message.video:
                    file_id = update.message.video.file_id
                    file_type_key = "video"
                
                if file_id:
                    # Initialize attachments list if not exists
                    task_data = context.user_data.get('task_creation', {})
                    if 'attachments' not in task_data:
                        task_data['attachments'] = []
                    
                    # Add new attachment to list
                    file_type_display = f"📸 {get_text('photo', lang)}" if file_type_key == "photo" else f"📄 {get_text('document', lang)}" if file_type_key == "document" else f"🎥 {get_text('video', lang)}"
                    task_data['attachments'].append({
                        'file_id': file_id,
                        'type': file_type_key
                    })
                    context.user_data['task_creation'] = task_data
                    
                    # Check if this is part of a media group (multiple photos sent at once)
                    media_group_id = update.message.media_group_id
                    
                    if media_group_id:
                        # Store media group ID and set a flag
                        if 'media_group_id' not in task_data or task_data['media_group_id'] != media_group_id:
                            task_data['media_group_id'] = media_group_id
                            task_data['media_group_sent'] = False
                            context.user_data['task_creation'] = task_data
                        
                        # Skip sending confirmation for now (will be sent after all photos in group)
                        import asyncio
                        
                        # Wait briefly to collect all photos in the media group
                        async def send_confirmation_after_delay():
                            await asyncio.sleep(1.5)  # Wait for all media in group
                            current_task_data = context.user_data.get('task_creation', {})
                            
                            # Only send if we haven't sent for this media group yet
                            if current_task_data.get('media_group_id') == media_group_id and not current_task_data.get('media_group_sent'):
                                current_task_data['media_group_sent'] = True
                                context.user_data['task_creation'] = current_task_data
                                
                                attachment_count = len(current_task_data['attachments'])
                                dept_name = current_task_data.get('department_name', get_text('unknown', lang))
                                emp_name = current_task_data.get('employee_name', get_text('unassigned', lang))
                                emp_name_display = get_text('unassigned', lang) if emp_name == "Unassigned" else emp_name
                                description = current_task_data.get('description', 'N/A')
                                priority = current_task_data.get('priority', 'Normal')
                                due_date = current_task_data.get('due_date', 'N/A')
                                proof_required = current_task_data.get('proof_required', False)
                                
                                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "🟡")
                                priority_display = get_text(f'priority_{priority.lower()}', lang)
                                proof_display = get_text('proof_required_yes', lang) if proof_required else get_text('proof_required_no', lang)
                                
                                text = f"✅ 📸 Photo dodat! ({attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'})\n\n"
                                text += f"📝 {get_text('task_confirmation_title', lang)}\n\n"
                                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                                text += f"🏢 {get_text('department', lang)}: {dept_name}\n"
                                text += f"👤 {get_text('assigned_to', lang)}: {emp_name_display}\n"
                                text += f"📋 {get_text('task_order', lang)}:\n{description}\n"
                                text += f"{priority_emoji} {get_text('priority', lang)}: {priority_display}\n"
                                text += f"📆 {get_text('due_date', lang)}: {due_date}\n"
                                text += f"📸 {get_text('proof_required', lang)}: {proof_display}\n"
                                text += f"📎 {get_text('attachment', lang)}: {attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}\n"
                                text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                                text += "Možete dodati još fajlova ili završiti:"
                                
                                keyboard = [
                                    [
                                        InlineKeyboardButton(f"✅ {get_text('confirm', lang)}", callback_data="task_confirm"),
                                        InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")
                                    ]
                                ]
                                reply_markup = InlineKeyboardMarkup(keyboard)
                                await context.bot.send_message(chat_id=telegram_user_id, text=text, reply_markup=reply_markup)
                        
                        # Schedule confirmation message
                        asyncio.create_task(send_confirmation_after_delay())
                        return
                    
                    # Single file (not part of media group) - send confirmation immediately
                    attachment_count = len(task_data['attachments'])
                    
                    dept_name = task_data.get('department_name', get_text('unknown', lang))
                    emp_name = task_data.get('employee_name', get_text('unassigned', lang))
                    emp_name_display = get_text('unassigned', lang) if emp_name == "Unassigned" else emp_name
                    description = task_data.get('description', 'N/A')
                    priority = task_data.get('priority', 'Normal')
                    due_date = task_data.get('due_date', 'N/A')
                    proof_required = task_data.get('proof_required', False)
                    
                    priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(priority, "🟡")
                    priority_display = get_text(f'priority_{priority.lower()}', lang)
                    proof_display = get_text('proof_required_yes', lang) if proof_required else get_text('proof_required_no', lang)
                    
                    text = f"✅ {file_type_display} dodat! ({attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'})\n\n"
                    text += f"📝 {get_text('task_confirmation_title', lang)}\n\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"🏢 {get_text('department', lang)}: {dept_name}\n"
                    text += f"👤 {get_text('assigned_to', lang)}: {emp_name_display}\n"
                    text += f"📋 {get_text('task_order', lang)}:\n{description}\n"
                    text += f"{priority_emoji} {get_text('priority', lang)}: {priority_display}\n"
                    text += f"📆 {get_text('due_date', lang)}: {due_date}\n"
                    text += f"📸 {get_text('proof_required', lang)}: {proof_display}\n"
                    text += f"📎 {get_text('attachment', lang)}: {attachment_count} {'fajl' if attachment_count == 1 else 'fajlova'}\n"
                    text += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    text += "Možete dodati još fajlova ili završiti:"
                    
                    keyboard = [
                        [
                            InlineKeyboardButton(f"✅ {get_text('confirm', lang)}", callback_data="task_confirm"),
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")
                        ]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await update.message.reply_text(text, reply_markup=reply_markup)
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('file_process_error', lang)}\n\n{get_text('or_press_skip', lang)}:",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"⏭️ {get_text('skip_attachment', lang)}", callback_data="task_skip_attachment")],
                            [InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")]
                        ])
                    )
                return
            
            # ========== Task Report: Attachment Upload ==========
            if context.user_data.get('awaiting_report_attachment'):
                file_id = None
                file_type = None
                
                if update.message.photo:
                    file_id = update.message.photo[-1].file_id
                    file_type = "photo"
                elif update.message.document:
                    file_id = update.message.document.file_id
                    file_type = "document"
                elif update.message.video:
                    file_id = update.message.video.file_id
                    file_type = "video"
                
                if file_id:
                    # Initialize attachments list if not exists
                    report_data = context.user_data.get('task_report', {})
                    if 'attachments' not in report_data:
                        report_data['attachments'] = []
                    
                    # Add new attachment to list
                    report_data['attachments'].append({
                        'file_id': file_id,
                        'type': file_type
                    })
                    context.user_data['task_report'] = report_data
                    
                    # Check if this is part of a media group (multiple photos sent at once)
                    media_group_id = update.message.media_group_id
                    
                    if media_group_id:
                        # Store media group ID and set a flag
                        if 'report_media_group_id' not in report_data or report_data['report_media_group_id'] != media_group_id:
                            report_data['report_media_group_id'] = media_group_id
                            report_data['report_media_group_sent'] = False
                            context.user_data['task_report'] = report_data
                        
                        # Skip sending confirmation for now (will be sent after all photos in group)
                        import asyncio
                        
                        # Wait briefly to collect all photos in the media group
                        async def send_report_confirmation_after_delay():
                            await asyncio.sleep(1.5)  # Wait for all media in group
                            current_report_data = context.user_data.get('task_report', {})
                            
                            # Only send if we haven't sent for this media group yet
                            if current_report_data.get('report_media_group_id') == media_group_id and not current_report_data.get('report_media_group_sent'):
                                current_report_data['report_media_group_sent'] = True
                                context.user_data['task_report'] = current_report_data
                                
                                attachment_count = len(current_report_data['attachments'])
                                
                                lang = get_user_language(telegram_user_id, self.db)
                                file_word = get_text('file_added', lang) if attachment_count == 1 else get_text('files_added', lang)
                                
                                await context.bot.send_message(
                                    chat_id=telegram_user_id,
                                    text=f"✅ 📸 {get_text('photo_added', lang)} ({attachment_count} {file_word})\n\n"
                                         f"{get_text('can_add_more_files', lang)}",
                                    reply_markup=InlineKeyboardMarkup([
                                        [InlineKeyboardButton(f"{get_text('finish_and_send', lang)}", callback_data="report_complete_with_attachments")],
                                        [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_report_task")]
                                    ])
                                )
                        
                        # Schedule confirmation message
                        asyncio.create_task(send_report_confirmation_after_delay())
                        return
                    
                    # Single file (not part of media group) - send confirmation immediately
                    attachment_count = len(report_data['attachments'])
                    lang = get_user_language(telegram_user_id, self.db)
                    file_type_display = {
                        "photo": f"📸 {get_text('photo_added', lang)}", 
                        "document": f"📄 {get_text('document_added', lang)}", 
                        "video": f"🎥 {get_text('video_added', lang)}"
                    }.get(file_type, file_type)
                    file_word = get_text('file_added', lang) if attachment_count == 1 else get_text('files_added', lang)
                    
                    await update.message.reply_text(
                        f"✅ {file_type_display} ({attachment_count} {file_word})\n\n"
                        f"{get_text('can_add_more_files', lang)}",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"{get_text('finish_and_send', lang)}", callback_data="report_complete_with_attachments")],
                            [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_report_task")]
                        ])
                    )
                else:
                    await update.message.reply_text(
                        "❌ Nije moguće obraditi datoteku. Pošaljite fotografiju, video ili dokument.\n\n"
                        "Ili pritisnite dugme za preskakanje:",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("⏭️ Preskoči prilog", callback_data="report_skip_attachment")],
                            [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_report_task")]
                        ])
                    )
                return
            
            # ========== Complaint: Media Attachment Processing ==========
            if 'complaint' in context.user_data and context.user_data['complaint'].get('step') == 'media':
                complaint_data = context.user_data['complaint']
                
                # Extract file ID and type
                file_id = None
                media_type = None
                
                if update.message.photo:
                    file_id = update.message.photo[-1].file_id
                    media_type = 'photo'
                elif update.message.document:
                    file_id = update.message.document.file_id
                    media_type = 'document'
                elif update.message.video:
                    file_id = update.message.video.file_id
                    media_type = 'video'
                
                if file_id:
                    # Create complaint with media
                    complaint_id = self.db.create_complaint(
                        telegram_user_id=complaint_data['telegram_user_id'],
                        department=complaint_data['department'],
                        name=complaint_data['name'],
                        complaint_text=complaint_data['text'],
                        media_type=media_type,
                        media_file_id=file_id
                    )
                    
                    if complaint_id:
                        # Clear complaint data
                        del context.user_data['complaint']
                        
                        # Notify admin with media and inline buttons
                        try:
                            from datetime import datetime
                            admins = self.db.get_all_admins()
                            for admin in admins:
                                try:
                                    admin_keyboard = InlineKeyboardMarkup([
                                        [InlineKeyboardButton("✅ Potvrdi", callback_data=f"complaint_confirm_{complaint_id}"),
                                         InlineKeyboardButton("👁 Detalji", callback_data=f"complaint_view_{complaint_id}")]
                                    ])
                                    
                                    # Truncate text if too long for caption (max 1024 chars)
                                    complaint_text_short = complaint_data['text'][:500] + "..." if len(complaint_data['text']) > 500 else complaint_data['text']
                                    
                                    media_caption = f"""� NOVA PRITUŽBA! 🚨

📋 Pritužba #{complaint_id}
👤 Zaposleni: {complaint_data['name']}
🏢 Odeljenje: {get_dept_display(complaint_data['department'])}
📅 Datum: {datetime.now().strftime('%Y-%m-%d %H:%M')}

📝 Pritužba:
{complaint_text_short}"""
                                    
                                    # Send the media with complaint text as caption
                                    if media_type == 'photo':
                                        await self.application.bot.send_photo(
                                            chat_id=admin[0],
                                            photo=file_id,
                                            caption=media_caption,
                                            reply_markup=admin_keyboard
                                        )
                                    elif media_type == 'document':
                                        await self.application.bot.send_document(
                                            chat_id=admin[0],
                                            document=file_id,
                                            caption=media_caption,
                                            reply_markup=admin_keyboard
                                        )
                                    elif media_type == 'video':
                                        await self.application.bot.send_video(
                                            chat_id=admin[0],
                                            video=file_id,
                                            caption=media_caption,
                                            reply_markup=admin_keyboard
                                        )
                                except Exception as e:
                                    print(f"Error sending complaint media to admin: {e}")
                        except Exception as e:
                            print(f"Error getting admins for complaint: {e}")
                        
                        from datetime import datetime
                        lang = get_user_language(telegram_user_id, self.db)
                        success_text = f"""✅ Pritužba uspešno poslata!

📋 ID pritužbe: #{complaint_id}
📅 Datum: {datetime.now().strftime('%Y-%m-%d %H:%M')}
📎 Prilog: {media_type}

{get_text('complaint_forwarded_to_admin', lang)}
Dobićete obaveštenje kada bude potvrđena."""
                        
                        keyboard = [[InlineKeyboardButton("🔙 Nazad", callback_data="emp_complaint")]]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await update.message.reply_text(success_text, reply_markup=reply_markup)
                    else:
                        await update.message.reply_text("❌ Greška pri kreiranju pritužbe. Pokušajte ponovo.")
                else:
                    await update.message.reply_text("❌ Nije moguće obraditi datoteku. Pošaljite fotografiju, video ili dokument.")
                return
            
            # ========== Task: Proof File Upload Processing ==========
            # Check if waiting for proof file upload (skip if already handled by other systems)
            if context.user_data.get('awaiting_driver_report_media') or \
               context.user_data.get('awaiting_restaurant_report_media') or \
               context.user_data.get('awaiting_laundry_report_media'):
                # Already handled by driver/restaurant/laundry report system
                return
            
            # Skip proof check if shift report is in progress
            if self.user_context.get(telegram_user_id, {}).get('reporting_shift'):
                return
            
            if 'waiting_proof' not in context.user_data:
                # Only show this message if it's actually a photo/video/document upload
                # Don't show for regular text messages
                if update.message.photo or update.message.video or update.message.document:
                    lang = get_user_language(telegram_user_id, self.db)
                    await update.message.reply_text(f"❓ {get_text('no_task_waiting_proof', lang)}")
                return
            
            waiting = context.user_data['waiting_proof']
            task_id = waiting.get('task_id')
            
            if not task_id:
                context.user_data.pop('waiting_proof', None)
                lang = get_user_language(telegram_user_id, self.db)
                await update.message.reply_text(f"❌ {get_text('invalid_upload_state', lang)}")
                return
            
            # Extract file ID
            file_id = None
            if update.message.photo:
                # Select largest photo
                file_id = update.message.photo[-1].file_id
            elif update.message.document:
                file_id = update.message.document.file_id
            
            if not file_id:
                await update.message.reply_text("❌ Nije moguće obraditi datoteku. Molimo pošaljite fotografiju ili dokument.")
                return
            
            # Process task completion
            success = self.db.complete_task_with_proof(task_id, file_id)
            
            if success:
                # Remove waiting state
                context.user_data.pop('waiting_proof', None)
                
                # Get task info
                task = self.db.get_task_by_id(task_id)
                if task:
                    t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, t_report_notes, t_report_attachment = task
                    
                    lang = get_user_language(telegram_user_id, self.db)
                    priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(t_priority, "🟡")
                    priority_display = get_text(f'priority_{t_priority.lower()}', lang) if t_priority else t_priority
                    
                    success_text = f"""{get_text('task_completed_msg', lang)}

{get_text('task', lang)} #{t_id}
━━━━━━━━━━━━━━━━━━
{get_text('department', lang)}: {t_dept}
{get_text('description', lang)}: {t_desc[:50]}{'...' if len(t_desc) > 50 else ''}
{priority_emoji} {get_text('priority', lang)}: {priority_display}
📷 {get_text('proof_label', lang)}: {get_text('uploaded', lang)}
━━━━━━━━━━━━━━━━━━

{get_text('admin_notified', lang)}"""
                    
                    keyboard = [[InlineKeyboardButton(f"🔙 {get_text('back_to', lang)} {get_text('report_task_title', lang)}", callback_data="emp_report_task")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await update.message.reply_text(success_text, reply_markup=reply_markup)
                    
                    # Send notification to admin
                    await self.notify_admin_task_completed(task_id, task)
            else:
                await update.message.reply_text("❌ Završavanje zadatka nije uspelo. Molimo pokušajte ponovo.")
        except Exception as e:
            print(f"❌ Error in handle_media: {e}")
            try:
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                await update.message.reply_text(get_text('error_occurred_try_again', lang))
            except:
                pass
    
    async def notify_admin_task_completed(self, task_id: int, task: tuple, report_notes: str = None):
        """
        Send task completion notification to admin
        
        Telegram bot can send messages even if recipient is offline.
        Telegram server stores the message and delivers it when recipient comes online.
        """
        print(f"\n{'='*50}")
        print(f"🔔 notify_admin_task_completed called")
        print(f"   Task ID: {task_id}")
        print(f"   Report Notes: {report_notes[:50] if report_notes else 'None'}...")
        print(f"{'='*50}\n")
        
        try:
            t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, t_report_notes, t_report_attachment = task
            
            print(f"📋 Task Info:")
            print(f"   ID: {t_id}")
            print(f"   Assignee: {t_assignee_name}")
            print(f"   Department: {t_dept}")
            print(f"   Priority: {t_priority}")
            
            # Get admin list
            admin_ids = self.db.get_admin_telegram_ids()
            print(f"\n👥 Admin list retrieved:")
            print(f"   Total {len(admin_ids)} admin(s)")
            print(f"   Admin Telegram IDs: {admin_ids}\n")
            
            if not admin_ids:
                print("⚠️ Warning: No admins registered! Cannot send notification.")
                return
            
            for admin_id in admin_ids:
                # Get admin language preference
                admin_lang = get_user_language(admin_id, self.db)
                print(f"📤 Attempting to send notification to admin {admin_id} (lang: {admin_lang})...")
                
                # Build multilingual notification
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(t_priority, "🟡")
                priority_text = {
                    "Low": get_text('priority_low', admin_lang),
                    "Normal": get_text('priority_normal', admin_lang),
                    "Urgent": get_text('priority_urgent', admin_lang)
                }.get(t_priority, t_priority)
                
                report_text = f"""📥 {get_text('new_task_report', admin_lang)}

━━━━━━━━━━━━━━━━━━
📋 {get_text('task', admin_lang)} #{t_id}
━━━━━━━━━━━━━━━━━━
📅 {get_text('date', admin_lang)}: {t_date}
🏢 {get_text('department', admin_lang)}: {t_dept}
👤 {get_text('completed_by', admin_lang)}: {t_assignee_name}
{priority_emoji} {get_text('priority', admin_lang)}: {priority_text}
📆 {get_text('deadline_label', admin_lang)}: {t_due_date}

📝 {get_text('task_description', admin_lang)}:
{t_desc}
"""
                
                if report_notes:
                    report_text += f"""
📄 {get_text('report', admin_lang)}:
{report_notes}
"""
                
                report_text += "━━━━━━━━━━━━━━━━━━"
                
                keyboard = [
                    [InlineKeyboardButton(get_text('confirm_task', admin_lang), callback_data=f"admin_confirm_{task_id}")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                try:
                    # Send proof file if exists (Telegram delivers even if offline)
                    if t_proof:
                        print(f"   📸 Attachment exists - sending as photo/document")
                        try:
                            await self.application.bot.send_photo(
                                chat_id=admin_id,
                                photo=t_proof,
                                caption=report_text,
                                reply_markup=reply_markup
                            )
                            print(f"   ✅ Sent as photo successfully")
                        except Exception as e:
                            print(f"   ⚠️ Photo send failed: {e}, retrying as document...")
                            try:
                                await self.application.bot.send_document(
                                    chat_id=admin_id,
                                    document=t_proof,
                                    caption=report_text,
                                    reply_markup=reply_markup
                                )
                                print(f"   ✅ Sent as document successfully")
                            except Exception as e2:
                                print(f"   ⚠️ Document send failed: {e2}, retrying as text...")
                                await self.application.bot.send_message(
                                    chat_id=admin_id,
                                    text=report_text,
                                    reply_markup=reply_markup
                                )
                                print(f"   ✅ Sent as text successfully")
                    else:
                        print(f"   📝 No attachment - sending as text message")
                        await self.application.bot.send_message(
                            chat_id=admin_id,
                            text=report_text,
                            reply_markup=reply_markup
                        )
                        print(f"   ✅ Text message sent successfully")
                    print(f"✅ Notification sent to admin {admin_id} (Telegram will deliver later if offline)")
                except Exception as e:
                    print(f"❌ Failed to send notification to admin {admin_id}: {e}")
        except Exception as e:
            print(f"❌ Error in notify_admin_task_completed: {e}")
    
    async def notify_admin_shift_report(self, telegram_user_id: int, emp_name: str, shift_num: int, report: dict, report_summary: str):
        """
        Send shift report notification to admin
        """
        print(f"\n{'='*50}")
        print(f"🔔 notify_admin_shift_report called")
        print(f"   Employee: {emp_name} (ID: {telegram_user_id})")
        print(f"   Shift: {shift_num}")
        print(f"   Report Summary: {report_summary}")
        print(f"{'='*50}\n")
        
        try:
            # Get admin list
            admin_ids = self.db.get_admin_telegram_ids()
            print(f"\n👥 Admin list retrieved:")
            print(f"   Total {len(admin_ids)} admin(s)")
            print(f"   Admin Telegram IDs: {admin_ids}\n")
            
            if not admin_ids:
                print("⚠️ Warning: No admins registered! Cannot send notification.")
                return
            
            for admin_id in admin_ids:
                # Get admin language preference
                admin_lang = get_user_language(admin_id, self.db)
                print(f"📤 Attempting to send shift report notification to admin {admin_id} (lang: {admin_lang})...")
                
                # Build multilingual report text
                report_text = f"""📊 {get_text('shift_report_notification', admin_lang)}

━━━━━━━━━━━━━━━━━━
🔄 {get_text('shift_number', admin_lang)} {shift_num} - Reception
━━━━━━━━━━━━━━━━━━
👤 {get_text('employee', admin_lang)}: {emp_name}
📅 {get_text('date', admin_lang)}: {datetime.now().strftime('%Y-%m-%d %H:%M')}

📋 {get_text('report_details', admin_lang)}:
• {get_text('reservations', admin_lang)}: {report.get('reservations', 0)}
• {get_text('arrivals', admin_lang)}: {report.get('arrivals', 0)}
• {get_text('cash_amount', admin_lang)}: {report.get('cash_amount', 0)}
• {get_text('store_stock_notes', admin_lang)}: {report.get('store_notes', 'N/A')}
• {get_text('key_tool_notes', admin_lang)}: {report.get('key_notes', 'N/A')}
• {get_text('additional_notes', admin_lang)}: {report.get('additional_notes', 'N/A')}

━━━━━━━━━━━━━━━━━━
"""
                
                try:
                    # Send cash photo if exists
                    if report.get('cash_photo'):
                        print(f"   📸 Cash photo exists - sending as photo")
                        try:
                            cash_caption = f"� {get_text('shift_number', admin_lang)} {shift_num} - {get_text('cash_photo', admin_lang) if admin_lang == 'en' else 'Fotografija gotovine'}\n{emp_name}"
                            await self.application.bot.send_photo(
                                chat_id=admin_id,
                                photo=report['cash_photo'],
                                caption=cash_caption
                            )
                            print(f"   ✅ Cash photo sent successfully")
                        except Exception as e:
                            print(f"   ⚠️ Cash photo send failed: {e}")
                    
                    # Send hotel register photo if exists
                    if report.get('hotel_register_photo'):
                        print(f"   📸 Hotel register photo exists - sending as photo")
                        try:
                            register_caption = f"📖 {get_text('shift_number', admin_lang)} {shift_num} - {get_text('hotel_register_photo', admin_lang) if admin_lang == 'en' else 'Fotografija hotelske knjige'}\n{emp_name}"
                            await self.application.bot.send_photo(
                                chat_id=admin_id,
                                photo=report['hotel_register_photo'],
                                caption=register_caption
                            )
                            print(f"   ✅ Hotel register photo sent successfully")
                        except Exception as e:
                            print(f"   ⚠️ Hotel register photo send failed: {e}")
                    
                    # Send report text
                    await self.application.bot.send_message(
                        chat_id=admin_id,
                        text=report_text
                    )
                    print(f"   ✅ Report text sent successfully")
                    print(f"✅ Shift report notification sent to admin {admin_id}")
                except Exception as e:
                    print(f"❌ Failed to send shift report to admin {admin_id}: {e}")
        except Exception as e:
            print(f"❌ Error in notify_admin_shift_report: {e}")
    
    async def notify_admin_task_completed_with_attachment(self, task_id: int, task: tuple, report_notes: str, attachment_file_id: str, attachment_type: str):
        """
        Send task completion notification to admin with attachment
        """
        try:
            t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, t_report_notes, t_report_attachment = task
            
            # Get admin language preference (default to Serbian)
            admin_lang = 'sr'
            
            priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(t_priority, "🟡")
            priority_text = {
                "Low": get_text('priority_low', admin_lang),
                "Normal": get_text('priority_normal', admin_lang),
                "Urgent": get_text('priority_urgent', admin_lang)
            }.get(t_priority, t_priority)
            
            report_text = f"""📥 {get_text('new_task_report', admin_lang)}

━━━━━━━━━━━━━━━━━━
📋 {get_text('task', admin_lang)} #{t_id}
━━━━━━━━━━━━━━━━━━
📅 {get_text('date', admin_lang)}: {t_date}
🏢 {get_text('department', admin_lang)}: {t_dept}
👤 {get_text('completed_by', admin_lang)}: {t_assignee_name}
{priority_emoji} {get_text('priority', admin_lang)}: {priority_text}
📆 {get_text('deadline_label', admin_lang)}: {t_due_date}

📝 {get_text('task_description', admin_lang)}:
{t_desc}

📄 {get_text('report', admin_lang)}:
{report_notes}

📎 {get_text('attachment', admin_lang)}: {attachment_type}
━━━━━━━━━━━━━━━━━━"""
            
            keyboard = [
                [InlineKeyboardButton("✅ Potvrdi zadatak", callback_data=f"admin_confirm_{task_id}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Get admin list
            admin_ids = self.db.get_admin_telegram_ids()
            
            for admin_id in admin_ids:
                try:
                    # Send with attachment
                    if attachment_file_id and len(attachment_file_id.strip()) > 0:
                        if '📸' in attachment_type:
                            await self.application.bot.send_photo(
                                chat_id=admin_id,
                                photo=attachment_file_id,
                                caption=report_text,
                                reply_markup=reply_markup
                            )
                        elif '🎥' in attachment_type:
                            await self.application.bot.send_video(
                                chat_id=admin_id,
                                video=attachment_file_id,
                                caption=report_text,
                                reply_markup=reply_markup
                            )
                        else:
                            await self.application.bot.send_document(
                                chat_id=admin_id,
                                document=attachment_file_id,
                                caption=report_text,
                                reply_markup=reply_markup
                            )
                    else:
                        # Send text-only if no valid attachment
                        await self.application.bot.send_message(
                            chat_id=admin_id,
                            text=report_text,
                            reply_markup=reply_markup
                        )
                    print(f"✅ Notification with attachment sent to admin {admin_id}")
                except Exception as e:
                    print(f"Failed to send notification to admin {admin_id}: {e}")
                    print(f"❌ Failed to send notification to admin {admin_id}: {e}")
        except Exception as e:
            print(f"❌ Error in notify_admin_task_completed_with_attachment: {e}")
    
    async def notify_admin_task_completed_with_multiple_attachments(self, task_id: int, task: tuple, report_notes: str, attachments: list):
        """
        Send task completion notification to admin with multiple attachments
        """
        try:
            t_id, t_date, t_dept, t_assignee_id, t_assignee_name, t_desc, t_priority, t_due_date, t_materials, t_is_check, t_is_perform, t_proof, t_check_admin, t_created_by, t_created_at, t_proof_required, t_report_notes, t_report_attachment = task
            
            # Get admin list
            admin_ids = self.db.get_admin_telegram_ids()
            
            for admin_id in admin_ids:
                # Get admin language preference
                admin_lang = get_user_language(admin_id, self.db)
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(t_priority, "🟡")
                priority_text = {
                    "Low": get_text('priority_low', admin_lang),
                    "Normal": get_text('priority_normal', admin_lang),
                    "Urgent": get_text('priority_urgent', admin_lang)
                }.get(t_priority, t_priority)
                
                file_count = len(attachments)
                attachment_text = f"{file_count} {get_text('file', admin_lang) if file_count == 1 else get_text('files', admin_lang)}"
                
                report_text = f"""📥 {get_text('new_task_report', admin_lang)}

━━━━━━━━━━━━━━━━━━
📋 {get_text('task', admin_lang)} #{t_id}
━━━━━━━━━━━━━━━━━━
📅 {get_text('date', admin_lang)}: {t_date}
🏢 {get_text('department', admin_lang)}: {t_dept}
👤 {get_text('completed_by', admin_lang)}: {t_assignee_name}
{priority_emoji} {get_text('priority', admin_lang)}: {priority_text}
📆 {get_text('deadline_label', admin_lang)}: {t_due_date}

📝 {get_text('task_description', admin_lang)}:
{t_desc}

📄 {get_text('report', admin_lang)}:
{report_notes}

📎 {get_text('attachments', admin_lang) if admin_lang == 'en' else 'Prilozi'}: {attachment_text}
━━━━━━━━━━━━━━━━━━

⏳ {get_text('task_pending_approval', admin_lang)}"""
                
                keyboard = [
                    [
                        InlineKeyboardButton(get_text('approve_task', admin_lang), callback_data=f"approve_task_{task_id}"),
                        InlineKeyboardButton(get_text('reject_task', admin_lang), callback_data=f"reject_task_{task_id}")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                try:
                    # Send first message with text
                    await self.application.bot.send_message(
                        chat_id=admin_id,
                        text=report_text,
                        reply_markup=reply_markup
                    )
                    
                    # Send attachments as media group
                    if attachments:
                        from telegram import InputMediaPhoto, InputMediaVideo
                        
                        media_group = []
                        documents = []
                        
                        file_count = len(attachments)
                        
                        for idx, attachment in enumerate(attachments):
                            file_id = attachment['file_id']
                            file_type = attachment['type']
                            
                            # Add caption only to the first media item
                            item_caption = f"📎 {file_count} {'fajl' if file_count == 1 else 'fajlova'}" if idx == 0 else None
                            
                            if file_type == 'photo':
                                media_group.append(InputMediaPhoto(media=file_id, caption=item_caption))
                            elif file_type == 'video':
                                media_group.append(InputMediaVideo(media=file_id, caption=item_caption))
                            elif file_type == 'document':
                                documents.append(file_id)
                        
                        # Send media group (photos/videos together)
                        if media_group:
                            try:
                                await self.application.bot.send_media_group(
                                    chat_id=admin_id,
                                    media=media_group
                                )
                            except Exception as e:
                                print(f"❌ Failed to send media group to admin {admin_id}: {e}")
                        
                        # Send documents individually
                        for idx, doc_id in enumerate(documents, 1):
                            try:
                                await self.application.bot.send_document(
                                    chat_id=admin_id,
                                    document=doc_id,
                                    caption=f"📎 Dokument {idx}/{len(documents)}"
                                )
                            except Exception as e:
                                print(f"❌ Failed to send document {idx} to admin {admin_id}: {e}")
                    
                    print(f"✅ Notification with {file_count} attachments sent to admin {admin_id}")
                except Exception as e:
                    print(f"❌ Failed to send notification to admin {admin_id}: {e}")
        except Exception as e:
            print(f"❌ Error in notify_admin_task_completed_with_multiple_attachments: {e}")
    
    async def reservations_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Get reservation list"""
        try:
            reservations = self.db.execute_query("""
                SELECT r.reservation_id, rm.room_number, r.guest_name, 
                       r.check_in, r.check_out
                FROM reservations r
                JOIN rooms rm ON r.room_id = rm.room_id
            """)
            
            if not reservations:
                await update.message.reply_text("📅 Nema registrovanih rezervacija.")
                return
            
            message = "📅 Lista rezervacija:\n\n"
            for reservation in reservations:
                res_id, room_number, guest_name, check_in, check_out = reservation
                message += f"ID rezervacije: {res_id}\n"
                message += f"Soba: {room_number}\n"
                message += f"Gost: {guest_name}\n"
                message += f"Prijava: {check_in}\n"
                message += f"Odjava: {check_out}\n"
                message += "-" * 30 + "\n"
            
            await update.message.reply_text(message)
        except Exception as e:
            print(f"❌ Error in reservations_command: {e}")
            try:
                await update.message.reply_text("⚠️ Došlo je do greške pri učitavanju rezervacija. Molimo pokušajte ponovo.")
            except:
                pass
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle general messages"""
        try:
            text = update.message.text
            telegram_user_id = update.effective_user.id
            
            # ========== TASK REJECTION REASON ==========
            if context.user_data.get('awaiting_rejection_reason'):
                task_id = context.user_data.get('pending_rejection_task_id')
                rejection_reason = text.strip()
                
                if not task_id:
                    await update.message.reply_text("❌ Error: Task ID not found.")
                    return
                
                # Check admin permission
                if not self.db.check_admin(telegram_user_id):
                    await update.message.reply_text("❌ Ova komanda nije dostupna.")
                    return
                
                try:
                    from database import validate_task_status_transition, record_task_status_change
                    
                    # Get current task status and assignee
                    self.db.cursor.execute("SELECT status, assignee_id FROM tbl_tasks WHERE id = %s", (task_id,))
                    result = self.db.cursor.fetchone()
                    if not result:
                        await update.message.reply_text("❌ Task not found")
                        return
                    
                    current_status, assignee_id = result[0], result[1]
                    
                    # Validate transition
                    is_valid, error_msg = validate_task_status_transition(current_status, 'rejected')
                    if not is_valid:
                        await update.message.reply_text(f"❌ {error_msg}")
                        return
                    
                    # Update status to rejected
                    self.db.cursor.execute("""
                        UPDATE tbl_tasks 
                        SET status = 'rejected',
                            rejection_reason = %s,
                            completed_at = NULL
                        WHERE id = %s
                    """, (rejection_reason, task_id))
                    
                    # Record status change
                    admin_name = update.effective_user.full_name or update.effective_user.username or "Admin"
                    record_task_status_change(
                        self.db, task_id, 'tbl_tasks',
                        current_status, 'rejected',
                        telegram_user_id, admin_name,
                        f"Task rejected by admin. Reason: {rejection_reason}"
                    )
                    
                    self.db.connection.commit()
                    
                    # Notify employee about rejection
                    if assignee_id:
                        employee_lang = get_user_language(assignee_id, self.db)
                        rejection_message = f"""{get_text('task_rejected_notification', employee_lang)}

{get_text('task', employee_lang)} #{task_id}
━━━━━━━━━━━━━━━━━━
{get_text('task_rejected_by_admin', employee_lang)}

{get_text('rejection_reason', employee_lang)}:
{rejection_reason}

{get_text('please_resubmit', employee_lang)}"""
                        
                        keyboard = [[InlineKeyboardButton(
                            get_text('view_task', employee_lang) if employee_lang == 'en' else 'Погледај задатак',
                            callback_data=f"view_task_{task_id}"
                        )]]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        
                        try:
                            await self.application.bot.send_message(
                                chat_id=assignee_id,
                                text=rejection_message,
                                reply_markup=reply_markup
                            )
                        except Exception as e:
                            print(f"❌ Failed to notify employee {assignee_id}: {e}")
                    
                    # Send confirmation to admin
                    admin_lang = get_user_language(telegram_user_id, self.db)
                    success_text = f"""{get_text('task_rejected_by_admin', admin_lang)}

{get_text('task', admin_lang)} #{task_id}
━━━━━━━━━━━━━━━━━━
❌ {get_text('status', admin_lang)}: {get_text('rejected', admin_lang) if admin_lang == 'en' else 'Одбијен'}
👤 {get_text('rejected_by', admin_lang) if admin_lang == 'en' else 'Одбио'}: {admin_name}

{get_text('rejection_reason', admin_lang)}:
{rejection_reason}

✅ {get_text('employee_notified', admin_lang) if admin_lang == 'en' else 'Запослени је обавештен'}"""
                    
                    keyboard = [[InlineKeyboardButton(get_text('back_to_reports', admin_lang), callback_data="admin_pending_reports")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await update.message.reply_text(success_text, reply_markup=reply_markup)
                    
                except Exception as e:
                    print(f"❌ Error rejecting task: {e}")
                    import traceback
                    traceback.print_exc()
                    await update.message.reply_text(f"❌ Error: {str(e)}")
                
                finally:
                    # Clean up context
                    context.user_data.pop('pending_rejection_task_id', None)
                    context.user_data.pop('awaiting_rejection_reason', None)
                
                return
            
            # ========== INVENTORY STOCK UPDATE ==========
            if context.user_data.get('updating_inventory_item'):
                from database import update_inventory_stock, get_inventory_item_by_id
                
                item_id = context.user_data.get('updating_inventory_item')
                unit = context.user_data.get('inventory_item_unit', 'units')
                lang = get_user_language(telegram_user_id, self.db)
                
                try:
                    new_stock = float(text.strip())
                    if new_stock < 0:
                        raise ValueError("Stock cannot be negative")
                    
                    # Get current stock before update
                    old_item = get_inventory_item_by_id(self.db, item_id) if hasattr(self.db, 'cursor') else None
                    old_stock = old_item.get('stock') if old_item else None
                    item_name = old_item.get('name') if old_item else f"Item #{item_id}"
                    
                    if update_inventory_stock(self.db, item_id, new_stock):
                        # Log action with before/after state
                        employee = self.db.check_employee_exists(telegram_user_id)
                        if employee:
                            employee_id, name, department, work_role, gmail, whatsapp = employee
                            try:
                                event_logger = get_event_logger()
                                event_logger.log_inventory_update(
                                    user_id=telegram_user_id,
                                    user_name=name,
                                    item_id=item_id,
                                    item_name=item_name,
                                    old_stock=old_stock,
                                    new_stock=new_stock,
                                    unit=unit,
                                    department=department,
                                    employee_id=employee_id
                                )
                            except Exception as log_error:
                                print(f"Event logging error: {log_error}")
                        
                        await update.message.reply_text(
                            f"✅ Stock updated successfully!\n\n"
                            f"Item #{item_id}\n"
                            f"New Stock: {new_stock} {unit}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton("🔙 Back to Inventory", callback_data="emp_work_inventory")
                            ]])
                        )
                    else:
                        await update.message.reply_text(
                            f"❌ Error updating stock. Please try again.",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton("🔙 Back to Inventory", callback_data="emp_work_inventory")
                            ]])
                        )
                except ValueError as e:
                    await update.message.reply_text(
                        f"❌ Invalid number. Please enter a valid positive number.",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton("❌ Cancel", callback_data="inventory_update")
                        ]])
                    )
                    return
                finally:
                    # Clean up context
                    context.user_data.pop('updating_inventory_item', None)
                    context.user_data.pop('inventory_item_unit', None)
                    context.user_data.pop('callback_query_data', None)
                return
            
            # ========== SHIFT TIME INPUT (check early) ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_shift_start'):
                self.user_context[telegram_user_id]['awaiting_shift_start'] = False
                lang = get_user_language(telegram_user_id, self.db)
                time_input = text.strip()
                
                # Validate time format HH:MM
                import re
                time_pattern = r'^([0-1]?[0-9]|2[0-4]):([0-5][0-9])$'
                if not re.match(time_pattern, time_input):
                    await update.message.reply_text(
                        f"❌ {get_text('invalid_time_format', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="shift_edit_start")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_shift_start'] = True
                    return
                
                # Normalize to HH:MM format
                parts = time_input.split(':')
                time_input = f"{int(parts[0]):02d}:{parts[1]}"
                
                # Get shift index (0=A, 1=B, 2=C)
                shift_index = self.user_context[telegram_user_id].get('editing_shift_index', 0)
                shift_letter = self.user_context[telegram_user_id].get('editing_shift_letter', 'A')
                
                # Update shift_starts list
                if 'shift_starts' not in self.user_context[telegram_user_id]:
                    self.user_context[telegram_user_id]['shift_starts'] = ['08:00', '16:00', '00:00']
                
                self.user_context[telegram_user_id]['shift_starts'][shift_index] = time_input
                
                # Show updated configuration
                shift_starts = self.user_context[telegram_user_id]['shift_starts']
                
                text_msg = f"✅ {get_text('shift', lang)} {shift_letter} {get_text('start_time', lang)}: {time_input}\n\n"
                text_msg += f"📝 {get_text('current_settings', lang)}:\n"
                for i, start in enumerate(shift_starts):
                    letter = ['A', 'B', 'C'][i]
                    text_msg += f"  {letter}️⃣ {get_text('starts_at', lang)}: {start}\n"
                
                text_msg += f"\n💡 {get_text('end_times_auto_calculated', lang)}"
                
                keyboard = [
                    [InlineKeyboardButton(f"✏️ {get_text('edit_shift', lang)} A", callback_data="shift_edit_A")],
                    [InlineKeyboardButton(f"✏️ {get_text('edit_shift', lang)} B", callback_data="shift_edit_B")],
                    [InlineKeyboardButton(f"✏️ {get_text('edit_shift', lang)} C", callback_data="shift_edit_C")],
                    [InlineKeyboardButton(f"💾 {get_text('save_settings', lang)}", callback_data="shift_save_new")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="settings_shift")]
                ]
                
                await update.message.reply_text(text_msg, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            
            # Old awaiting_shift_end handler - no longer needed
            if self.user_context.get(telegram_user_id, {}).get('awaiting_shift_end'):
                self.user_context[telegram_user_id]['awaiting_shift_end'] = False
                # Redirect to new flow
                lang = get_user_language(telegram_user_id, self.db)
                await update.message.reply_text(
                    f"⚠️ {get_text('end_times_auto_calculated', lang)}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="shift_edit_start")
                    ]])
                )
                return
            
            # ========== EVENT CREATION (Template-based 7 steps) ==========
            if context.user_data.get('creating_event'):
                from database import create_event, create_event_history, create_event_task
                from templates import get_event_input_step, auto_assign_event_tasks
                
                lang = get_user_language(telegram_user_id, self.db)
                event_data = context.user_data['creating_event']
                step = event_data.get('step')
                template = event_data.get('template', {})
                template_name = template.get('name', {}).get(lang, 'Event')
                
                # Step 1: Event Name
                if step == 1:
                    event_data['event_name'] = text.strip()
                    event_data['step'] = 2
                    
                    step_info = get_event_input_step(lang, 2)
                    await update.message.reply_text(
                        f"✅ {get_event_input_step(lang, 1)['title']}: {text.strip()}\n\n"
                        f"Step 2/7: {step_info['title']}\n\n{step_info['prompt']}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")
                        ]])
                    )
                    return
                
                # Step 2: Hall/Venue
                elif step == 2:
                    event_data['hall'] = text.strip()
                    event_data['step'] = 3
                    
                    # Show calendar for date selection
                    from datetime import datetime
                    today = datetime.now()
                    calendar_keyboard = create_calendar(today.year, today.month, lang, 'event_date')
                    calendar_keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")])
                    
                    step_info = get_event_input_step(lang, 3)
                    await update.message.reply_text(
                        f"✅ {get_event_input_step(lang, 2)['title']}: {text.strip()}\n\n"
                        f"Step 3/7: {step_info['title']}\n\n{step_info['prompt']}",
                        reply_markup=InlineKeyboardMarkup(calendar_keyboard)
                    )
                    return
                
                # Step 3: Date (handled by calendar, but keep fallback)
                elif step == 3:
                    import re
                    date_pattern = r'^\d{4}-\d{2}-\d{2}$'
                    if not re.match(date_pattern, text.strip()):
                        from datetime import datetime
                        today = datetime.now()
                        calendar_keyboard = create_calendar(today.year, today.month, lang, 'event_date')
                        calendar_keyboard.append([InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")])
                        
                        await update.message.reply_text(
                            f"❌ Invalid date format. Use YYYY-MM-DD or select from calendar.",
                            reply_markup=InlineKeyboardMarkup(calendar_keyboard)
                        )
                        return
                    event_data['event_date'] = text.strip()
                    event_data['step'] = 4
                    
                    step_info = get_event_input_step(lang, 4)
                    await update.message.reply_text(
                        f"✅ {get_event_input_step(lang, 3)['title']}: {text.strip()}\n\n"
                        f"Step 4/7: {step_info['title']}\n\n{step_info['prompt']}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")
                        ]])
                    )
                    return
                
                # Step 4: Start Time
                elif step == 4:
                    import re
                    time_pattern = r'^([0-1]?[0-9]|2[0-3]):([0-5][0-9])$'
                    if not re.match(time_pattern, text.strip()):
                        await update.message.reply_text(
                            f"❌ Invalid time format. Use HH:MM (e.g. 14:00)",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")
                            ]])
                        )
                        return
                    event_data['event_time'] = text.strip()
                    
                    # Calculate end time based on template duration
                    default_duration = template.get('default_duration', 3)
                    from datetime import datetime, timedelta
                    start_time = datetime.strptime(text.strip(), '%H:%M')
                    end_time = (start_time + timedelta(hours=default_duration)).strftime('%H:%M')
                    event_data['end_time'] = end_time
                    
                    event_data['step'] = 5
                    
                    step_info = get_event_input_step(lang, 5)
                    await update.message.reply_text(
                        f"✅ {get_event_input_step(lang, 4)['title']}: {text.strip()}\n"
                        f"⏱️ End Time (auto): {end_time} (+{default_duration}h)\n\n"
                        f"Step 5/7: {step_info['title']}\n\n{step_info['prompt']}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")
                        ]])
                    )
                    return
                
                # Step 5: Number of Guests
                elif step == 5:
                    try:
                        seats = int(text.strip())
                        if seats <= 0:
                            raise ValueError("Must be positive")
                        event_data['seats'] = seats
                        event_data['meals_count'] = seats  # Default meals = guests
                    except ValueError:
                        await update.message.reply_text(
                            f"❌ Please enter a valid number.",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")
                            ]])
                        )
                        return
                    event_data['step'] = 6
                    
                    step_info = get_event_input_step(lang, 6)
                    await update.message.reply_text(
                        f"✅ {get_event_input_step(lang, 5)['title']}: {seats}\n\n"
                        f"Step 6/7: {step_info['title']}\n\n{step_info['prompt']}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('skip', lang), callback_data="event_skip_location"),
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")
                        ]])
                    )
                    return
                
                # Step 6: Location (optional)
                elif step == 6:
                    event_data['location'] = None if text.strip().lower() == 'skip' else text.strip()
                    event_data['step'] = 7
                    
                    step_info = get_event_input_step(lang, 7)
                    location_text = event_data['location'] if event_data['location'] else 'Skipped'
                    await update.message.reply_text(
                        f"✅ {get_event_input_step(lang, 6)['title']}: {location_text}\n\n"
                        f"Step 7/7: {step_info['title']}\n\n{step_info['prompt']}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('skip', lang), callback_data="event_skip_notes"),
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_events")
                        ]])
                    )
                    return
                
                # Step 7: Additional Notes (optional) - FINAL STEP
                elif step == 7:
                    event_data['notes'] = None if text.strip().lower() == 'skip' else text.strip()
                    event_data['created_by'] = telegram_user_id
                    event_data['price'] = 0  # Default price, can be updated later
                    
                    # Create event in database
                    event_id = create_event(self.db, event_data)
                    
                    if event_id:
                        # Create event history records for each department in template
                        departments = template.get('departments', ['Reception', 'Kitchen', 'Housekeeping'])
                        for dept in departments:
                            create_event_history(self.db, event_id, dept, 'T-2')
                        
                        # Use AI-based task assignment
                        event_type = event_data.get('event_type', 'custom')
                        assigned_task_ids = auto_assign_event_tasks(self.db, event_id, event_type, event_data['event_date'])
                        
                        tasks_created = len(assigned_task_ids)
                        
                        context.user_data['creating_event'] = None
                        
                        await update.message.reply_text(
                            f"✅ {get_text('event_created', lang)}\n\n"
                            f"📌 {event_data['event_name']} ({template_name})\n"
                            f"📍 {event_data['hall']}\n"
                            f"📅 {event_data['event_date']} {event_data['event_time']}-{event_data.get('end_time', '')}\n"
                            f"👥 {event_data['seats']} guests\n"
                            f"🍽️ Menu: {event_data.get('menu', 'N/A')}\n"
                            f"📝 Notes: {event_data.get('notes', 'N/A')}\n\n"
                            f"🤖 AI assigned {tasks_created} tasks to departments",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('event_list', lang), callback_data="admin_event_list"),
                                InlineKeyboardButton(get_text('back', lang), callback_data="admin_events")
                            ]])
                        )
                    else:
                        await update.message.reply_text(
                            "❌ Error creating event",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('back', lang), callback_data="admin_events")
                            ]])
                        )
                    return
            
            # ========== EVENT MANUAL TASK DESCRIPTION ==========
            if context.user_data.get('event_task_creation') and context.user_data['event_task_creation'].get('step') == 'description':
                from database import create_event_task
                from datetime import datetime, timedelta
                
                lang = get_user_language(telegram_user_id, self.db)
                event_task_data = context.user_data['event_task_creation']
                
                description = text.strip()
                if not description or len(description) < 3:
                    await update.message.reply_text(
                        f"❌ {get_text('description_too_short', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_event_view_{event_task_data['event_id']}")
                        ]])
                    )
                    return
                
                # Build full task description with event info
                full_desc = f"🎉 {event_task_data.get('event_name', 'Event')}\n"
                full_desc += f"📅 {event_task_data.get('event_date', '')} {event_task_data.get('event_time', '')}\n\n"
                full_desc += f"📋 {description}"
                
                # Calculate due date (T-1)
                event_date_raw = event_task_data['event_date']
                # Handle both string and date object
                if isinstance(event_date_raw, str):
                    event_date = datetime.strptime(event_date_raw, '%Y-%m-%d')
                else:
                    # Already a date object
                    event_date = datetime.combine(event_date_raw, datetime.min.time())
                task_due_date = (event_date - timedelta(days=1)).strftime('%Y-%m-%d')
                
                # Create task
                task_data = {
                    'department_name': event_task_data.get('dept_name'),
                    'employee_id': event_task_data.get('emp_telegram'),
                    'employee_name': event_task_data.get('emp_name'),
                    'description': full_desc,
                    'priority': 'Normal',
                    'due_date': task_due_date,
                    'requires_materials': False,
                    'created_by': telegram_user_id,
                    'proof_required': True
                }
                
                task_id = self.db.create_task(task_data)
                
                if task_id:
                    # Link task to event with assignment info
                    create_event_task(
                        self.db, 
                        event_task_data['event_id'], 
                        task_id, 
                        event_task_data['dept_name'], 
                        'manual', 
                        full_desc, 
                        task_due_date,
                        event_task_data.get('emp_telegram'),
                        event_task_data.get('emp_name')
                    )
                    
                    # Notify assigned employee
                    try:
                        await self.application.bot.send_message(
                            chat_id=event_task_data['emp_telegram'],
                            text=f"📋 {get_text('new_task_assigned', lang)}\n\n"
                                 f"🎉 Event: {event_task_data['event_name']}\n"
                                 f"📅 Date: {event_task_data['event_date']}\n"
                                 f"📋 Task: {description}\n"
                                 f"📆 Due: {task_due_date}"
                        )
                    except Exception as e:
                        print(f"⚠️ Could not notify employee: {e}")
                    
                    context.user_data['event_task_creation'] = None
                    
                    await update.message.reply_text(
                        f"✅ {get_text('task_created', lang)}\n\n"
                        f"🎉 Event: {event_task_data['event_name']}\n"
                        f"🏢 {get_text('department', lang)}: {event_task_data['dept_name']}\n"
                        f"👤 {get_text('assigned_to', lang)}: {event_task_data['emp_name']}\n"
                        f"📋 {description}\n"
                        f"📆 Due: {task_due_date}",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"➕ {get_text('add_another_task', lang)}", callback_data=f"event_manual_task_{event_task_data['event_id']}")],
                            [InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_event_view_{event_task_data['event_id']}")]
                        ])
                    )
                else:
                    await update.message.reply_text(
                        "❌ Error creating task",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_event_view_{event_task_data['event_id']}")
                        ]])
                    )
                return
            
            # ========== ADMIN PROFILE: Name Change ==========
            if context.user_data.get('awaiting_admin_name_change'):
                context.user_data['awaiting_admin_name_change'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_name = text.strip()
                
                if not self.db.check_admin(telegram_user_id):
                    await update.message.reply_text(f"❌ {get_text('no_permission', lang)}")
                    return
                
                # Validate name
                if not new_name or len(new_name) < 2:
                    await update.message.reply_text(
                        "❌ Name too short",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="information")
                        ]])
                    )
                    return
                
                # Update name in database
                if self.db.update_employee_name(telegram_user_id, new_name):
                    await update.message.reply_text(
                        get_text('name_updated', lang),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="information")
                        ]])
                    )
                else:
                    await update.message.reply_text("❌ Error updating name")
                return
            
            # ========== PROFILE: Name Change ==========
            if context.user_data.get('awaiting_name_change'):
                context.user_data['awaiting_name_change'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_name = text.strip()
                
                # Validate name
                if not new_name or len(new_name) < 2:
                    await update.message.reply_text(
                        "❌ Name too short",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="emp_profile")
                        ]])
                    )
                    return
                
                # Update name in database
                if self.db.update_employee_name(telegram_user_id, new_name):
                    await update.message.reply_text(
                        get_text('name_updated', lang),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="emp_profile")
                        ]])
                    )
                else:
                    await update.message.reply_text("❌ Error updating name")
                return
            
            # ========== SHIFT REPORT: Photo Required - Text Input Error ==========
            # Check if user is expected to send a photo but sent text instead
            if self.user_context.get(telegram_user_id, {}).get('awaiting_cash_pos_photo'):
                lang = get_user_language(telegram_user_id, self.db)
                await update.message.reply_text(
                    f"❌ {get_text('please_send_photo', lang)}\n\n"
                    f"📷 Please upload photo of cash register and POS report",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            if self.user_context.get(telegram_user_id, {}).get('awaiting_hotel_register_photo'):
                lang = get_user_language(telegram_user_id, self.db)
                await update.message.reply_text(
                    f"❌ {get_text('please_send_photo', lang)}\n\n"
                    f"📷 Please upload photo of hotel register (guest book)",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== SHIFT REPORT: Reservations Count (Reception) ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_reservations_count'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_reservations_count'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                # Check if format is "reservations,arrivals"
                if ',' in text.strip():
                    try:
                        parts = text.strip().split(',')
                        reservations = int(parts[0].strip())
                        arrivals = int(parts[1].strip())
                        if reservations < 0 or arrivals < 0:
                            raise ValueError()
                        
                        self.user_context[telegram_user_id]['shift_report']['reservations'] = reservations
                        self.user_context[telegram_user_id]['shift_report']['arrivals'] = arrivals
                        self.user_context[telegram_user_id]['shift_report_step'] = 2
                        self.user_context[telegram_user_id]['awaiting_cash_amount'] = True
                        
                        shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                        step_template = get_shift_report_input_template(lang, 2)
                        
                        await update.message.reply_text(
                            f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                            f"✅ {get_text('reservations', lang)}: {reservations}\n"
                            f"✅ {get_text('arrivals', lang)}: {arrivals}\n\n"
                            f"━━━━━━━━━━━━━━━━━━━━━━\n"
                            f"{step_template['title']}\n"
                            f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                            f"{step_template['prompt']}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                            ]])
                        )
                        return
                    except (ValueError, IndexError):
                        pass
                
                try:
                    reservations = int(text.strip())
                    if reservations < 0:
                        raise ValueError()
                except ValueError:
                    await update.message.reply_text(
                        "❌ Please enter a valid number\n\nFormat: reservations,arrivals (e.g., 15,8)",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_reservations_count'] = True
                    return
                
                self.user_context[telegram_user_id]['shift_report']['reservations'] = reservations
                self.user_context[telegram_user_id]['awaiting_arrivals_count'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ {get_text('reservations', lang)}: {reservations}\n\n"
                    f"📊 {get_text('step', lang)} 1b/7: {get_text('enter_arrivals_count', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== SHIFT REPORT: Arrivals Count ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_arrivals_count'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_arrivals_count'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                try:
                    arrivals = int(text.strip())
                    if arrivals < 0:
                        raise ValueError()
                except ValueError:
                    await update.message.reply_text(
                        "❌ Please enter a valid number",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_arrivals_count'] = True
                    return
                
                self.user_context[telegram_user_id]['shift_report']['arrivals'] = arrivals
                self.user_context[telegram_user_id]['shift_report_step'] = 2
                self.user_context[telegram_user_id]['awaiting_cash_amount'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                reservations = self.user_context[telegram_user_id]['shift_report'].get('reservations', 0)
                step_template = get_shift_report_input_template(lang, 2)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ {get_text('reservations', lang)}: {reservations}\n"
                    f"✅ {get_text('arrivals', lang)}: {arrivals}\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== SHIFT REPORT: Cash Amount ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_cash_amount'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_cash_amount'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                try:
                    # Remove any currency symbols and commas
                    amount_str = text.strip().replace(',', '').replace('.', '').replace('$', '').replace('€', '').replace('RSD', '').replace('rsd', '')
                    cash_amount = float(amount_str)
                    if cash_amount < 0:
                        raise ValueError()
                except ValueError:
                    await update.message.reply_text(
                        "❌ Please enter a valid number (e.g., 125000)",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_cash_amount'] = True
                    return
                
                self.user_context[telegram_user_id]['shift_report']['cash_amount'] = cash_amount
                self.user_context[telegram_user_id]['shift_report_step'] = 3
                self.user_context[telegram_user_id]['awaiting_cash_pos_photo'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                reservations = self.user_context[telegram_user_id]['shift_report'].get('reservations', 0)
                arrivals = self.user_context[telegram_user_id]['shift_report'].get('arrivals', 0)
                step_template = get_shift_report_input_template(lang, 3)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ {get_text('reservations', lang)}: {reservations}\n"
                    f"✅ {get_text('arrivals', lang)}: {arrivals}\n"
                    f"✅ {get_text('cash_report', lang)}: {cash_amount:,.0f}\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== SHIFT REPORT: Store Stock Notes ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_store_stock_notes'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_store_stock_notes'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                notes = text.strip()
                if notes.lower() == get_text('skip', lang) or notes.lower() == 'skip' or notes.lower() == 'ok':
                    notes = 'OK - No issues'
                
                self.user_context[telegram_user_id]['shift_report']['store_stock_notes'] = notes
                self.user_context[telegram_user_id]['shift_report_step'] = 6
                self.user_context[telegram_user_id]['awaiting_key_tool_notes'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                step_template = get_shift_report_input_template(lang, 6)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ Store & Restaurant: {notes[:30]}{'...' if len(notes) > 30 else ''}\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== SHIFT REPORT: Key/Tool Notes ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_key_tool_notes'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_key_tool_notes'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                notes = text.strip()
                if notes.lower() == get_text('skip', lang) or notes.lower() == 'skip' or notes.lower() == 'ok':
                    notes = 'OK - No items issued/returned'
                
                self.user_context[telegram_user_id]['shift_report']['key_tool_notes'] = notes
                self.user_context[telegram_user_id]['shift_report_step'] = 7
                self.user_context[telegram_user_id]['awaiting_additional_notes'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                step_template = get_shift_report_input_template(lang, 7)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ Keys/Tools: {notes[:30]}{'...' if len(notes) > 30 else ''}\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== SHIFT REPORT: Additional Notes (Final Step) ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_additional_notes'):
                from templates import get_shift_report_input_template, format_shift_report_summary
                self.user_context[telegram_user_id]['awaiting_additional_notes'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                notes = text.strip()
                if notes.lower() == get_text('skip', lang) or notes.lower() == 'skip' or notes.lower() == 'ok':
                    notes = 'None'
                
                self.user_context[telegram_user_id]['shift_report']['additional_notes'] = notes
                
                # Save the shift report
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                report = self.user_context[telegram_user_id].get('shift_report', {})
                
                # Get employee info
                employee = self.db.check_employee_exists(telegram_user_id)
                if not employee:
                    await update.message.reply_text(get_text('error_occurred', lang))
                    return
                
                employee_id, name, department, work_role, gmail, whatsapp = employee
                
                try:
                    from datetime import date
                    report_id = self.db.create_shift_report(
                        shift_date=date.today().isoformat(),
                        shift_number=shift_num,
                        employee_id=employee_id,  # Use actual employee_id, not telegram_user_id
                        reservations_count=report.get('reservations', 0),
                        arrivals_count=report.get('arrivals', 0),
                        cash_amount=report.get('cash_amount', 0),
                        cash_photo=report.get('cash_photo', ''),
                        pos_report_photo=report.get('hotel_register_photo', ''),
                        store_stock_notes=report.get('store_stock_notes', ''),
                        restaurant_cash_confirmed=True,  # Default to True since field removed
                        key_log_notes=report.get('key_tool_notes', ''),
                        tool_log_notes=report.get('additional_notes', '')
                    )
                    
                    # Check if AI analysis is enabled
                    hotel_settings = self.db.get_hotel_settings()
                    ai_enabled = hotel_settings.get('ai_analysis_enabled', False)
                    
                    analysis_text = ""
                    if ai_enabled:
                        try:
                            from ai_analyzer import ShiftReportAnalyzer
                            analyzer = ShiftReportAnalyzer()
                            
                            # Prepare report data for analysis
                            employee_info = self.db.get_employee_info(telegram_user_id)
                            report_data = {
                                'id': report_id,
                                'date': date.today().isoformat(),
                                'shift_number': shift_num,
                                'employee_name': employee_info.get('name', 'Unknown') if employee_info else 'Unknown',
                                'reservations_count': report.get('reservations', 0),
                                'arrivals_count': report.get('arrivals', 0),
                                'cash_amount': report.get('cash_amount', 0),
                                'store_stock_notes': report.get('store_stock_notes', ''),
                                'restaurant_cash_confirmed': report.get('restaurant_cash_confirmed', False),
                                'key_log_notes': report.get('key_tool_notes', ''),
                            }
                            
                            # Run AI analysis if configured
                            if analyzer.is_configured():
                                result = analyzer.analyze_shift_report(report_data, lang)
                                if result.get('success'):
                                    analysis_text = f"\n\n📊 {get_text('ai_analysis_result', lang)}:\n{result.get('analysis', '')[:1000]}"
                                    
                                    # Send notifications if enabled
                                    email_enabled = hotel_settings.get('email_notifications_enabled', False)
                                    whatsapp_enabled = hotel_settings.get('whatsapp_notifications_enabled', False)
                                    
                                    if email_enabled or whatsapp_enabled:
                                        try:
                                            from message_sender import MessageSender
                                            sender = MessageSender()
                                            
                                            # Get admin contacts
                                            admins = self.db.get_all_admins()
                                            for admin in admins:
                                                admin_info = self.db.get_employee_info(admin[2])
                                                if admin_info:
                                                    if email_enabled and admin_info.get('gmail'):
                                                        sender.send_shift_report_email(
                                                            admin_info['gmail'],
                                                            report_data,
                                                            lang
                                                        )
                                                    if whatsapp_enabled and admin_info.get('whatsapp'):
                                                        sender.send_shift_report_whatsapp(
                                                            admin_info['whatsapp'],
                                                            report_data,
                                                            lang
                                                        )
                                        except Exception as notify_error:
                                            print(f"Notification error: {notify_error}")
                            else:
                                # Basic analysis when AI not configured
                                basic_result = analyzer._basic_analysis(report_data)
                                grade = basic_result.get('grade', 'N/A')
                                analysis_text = f"\n\n📊 Shift Grade: {grade}"
                        except Exception as ai_error:
                            print(f"AI analysis error: {ai_error}")
                    
                    # Clear context
                    self.user_context[telegram_user_id].pop('reporting_shift', None)
                    self.user_context[telegram_user_id].pop('shift_report', None)
                    
                    # Log shift report submission
                    try:
                        event_logger = get_event_logger()
                        employee = self.db.check_employee_exists(telegram_user_id)
                        emp_name = employee[1] if employee else update.effective_user.full_name
                        event_logger.log_shift_report_submitted(
                            user_id=telegram_user_id,
                            user_name=emp_name,
                            shift_type=f"Shift {shift_num}",
                            department="Reception",
                            report_data={
                                "reservations": report.get('reservations', 0),
                                "arrivals": report.get('arrivals', 0),
                                "cash_amount": report.get('cash_amount', 0)
                            }
                        )
                    except Exception as log_error:
                        print(f"Event logging error: {log_error}")
                    
                    # Send shift report notification to admin
                    employee = self.db.check_employee_exists(telegram_user_id)
                    emp_name = employee[1] if employee else update.effective_user.full_name
                    report_summary = f"Shift {shift_num} Report: Reservations={report.get('reservations', 0)}, Arrivals={report.get('arrivals', 0)}, Cash={report.get('cash_amount', 0)}"
                    
                    try:
                        await self.notify_admin_shift_report(telegram_user_id, emp_name, shift_num, report, report_summary)
                        print(f"🔔 Admin notified about shift {shift_num} report from {emp_name}")
                    except Exception as notify_err:
                        print(f"⚠️ Admin notification error: {notify_err}")
                    
                    # If this was from a task, complete the task as well
                    shift_report_task_id = self.user_context[telegram_user_id].pop('shift_report_task_id', None)
                    if shift_report_task_id:
                        # Complete the task with report summary
                        success = self.db.complete_task_with_report(shift_report_task_id, report_summary, None)
                        print(f"✅ Task #{shift_report_task_id} completed with shift report (success={success})")
                        
                        # Also update task status to notify admin via task system
                        if success:
                            try:
                                task = self.db.get_task_by_id(shift_report_task_id)
                                if task:
                                    await self.notify_admin_task_completed(shift_report_task_id, task, report_summary)
                                    print(f"🔔 Admin notified about shift report task #{shift_report_task_id}")
                            except Exception as task_notify_err:
                                print(f"⚠️ Task notification error: {task_notify_err}")
                    
                    await update.message.reply_text(
                        f"✅ {get_text('shift_report_submitted', lang)}{analysis_text}\n\n"
                        f"💡 Type /start to return to main menu.",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🏠 /start", callback_data="emp_start_menu")
                        ]])
                    )
                except Exception as e:
                    print(f"Error saving shift report: {e}")
                    await update.message.reply_text(
                        f"❌ {get_text('shift_report_error', lang)}: {e}\n\n"
                        f"💡 Type /start to return to main menu.",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🏠 /start", callback_data="emp_start_menu")
                        ]])
                    )
                return
            
            # ========== RESTAURANT SHIFT REPORT: Guests Served (Step 1) ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_guests_served'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_guests_served'] = False
                lang = get_user_language(telegram_user_id, self.db)
                department = self.user_context[telegram_user_id].get('shift_report_department', 'Restaurant')
                
                try:
                    guests_served = int(text.strip())
                    if guests_served < 0:
                        raise ValueError()
                except ValueError:
                    await update.message.reply_text(
                        "❌ Please enter a valid number",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_guests_served'] = True
                    return
                
                self.user_context[telegram_user_id]['shift_report']['guests_served'] = guests_served
                self.user_context[telegram_user_id]['shift_report_step'] = 2
                self.user_context[telegram_user_id]['awaiting_cash_sales'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                step_template = get_shift_report_input_template(lang, 2, department)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ Guests Served: {guests_served}\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== RESTAURANT SHIFT REPORT: Cash Sales (Step 2) ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_cash_sales'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_cash_sales'] = False
                lang = get_user_language(telegram_user_id, self.db)
                department = self.user_context[telegram_user_id].get('shift_report_department', 'Restaurant')
                
                try:
                    amount_str = text.strip().replace(',', '').replace('.', '').replace('$', '').replace('€', '').replace('RSD', '').replace('rsd', '')
                    cash_sales = float(amount_str)
                    if cash_sales < 0:
                        raise ValueError()
                except ValueError:
                    await update.message.reply_text(
                        "❌ Please enter a valid number (e.g., 50000)",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_cash_sales'] = True
                    return
                
                self.user_context[telegram_user_id]['shift_report']['cash_sales'] = cash_sales
                self.user_context[telegram_user_id]['shift_report_step'] = 3
                self.user_context[telegram_user_id]['awaiting_card_sales'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                step_template = get_shift_report_input_template(lang, 3, department)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ Guests Served: {self.user_context[telegram_user_id]['shift_report'].get('guests_served', 0)}\n"
                    f"✅ Cash Sales: {cash_sales:,.0f}\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== RESTAURANT SHIFT REPORT: Card Sales (Step 3) ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_card_sales'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_card_sales'] = False
                lang = get_user_language(telegram_user_id, self.db)
                department = self.user_context[telegram_user_id].get('shift_report_department', 'Restaurant')
                
                try:
                    amount_str = text.strip().replace(',', '').replace('.', '').replace('$', '').replace('€', '').replace('RSD', '').replace('rsd', '')
                    card_sales = float(amount_str)
                    if card_sales < 0:
                        raise ValueError()
                except ValueError:
                    await update.message.reply_text(
                        "❌ Please enter a valid number (e.g., 75000)",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_card_sales'] = True
                    return
                
                self.user_context[telegram_user_id]['shift_report']['card_sales'] = card_sales
                self.user_context[telegram_user_id]['shift_report_step'] = 4
                self.user_context[telegram_user_id]['awaiting_food_waste'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                step_template = get_shift_report_input_template(lang, 4, department)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ Cash Sales: {self.user_context[telegram_user_id]['shift_report'].get('cash_sales', 0):,.0f}\n"
                    f"✅ Card Sales: {card_sales:,.0f}\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== RESTAURANT SHIFT REPORT: Food Waste (Step 4) ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_food_waste'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_food_waste'] = False
                lang = get_user_language(telegram_user_id, self.db)
                department = self.user_context[telegram_user_id].get('shift_report_department', 'Restaurant')
                
                food_waste = text.strip()
                if food_waste.lower() in ['none', 'no', 'n/a', 'nema', 'ok']:
                    food_waste = 'None reported'
                
                self.user_context[telegram_user_id]['shift_report']['food_waste'] = food_waste
                self.user_context[telegram_user_id]['shift_report_step'] = 5
                self.user_context[telegram_user_id]['awaiting_inventory_issues'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                step_template = get_shift_report_input_template(lang, 5, department)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ Food Waste: {food_waste[:50]}{'...' if len(food_waste) > 50 else ''}\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== RESTAURANT SHIFT REPORT: Inventory Issues (Step 5) ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_inventory_issues'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_inventory_issues'] = False
                lang = get_user_language(telegram_user_id, self.db)
                department = self.user_context[telegram_user_id].get('shift_report_department', 'Restaurant')
                
                inventory_issues = text.strip()
                if inventory_issues.lower() in ['none', 'no', 'n/a', 'nema', 'ok']:
                    inventory_issues = 'None reported'
                
                self.user_context[telegram_user_id]['shift_report']['inventory_issues'] = inventory_issues
                self.user_context[telegram_user_id]['shift_report_step'] = 6
                self.user_context[telegram_user_id]['awaiting_equipment_issues'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                step_template = get_shift_report_input_template(lang, 6, department)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ Inventory Issues: {inventory_issues[:50]}{'...' if len(inventory_issues) > 50 else ''}\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== RESTAURANT SHIFT REPORT: Equipment Issues (Step 6) ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_equipment_issues'):
                from templates import get_shift_report_input_template
                self.user_context[telegram_user_id]['awaiting_equipment_issues'] = False
                lang = get_user_language(telegram_user_id, self.db)
                department = self.user_context[telegram_user_id].get('shift_report_department', 'Restaurant')
                
                equipment_issues = text.strip()
                if equipment_issues.lower() in ['none', 'no', 'n/a', 'nema', 'ok']:
                    equipment_issues = 'None reported'
                
                self.user_context[telegram_user_id]['shift_report']['equipment_issues'] = equipment_issues
                self.user_context[telegram_user_id]['shift_report_step'] = 7
                self.user_context[telegram_user_id]['awaiting_restaurant_notes'] = True
                
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                step_template = get_shift_report_input_template(lang, 7, department)
                
                await update.message.reply_text(
                    f"📋 {get_text('shift_report_required', lang)} - {get_text('shift_number', lang)} {shift_num}\n\n"
                    f"✅ Equipment Issues: {equipment_issues[:50]}{'...' if len(equipment_issues) > 50 else ''}\n\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    f"{step_template['title']}\n"
                    f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    f"{step_template['prompt']}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('cancel', lang)}", callback_data="reception_home")
                    ]])
                )
                return
            
            # ========== RESTAURANT SHIFT REPORT: Additional Notes (Step 7 - Final) ==========
            if self.user_context.get(telegram_user_id, {}).get('awaiting_restaurant_notes'):
                from database import create_shift_report
                self.user_context[telegram_user_id]['awaiting_restaurant_notes'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                notes = text.strip()
                if notes.lower() in ['none', 'no', 'n/a', 'nema', 'ok']:
                    notes = 'None'
                
                self.user_context[telegram_user_id]['shift_report']['notes'] = notes
                
                # Get employee info
                employee = self.db.check_employee_exists(telegram_user_id)
                if not employee:
                    await update.message.reply_text(get_text('error_occurred', lang))
                    return
                
                employee_id, name, department, work_role, gmail, whatsapp = employee
                shift_num = self.user_context[telegram_user_id].get('reporting_shift', 1)
                report_data = self.user_context[telegram_user_id]['shift_report']
                
                # Calculate total sales
                total_sales = report_data.get('cash_sales', 0) + report_data.get('card_sales', 0)
                
                # Save to database
                try:
                    from datetime import date
                    report_id = self.db.create_shift_report(
                        shift_date=date.today().isoformat(),
                        shift_number=shift_num,
                        employee_id=employee_id,
                        reservations_count=0,
                        arrivals_count=report_data.get('guests_served', 0),
                        cash_amount=report_data.get('cash_sales', 0),
                        cash_photo='',
                        pos_report_photo='',
                        store_stock_notes=f"Card Sales: {report_data.get('card_sales', 0):,.0f}",
                        restaurant_cash_confirmed=True,
                        key_log_notes=f"Food Waste: {report_data.get('food_waste', 'None')}\nInventory: {report_data.get('inventory_issues', 'None')}\nEquipment: {report_data.get('equipment_issues', 'None')}\nNotes: {notes}",
                        tool_log_notes=''
                    )
                    
                    # Mark task as completed if task_id exists
                    task_id = self.user_context[telegram_user_id].get('shift_report_task_id')
                    if task_id:
                        from database import complete_task
                        complete_task(self.db, task_id, 'tbl_tasks', telegram_user_id, name)
                    
                    await update.message.reply_text(
                        f"✅ {get_text('shift_report_submitted', lang if 'shift_report_submitted' in TRANSLATIONS.get(lang, {}) else 'en')}\n\n"
                        f"📋 Report ID: {report_id}\n"
                        f"👤 {name}\n"
                        f"🏢 Department: Restaurant\n"
                        f"🕐 Shift {shift_num}\n\n"
                        f"━━━━━━━━━━━━━━━━━━━━━━\n"
                        f"📊 Summary:\n"
                        f"• Guests Served: {report_data.get('guests_served', 0)}\n"
                        f"• Cash Sales: {report_data.get('cash_sales', 0):,.0f}\n"
                        f"• Card Sales: {report_data.get('card_sales', 0):,.0f}\n"
                        f"• Total Sales: {total_sales:,.0f}\n"
                        f"• Food Waste: {report_data.get('food_waste', 'None')[:50]}\n"
                        f"• Inventory Issues: {report_data.get('inventory_issues', 'None')[:50]}\n"
                        f"• Equipment Issues: {report_data.get('equipment_issues', 'None')[:50]}\n"
                        f"• Notes: {notes[:50]}\n"
                        f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                        f"Thank you for completing your shift report! 🎉"
                    )
                    
                    # Clean up context
                    self.user_context[telegram_user_id].pop('shift_report', None)
                    self.user_context[telegram_user_id].pop('shift_report_step', None)
                    self.user_context[telegram_user_id].pop('reporting_shift', None)
                    self.user_context[telegram_user_id].pop('shift_report_task_id', None)
                    self.user_context[telegram_user_id].pop('shift_report_department', None)
                    
                except Exception as e:
                    print(f"❌ Error saving restaurant shift report: {e}")
                    await update.message.reply_text(
                        f"❌ Error saving report. Please try again or contact management.\n\nError: {str(e)}"
                    )
                return
            
            # ========== CONTACT INFO: Gmail Input ==========
            if context.user_data.get('awaiting_gmail'):
                context.user_data['awaiting_gmail'] = False
                lang = get_user_language(telegram_user_id, self.db)
                gmail = text.strip().lower()
                
                # Validate Gmail format
                import re
                email_pattern = r'^[a-zA-Z0-9._%+-]+@gmail\.com$'
                if not gmail or not re.match(email_pattern, gmail):
                    await update.message.reply_text(
                        get_text('invalid_email_format', lang),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="emp_settings_contact" if not self.db.check_admin(telegram_user_id) else "settings_contact")
                        ]])
                    )
                    return
                
                # Check if Gmail already exists
                if self.db.check_gmail_exists(gmail, telegram_user_id):
                    await update.message.reply_text(
                        get_text('gmail_exists_error', lang),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="emp_settings_contact" if not self.db.check_admin(telegram_user_id) else "settings_contact")
                        ]])
                    )
                    return
                
                # Update Gmail in database
                if self.db.update_employee_gmail(telegram_user_id, gmail):
                    await update.message.reply_text(
                        get_text('gmail_updated', lang),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="emp_profile")
                        ]])
                    )
                else:
                    await update.message.reply_text("❌ Error updating Gmail")
                return
            
            # ========== CONTACT INFO: WhatsApp Input ==========
            if context.user_data.get('awaiting_whatsapp'):
                context.user_data['awaiting_whatsapp'] = False
                lang = get_user_language(telegram_user_id, self.db)
                whatsapp = text.strip()
                
                # Validate WhatsApp format (should start with + and contain 10-15 digits)
                import re
                phone_pattern = r'^\+\d{10,15}$'
                if not whatsapp or not re.match(phone_pattern, whatsapp):
                    await update.message.reply_text(
                        get_text('invalid_phone_format', lang),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="emp_settings_contact" if not self.db.check_admin(telegram_user_id) else "settings_contact")
                        ]])
                    )
                    return
                
                # Check if WhatsApp already exists
                if self.db.check_whatsapp_exists(whatsapp, telegram_user_id):
                    await update.message.reply_text(
                        get_text('whatsapp_exists_error', lang),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="emp_settings_contact" if not self.db.check_admin(telegram_user_id) else "settings_contact")
                        ]])
                    )
                    return
                
                # Update WhatsApp in database
                if self.db.update_employee_whatsapp(telegram_user_id, whatsapp):
                    await update.message.reply_text(
                        get_text('whatsapp_updated', lang),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="emp_profile")
                        ]])
                    )
                else:
                    await update.message.reply_text("❌ Error updating WhatsApp")
                return
            
            # ========== FINANCE: Amount Input ==========
            if context.user_data.get('awaiting_finance_amount'):
                context.user_data['awaiting_finance_amount'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                try:
                    amount = float(text.strip().replace(',', '.'))
                    if amount <= 0:
                        raise ValueError("Amount must be positive")
                    
                    context.user_data['finance_amount'] = amount
                    context.user_data['awaiting_finance_description'] = True
                    
                    tx_type = context.user_data.get('finance_tx_type', 'expense')
                    category = context.user_data.get('finance_category', 'other')
                    
                    await update.message.reply_text(
                        f"📝 {get_text('record_transaction', lang)}\n\n"
                        f"📌 {get_text('finance_type_label', lang)}: {get_text(f'finance_type_{tx_type}', lang)}\n"
                        f"📁 {get_text('finance_category_label', lang)}: {get_text(f'finance_cat_{category}', lang)}\n"
                        f"💰 {get_text('finance_amount_label', lang)}: {amount:,.2f} RSD\n\n"
                        f"📝 {get_text('finance_enter_description', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('finance_cancel', lang), callback_data="emp_work_finance")
                        ]])
                    )
                except ValueError:
                    await update.message.reply_text(
                        f"❌ {get_text('finance_invalid_amount', lang)}\n\n"
                        f"💰 {get_text('finance_enter_amount', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('finance_cancel', lang), callback_data="emp_work_finance")
                        ]])
                    )
                    context.user_data['awaiting_finance_amount'] = True
                return
            
            # ========== FINANCE: Description Input ==========
            if context.user_data.get('awaiting_finance_description'):
                context.user_data['awaiting_finance_description'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                description = text.strip()
                if len(description) < 3:
                    await update.message.reply_text(
                        "❌ Opis mora imati najmanje 3 karaktera.\n\n"
                        f"📝 {get_text('finance_enter_description', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('finance_cancel', lang), callback_data="emp_work_finance")
                        ]])
                    )
                    context.user_data['awaiting_finance_description'] = True
                    return
                
                context.user_data['finance_description'] = description
                
                # Show payment method selection
                tx_type = context.user_data.get('finance_tx_type', 'expense')
                category = context.user_data.get('finance_category', 'other')
                amount = context.user_data.get('finance_amount', 0)
                
                await update.message.reply_text(
                    f"📝 {get_text('record_transaction', lang)}\n\n"
                    f"📌 {get_text('finance_type_label', lang)}: {get_text(f'finance_type_{tx_type}', lang)}\n"
                    f"📁 {get_text('finance_category_label', lang)}: {get_text(f'finance_cat_{category}', lang)}\n"
                    f"💰 {get_text('finance_amount_label', lang)}: {amount:,.2f} RSD\n"
                    f"📝 {get_text('finance_description_label', lang)}: {description}\n\n"
                    f"{get_text('finance_select_payment', lang)}",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("💵 Gotovina", callback_data="finance_pay_cash")],
                        [InlineKeyboardButton("💳 Kartica", callback_data="finance_pay_card")],
                        [InlineKeyboardButton("🏦 Banka", callback_data="finance_pay_bank")],
                        [InlineKeyboardButton(get_text('finance_cancel', lang), callback_data="emp_work_finance")]
                    ])
                )
                return
            
            # ========== WHATSAPP MESSAGE INPUT ==========
            if context.user_data.get('awaiting_whatsapp_message'):
                context.user_data['awaiting_whatsapp_message'] = False
                lang = get_user_language(telegram_user_id, self.db)
                whatsapp_message = text.strip()
                
                if len(whatsapp_message) < 5:
                    await update.message.reply_text(
                        "❌ Message too short. Please enter at least 5 characters.",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton("🔙 Back", callback_data="message_management")
                        ]])
                    )
                    context.user_data['awaiting_whatsapp_message'] = True
                    return
                
                # Get selected employees
                selected_emp_ids = context.user_data.get('whatsapp_selected', [])
                if not selected_emp_ids:
                    await update.message.reply_text("❌ No employees selected")
                    return
                
                # Get department name
                dept_name = context.user_data.get('whatsapp_department', 'Unknown')
                
                # Analyze message with AI and generate WhatsApp template
                try:
                    from email_ai_analyzer import get_email_analyzer
                    
                    await update.message.reply_text("🤖 AI is analyzing your message and generating WhatsApp template...")
                    
                    # Get administrator information
                    admin_info = self.db.get_employee_info(telegram_user_id)
                    sender_info = {
                        'name': admin_info.get('name', 'Hotel Manager') if admin_info else 'Hotel Manager',
                        'phone': admin_info.get('whatsapp', 'N/A') if admin_info else 'N/A',
                        'hotel_name': 'Grand Hotel'  # You can make this configurable
                    }
                    
                    analyzer = get_email_analyzer()
                    if analyzer:
                        ai_result = await analyzer.analyze_and_generate_whatsapp_async(
                            user_input=whatsapp_message,
                            department=dept_name,
                            recipient_count=len(selected_emp_ids),
                            sender_info=sender_info
                        )
                        
                        # Show preview to admin
                        preview_text = f"📱 **WhatsApp Message Preview** (AI Generated)\n\n"
                        preview_text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                        preview_text += f"**Category:** {ai_result.get('category', 'N/A').title()}\n"
                        preview_text += f"**Tone:** {ai_result.get('tone', 'N/A').title()}\n\n"
                        preview_text += f"**Summary:** {ai_result['summary']}\n\n"
                        preview_text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                        preview_text += f"**Message Preview:**\n{ai_result.get('message', '')[:500]}"
                        if len(ai_result.get('message', '')) > 500:
                            preview_text += "...\n\n(Preview truncated)"
                        else:
                            preview_text += "\n\n"
                        preview_text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                        preview_text += f"👤 From: {sender_info['name']}\n"
                        preview_text += f"🏢 Department: {dept_name}\n"
                        preview_text += f"👥 Recipients: {len(selected_emp_ids)} employee(s)\n\n"
                        preview_text += f"Do you want to send this WhatsApp message?"
                        
                        # Store AI-generated content
                        context.user_data['whatsapp_ai_message'] = ai_result.get('message', '')
                        context.user_data['whatsapp_original_input'] = whatsapp_message
                        
                        keyboard = [
                            [InlineKeyboardButton("✅ Confirm & Send", callback_data="whatsapp_ai_confirm")],
                            [InlineKeyboardButton("✏️ Edit & Retry", callback_data="whatsapp_ai_retry")],
                            [InlineKeyboardButton("❌ Cancel", callback_data="message_management")]
                        ]
                        
                        await update.message.reply_text(
                            preview_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='Markdown'
                        )
                        return
                    else:
                        # Fallback if AI not available
                        await update.message.reply_text("⚠️ AI analyzer not available. Sending direct message...")
                        
                except Exception as e:
                    import traceback
                    error_details = traceback.format_exc()
                    print(f"❌ AI analysis error: {e}")
                    print(f"Traceback:\n{error_details}")
                    await update.message.reply_text(f"⚠️ AI analysis failed: {str(e)}\n\nSending direct message...")
                
                # Fallback: Send direct message without AI
                await update.message.reply_text("📱 Sending WhatsApp messages...")
                
                # Get WhatsApp service
                try:
                    from whatsapp_service import get_whatsapp_service
                    from database import log_whatsapp_message, get_employees_with_whatsapp
                    
                    whatsapp_service = get_whatsapp_service()
                    
                    # Get employees with WhatsApp from selected department
                    all_whatsapp_employees = get_employees_with_whatsapp(self.db, dept_name)
                    
                    # Filter to only selected employees
                    recipients = []
                    for emp in all_whatsapp_employees:
                        if emp['employee_id'] in selected_emp_ids:
                            recipients.append({
                                'name': emp['name'],
                                'whatsapp': emp['whatsapp']
                            })
                    
                    if not recipients:
                        await update.message.reply_text("❌ No valid WhatsApp numbers found for selected employees")
                        return
                    
                    # Send bulk messages
                    result = whatsapp_service.send_bulk_messages(recipients, whatsapp_message)
                    
                    # Log each message
                    for detail in result.get('details', []):
                        log_whatsapp_message(
                            self.db,
                            recipient=detail.get('whatsapp', 'Unknown'),
                            recipient_name=detail.get('name', 'Unknown'),
                            message_body=whatsapp_message,
                            status='sent' if detail.get('success') else 'failed',
                            message_sid=detail.get('message_sid'),
                            error_message=detail.get('error')
                        )
                    
                    # Clear selection
                    context.user_data.pop('whatsapp_selected', None)
                    context.user_data.pop('whatsapp_department', None)
                    
                    # Format result
                    result_text = f"📱 <b>WhatsApp Messages Sent</b>\n\n"
                    result_text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                    result_text += f"🏢 Department: <b>{dept_name}</b>\n"
                    result_text += f"📊 Total: {result['total']}\n"
                    result_text += f"✅ Success: {result['success']}\n"
                    result_text += f"❌ Failed: {result['failed']}\n"
                    result_text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    
                    if result['success'] > 0:
                        result_text += "✅ <b>Successfully sent to:</b>\n"
                        for detail in result['details']:
                            if detail.get('success'):
                                result_text += f"  • {detail['name']} ({detail['whatsapp']})\n"
                        result_text += "\n"
                    
                    if result['failed'] > 0:
                        result_text += "❌ <b>Failed to send to:</b>\n"
                        for detail in result['details']:
                            if not detail.get('success'):
                                error_msg = detail.get('error', 'Unknown error')[:50]
                                result_text += f"  • {detail['name']}: {error_msg}\n"
                    
                    await update.message.reply_text(
                        result_text,
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton("🔙 Back to Message Management", callback_data="message_management")
                        ]]),
                        parse_mode="HTML"
                    )
                    return
                    
                except Exception as e:
                    import traceback
                    error_details = traceback.format_exc()
                    print(f"❌ WhatsApp sending error: {e}")
                    print(f"Traceback:\n{error_details}")
                    
                    await update.message.reply_text(
                        f"❌ Failed to send WhatsApp messages:\n{str(e)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton("🔙 Back", callback_data="message_management")
                        ]])
                    )
                    return
            
            # ========== EMAIL MESSAGE INPUT ==========
            if context.user_data.get('awaiting_email_message'):
                context.user_data['awaiting_email_message'] = False
                lang = get_user_language(telegram_user_id, self.db)
                email_message = text.strip()
                
                if len(email_message) < 10:
                    await update.message.reply_text(
                        "❌ Message too short. Please enter at least 10 characters.",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton("🔙 Back", callback_data="mail_management")
                        ]])
                    )
                    context.user_data['awaiting_email_message'] = True
                    return
                
                # Get selected employees
                selected_emp_ids = context.user_data.get('email_selected', [])
                if not selected_emp_ids:
                    await update.message.reply_text("❌ No employees selected")
                    return
                
                # Get department name
                dept_name = context.user_data.get('email_department', 'Unknown')
                
                # Analyze message with AI and generate email template
                try:
                    from email_ai_analyzer import get_email_analyzer
                    
                    await update.message.reply_text("🤖 AI is analyzing your message and generating email template...")
                    
                    # Get administrator information
                    admin_info = self.db.get_employee_info(telegram_user_id)
                    sender_info = {
                        'name': admin_info.get('name', 'Hotel Manager') if admin_info else 'Hotel Manager',
                        'email': admin_info.get('gmail', 'manager@hotel.com') if admin_info else 'manager@hotel.com',
                        'phone': admin_info.get('whatsapp', 'N/A') if admin_info else 'N/A',
                        'hotel_name': 'Grand Hotel'  # You can make this configurable
                    }
                    
                    analyzer = get_email_analyzer()
                    if analyzer:
                        ai_result = await analyzer.analyze_and_generate_email_async(
                            user_input=email_message,
                            department=dept_name,
                            recipient_count=len(selected_emp_ids),
                            sender_info=sender_info
                        )
                        
                        # Show preview to admin
                        preview_text = f"📧 **Email Preview** (AI Generated)\n\n"
                        preview_text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                        preview_text += f"**Subject:** {ai_result['subject']}\n\n"
                        preview_text += f"**Category:** {ai_result.get('category', 'N/A').title()}\n"
                        preview_text += f"**Tone:** {ai_result.get('tone', 'N/A').title()}\n\n"
                        preview_text += f"**Summary:** {ai_result['summary']}\n\n"
                        preview_text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                        preview_text += f"**Email Body Preview:**\n{ai_result.get('body_html', ai_result.get('body', ''))[:400]}"
                        if len(ai_result.get('body_html', ai_result.get('body', ''))) > 400:
                            preview_text += "...\n\n(Preview truncated)"
                        else:
                            preview_text += "\n\n"
                        preview_text += f"━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                        preview_text += f"👤 From: {sender_info['name']}\n"
                        preview_text += f"🏢 Department: {dept_name}\n"
                        preview_text += f"👥 Recipients: {len(selected_emp_ids)} employee(s)\n\n"
                        preview_text += f"Do you want to send this email?"
                        
                        # Store AI-generated content (including HTML version)
                        context.user_data['email_ai_subject'] = ai_result['subject']
                        context.user_data['email_ai_body'] = ai_result.get('body', '')
                        context.user_data['email_ai_body_html'] = ai_result.get('body_html', ai_result.get('body', ''))
                        context.user_data['email_original_input'] = email_message
                        
                        keyboard = [
                            [InlineKeyboardButton("✅ Confirm & Send", callback_data="email_ai_confirm")],
                            [InlineKeyboardButton("✏️ Edit & Retry", callback_data="email_ai_retry")],
                            [InlineKeyboardButton("❌ Cancel", callback_data="message_management")]
                        ]
                        
                        await update.message.reply_text(
                            preview_text,
                            reply_markup=InlineKeyboardMarkup(keyboard),
                            parse_mode='Markdown'
                        )
                        return
                    else:
                        # Fallback if AI not available
                        await update.message.reply_text("⚠️ AI analyzer not available. Sending direct message...")
                        
                except Exception as e:
                    import traceback
                    error_details = traceback.format_exc()
                    print(f"❌ AI analysis error: {e}")
                    print(f"Traceback:\n{error_details}")
                    await update.message.reply_text(f"⚠️ AI analysis failed: {str(e)}\n\nSending direct message...")
                
                # Fallback: Send direct message without AI
                result = self.notification_manager.send_bulk_email(
                    selected_emp_ids,
                    "📧 Message from Hotel Management",
                    email_message
                )
                
                # Clear selection
                context.user_data.pop('email_selected', None)
                context.user_data.pop('email_department', None)
                
                # Format result using notification manager
                result_text = self.notification_manager.format_email_result_text(result)
                
                await update.message.reply_text(
                    result_text,
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton("🔙 Back to Message Management", callback_data="message_management")
                    ]])
                )
                return
            
            # ========== KEY MANAGEMENT: Purpose Input ==========
            # Key taking - purpose input
            if context.user_data.get('awaiting_key_purpose'):
                context.user_data['awaiting_key_purpose'] = False
                lang = get_user_language(telegram_user_id, self.db)
                purpose = text.strip()
                
                if not purpose:
                    await update.message.reply_text(
                        f"❌ {get_text('purpose_cannot_be_empty', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_keys")
                        ]])
                    )
                    context.user_data['awaiting_key_purpose'] = True
                    return
                
                # Store purpose and ask for proof
                context.user_data['key_purpose'] = purpose
                
                await update.message.reply_text(
                    f"📝 {get_text('purpose', lang)}: {purpose}\n\n"
                    f"📸 {get_text('add_proof_question', lang)}\n\n"
                    f"• {get_text('send_proof_photo_video', lang)}\n"
                    f"• {get_text('skip_proof', lang)}",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(f"⏭️ {get_text('skip_proof', lang)}", callback_data="key_skip_proof")],
                        [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_keys")]
                    ])
                )
                context.user_data['awaiting_key_proof'] = True
                return
            
            # ========== TASK REPORT: Notes Input ==========
            if context.user_data.get('task_report', {}).get('step') == 'notes':
                lang = get_user_language(telegram_user_id, self.db)
                notes = text.strip() if text else ""
                
                if not notes:
                    cancel_text = get_text('cancel', lang)
                    empty_report_text = get_text('report_cannot_be_empty', lang)
                    await update.message.reply_text(
                        f"❌ {empty_report_text}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(cancel_text, callback_data="emp_report_task")
                        ]])
                    )
                    return
                
                context.user_data['task_report']['notes'] = notes
                context.user_data['task_report']['step'] = 'attachment'
                context.user_data['awaiting_report_attachment'] = True
                
                task_id = context.user_data['task_report'].get('task_id')
                
                your_report_text = get_text('your_report', lang)
                text_msg = f"{get_text('task_report_title', lang)}\n\n"
                text_msg += f"📄 {your_report_text}:\n{notes}\n\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text_msg += f"📎 {get_text('attach_document', lang)}\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text_msg += get_text('send_photo_or_document', lang) + "\n"
                text_msg += get_text('or_press_skip', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('skip_attachment', lang), callback_data="report_skip_attachment")],
                    [InlineKeyboardButton(get_text('cancel', lang), callback_data="emp_report_task")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # ========== RESTAURANT REPORT: Notes Input ==========
            if context.user_data.get('restaurant_report', {}).get('step') == 'notes':
                task_id = context.user_data['restaurant_report']['task_id']
                notes = text.strip() if text else ""
                
                context.user_data['restaurant_report']['notes'] = notes
                context.user_data['restaurant_report']['step'] = 'media'
                context.user_data['awaiting_restaurant_report_media'] = task_id
                
                from database import get_restaurant_task_by_id
                task = get_restaurant_task_by_id(self.db, task_id)
                
                your_report_text = get_text('your_report', lang)
                text_msg = f"{get_text('task_report_title', lang)} #{task_id}\n\n"
                if notes:
                    notes_short = notes[:50] + '...' if len(notes) > 50 else notes
                    text_msg += f"📋 {your_report_text}: {notes_short}\n\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text_msg += f"{get_text('task_report_step_media', lang)}\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text_msg += get_text('attach_proof_text', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('finish_without_proof', lang), callback_data=f"rest_finish_nophoto_{task_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"rest_task_{task_id}")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # ========== LAUNDRY REPORT: Notes Input ==========
            if context.user_data.get('laundry_report', {}).get('step') == 'notes':
                task_id = context.user_data['laundry_report']['task_id']
                notes = text.strip() if text else ""
                
                context.user_data['laundry_report']['notes'] = notes
                context.user_data['laundry_report']['step'] = 'media'
                context.user_data['awaiting_laundry_report_media'] = task_id
                
                from database import get_laundry_task_by_id
                task = get_laundry_task_by_id(self.db, task_id)
                
                your_report_text = get_text('your_report', lang)
                text_msg = f"{get_text('task_report_title_laundry', lang)} #{task_id}\n\n"
                if notes:
                    notes_short = notes[:50] + '...' if len(notes) > 50 else notes
                    text_msg += f"📋 {your_report_text}: {notes_short}\n\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text_msg += f"{get_text('task_report_step_media', lang)}\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text_msg += get_text('attach_proof_text', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('finish_without_proof', lang), callback_data=f"laundry_finish_nophoto_{task_id}")],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data=f"laundry_task_{task_id}")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # ========== RESTAURANT ASSIGNMENT: Input Handlers ==========
            # Restaurant - description input
            if context.user_data.get('restaurant_assign', {}).get('step') == 'description':
                lang = get_user_language(telegram_user_id, self.db)
                description = text.strip()
                
                if not description:
                    await update.message.reply_text(
                        get_text('description_empty', lang),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_kitchen")
                        ]])
                    )
                    return
                
                context.user_data['restaurant_assign']['description'] = description
                context.user_data['restaurant_assign']['step'] = 'deadline'
                
                assignee_name = context.user_data['restaurant_assign'].get('assignee_name', 'Unknown')
                
                text_msg = f"{get_text('assign_kitchen', lang)}\n\n"
                text_msg += f"{get_text('worker_label', lang)}: {assignee_name}\n"
                text_msg += f"📝 {get_text('task_order', lang)}:\n{description}\n\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text_msg += f"{get_text('step_deadline', lang)}\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text_msg += get_text('select_deadline', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(get_text('deadline_1h', lang), callback_data="rest_deadline_1"),
                        InlineKeyboardButton(get_text('deadline_2h', lang), callback_data="rest_deadline_2"),
                        InlineKeyboardButton(get_text('deadline_3h', lang), callback_data="rest_deadline_3")
                    ],
                    [
                        InlineKeyboardButton(get_text('deadline_6h', lang), callback_data="rest_deadline_6"),
                        InlineKeyboardButton(get_text('deadline_12h', lang), callback_data="rest_deadline_12"),
                        InlineKeyboardButton(get_text('deadline_24h', lang), callback_data="rest_deadline_24")
                    ],
                    [
                        InlineKeyboardButton(get_text('deadline_48h', lang), callback_data="rest_deadline_48"),
                        InlineKeyboardButton(get_text('deadline_72h', lang), callback_data="rest_deadline_72")
                    ],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_assign_kitchen")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # ========== DRIVER ASSIGNMENT: Input Handlers ==========
            # Driver - description input
            if context.user_data.get('driver_assign', {}).get('step') == 'description':
                description = text.strip()
                
                if not description:
                    await update.message.reply_text(
                        get_text('description_empty', lang),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_driver")
                        ]])
                    )
                    return
                
                context.user_data['driver_assign']['description'] = description
                context.user_data['driver_assign']['step'] = 'deadline'
                
                assignee_name = context.user_data['driver_assign'].get('assignee_name', 'Unknown')
                
                text_msg = f"{get_text('assign_driver', lang)}\n\n"
                text_msg += f"{get_text('driver_label', lang)}: {assignee_name}\n"
                text_msg += f"📝 {get_text('task_order', lang)}:\n{description}\n\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text_msg += f"{get_text('step_deadline', lang)}\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text_msg += get_text('select_deadline', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(get_text('deadline_1h', lang), callback_data="driver_deadline_1"),
                        InlineKeyboardButton(get_text('deadline_2h', lang), callback_data="driver_deadline_2"),
                        InlineKeyboardButton(get_text('deadline_3h', lang), callback_data="driver_deadline_3")
                    ],
                    [
                        InlineKeyboardButton(get_text('deadline_6h', lang), callback_data="driver_deadline_6"),
                        InlineKeyboardButton(get_text('deadline_12h', lang), callback_data="driver_deadline_12"),
                        InlineKeyboardButton(get_text('deadline_24h', lang), callback_data="driver_deadline_24")
                    ],
                    [
                        InlineKeyboardButton(get_text('deadline_48h', lang), callback_data="driver_deadline_48"),
                        InlineKeyboardButton(get_text('deadline_72h', lang), callback_data="driver_deadline_72")
                    ],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_assign_driver")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # ========== DRIVER REPORT: Notes Input ==========
            if context.user_data.get('driver_report', {}).get('step') == 'notes':
                task_id = context.user_data['driver_report']['task_id']
                notes = text.strip() if text else ""
                
                context.user_data['driver_report']['notes'] = notes
                context.user_data['driver_report']['step'] = 'media'
                context.user_data['awaiting_driver_report_media'] = task_id
                
                from database import get_delivery_task_by_id
                task = get_delivery_task_by_id(self.db, task_id)
                
                your_report_text = get_text('your_report', lang)
                text_msg = f"{get_text('task_report_title', lang)} #{task_id}\n\n"
                if notes:
                    notes_short = notes[:50] + '...' if len(notes) > 50 else notes
                    text_msg += f"📋 {your_report_text}: {notes_short}\n\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text_msg += f"{get_text('task_report_step_media', lang)}\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text_msg += get_text('attach_proof_text', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('finish_without_proof', lang), callback_data=f"driver_finish_nophoto_{task_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"driver_task_{task_id}")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # ========== ACCOUNTING ASSIGNMENT: Input Handlers ==========
            # Accounting - description input
            if context.user_data.get('accounting_assign', {}).get('step') == 'description':
                description = text.strip()
                
                if not description:
                    await update.message.reply_text(
                        "❌ Opis ne može biti prazan. Pokušajte ponovo:",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_accounting")
                        ]])
                    )
                    return
                
                context.user_data['accounting_assign']['description'] = description
                context.user_data['accounting_assign']['step'] = 'deadline'
                
                assignee_name = context.user_data['accounting_assign'].get('assignee_name', 'Unknown')
                
                text_msg = f"💰 Dodela računovodstva\n\n"
                text_msg += f"👤 Radnik: {assignee_name}\n"
                text_msg += f"📝 Zadatak:\n{description}\n\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text_msg += "📍 Korak 3/4: Izaberite rok\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text_msg += "⏰ Izaberite rok završetka:"
                
                keyboard = [
                    [
                        InlineKeyboardButton("1 sat", callback_data="acct_deadline_1"),
                        InlineKeyboardButton("2 sata", callback_data="acct_deadline_2"),
                        InlineKeyboardButton("3 sata", callback_data="acct_deadline_3")
                    ],
                    [
                        InlineKeyboardButton("6 sati", callback_data="acct_deadline_6"),
                        InlineKeyboardButton("12 sati", callback_data="acct_deadline_12"),
                        InlineKeyboardButton("24 sata", callback_data="acct_deadline_24")
                    ],
                    [
                        InlineKeyboardButton("48 sati", callback_data="acct_deadline_48"),
                        InlineKeyboardButton("72 sata", callback_data="acct_deadline_72")
                    ],
                    [InlineKeyboardButton("🔙 Nazad", callback_data="emp_assign_accounting")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # ========== ACCOUNTING REPORT: Notes Input ==========
            if context.user_data.get('accounting_report', {}).get('step') == 'notes':
                task_id = context.user_data['accounting_report']['task_id']
                notes = text.strip() if text else ""
                
                context.user_data['accounting_report']['notes'] = notes
                context.user_data['accounting_report']['step'] = 'media'
                context.user_data['awaiting_accounting_report_media'] = task_id
                
                from database import get_accounting_task_by_id
                task = get_accounting_task_by_id(self.db, task_id)
                
                your_report_text = get_text('your_report', lang)
                text_msg = f"{get_text('task_report_title', lang)} #{task_id}\n\n"
                if notes:
                    notes_short = notes[:50] + '...' if len(notes) > 50 else notes
                    text_msg += f"📋 {your_report_text}: {notes_short}\n\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text_msg += f"{get_text('task_report_step_media', lang)}\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text_msg += get_text('attach_proof_text', lang)
                
                keyboard = [
                    [InlineKeyboardButton(get_text('finish_without_proof', lang), callback_data=f"acct_finish_nophoto_{task_id}")],
                    [InlineKeyboardButton(get_text('back', lang), callback_data=f"acct_task_{task_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # ========== REPAIR ASSIGNMENT: Input Handlers ==========
            # Repair - description input
            if context.user_data.get('repair_assign', {}).get('step') == 'description':
                lang = get_user_language(update.message.from_user.id, self.db)
                description = text.strip()
                
                if not description:
                    await update.message.reply_text(
                        f"❌ {get_text('description_empty', lang)}. {get_text('try_again', lang)}:",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_repair")
                        ]])
                    )
                    return
                
                context.user_data['repair_assign']['description'] = description
                context.user_data['repair_assign']['step'] = 'deadline'
                
                assignee_name = context.user_data['repair_assign'].get('assignee_name', 'Unknown')
                room_number = context.user_data['repair_assign'].get('room_number', 'Unknown')
                repair_type = context.user_data['repair_assign'].get('repair_type', 'Unknown')
                priority = context.user_data['repair_assign'].get('priority', 'Normal')
                
                priority_labels = {
                    'Urgent': get_text('priority_urgent', lang),
                    'High': get_text('priority_high', lang),
                    'Normal': get_text('priority_normal', lang)
                }
                type_labels = {
                    'Electrical': get_text('repair_type_electrical', lang),
                    'Plumbing': get_text('repair_type_plumbing', lang),
                    'HVAC': get_text('repair_type_hvac', lang),
                    'Furniture': get_text('repair_type_furniture', lang),
                    'Electronics': get_text('repair_type_electronics', lang),
                    'Other': get_text('repair_type_other', lang)
                }
                
                text_msg = f"{get_text('assign_repair_title', lang)}\n\n"
                text_msg += f"👤 {get_text('technician', lang)}: {assignee_name}\n"
                text_msg += f"🚪 {get_text('room', lang)}: {room_number}\n"
                text_msg += f"📋 {get_text('type', lang)}: {type_labels.get(repair_type, repair_type)}\n"
                text_msg += f"⚠️ {get_text('priority', lang)}: {priority_labels.get(priority, priority)}\n"
                text_msg += f"📝 {get_text('description', lang)}:\n{description}\n\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text_msg += f"📍 {get_text('select_deadline', lang)}:\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text_msg += f"⏰ {get_text('select_deadline', lang)}:"
                
                keyboard = [
                    [
                        InlineKeyboardButton(get_text('1_hour', lang), callback_data="repair_deadline_1"),
                        InlineKeyboardButton(get_text('2_hours', lang), callback_data="repair_deadline_2"),
                        InlineKeyboardButton(get_text('3_hours', lang), callback_data="repair_deadline_3")
                    ],
                    [
                        InlineKeyboardButton(get_text('6_hours', lang), callback_data="repair_deadline_6"),
                        InlineKeyboardButton(get_text('12_hours', lang), callback_data="repair_deadline_12"),
                        InlineKeyboardButton(get_text('24_hours', lang), callback_data="repair_deadline_24")
                    ],
                    [
                        InlineKeyboardButton(get_text('48_hours', lang), callback_data="repair_deadline_48"),
                        InlineKeyboardButton(get_text('72_hours', lang), callback_data="repair_deadline_72")
                    ],
                    [InlineKeyboardButton(get_text('back', lang), callback_data="emp_assign_repair")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # ========== REPAIR REPORT: Notes Input ==========
            if context.user_data.get('repair_report', {}).get('step') == 'notes':
                task_id = context.user_data['repair_report']['task_id']
                notes = text.strip() if text else ""
                
                context.user_data['repair_report']['notes'] = notes
                context.user_data['repair_report']['step'] = 'media'
                context.user_data['awaiting_repair_report_media'] = task_id
                
                from database import get_repair_task_by_id
                task = get_repair_task_by_id(self.db, task_id)
                
                text_msg = f"📋 Izveštaj o popravci #{task_id}\n\n"
                if notes:
                    text_msg += f"📋 Vaš izveštaj: {notes[:50]}{'...' if len(notes) > 50 else ''}\n\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text_msg += "📎 Korak 2/2: Priložite dokaz\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text_msg += "📸 Pošaljite fotografiju kao dokaz završene popravke,\n"
                text_msg += "ili pritisnite dugme za završetak bez dokaza:"
                
                keyboard = [
                    [InlineKeyboardButton("✅ Završi bez dokaza", callback_data=f"repair_finish_nophoto_{task_id}")],
                    [InlineKeyboardButton("🔙 Nazad", callback_data=f"repair_task_{task_id}")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # ========== VEHICLE MANAGEMENT: Input Handlers ==========
            # Vehicle - plate number input
            if context.user_data.get('awaiting_vehicle_plate'):
                context.user_data['awaiting_vehicle_plate'] = False
                lang = get_user_language(telegram_user_id, self.db)
                plate = text.strip().upper()
                
                if not plate:
                    await update.message.reply_text(
                        f"❌ {get_text('name_cannot_be_empty', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_transport")
                        ]])
                    )
                    context.user_data['awaiting_vehicle_plate'] = True
                    return
                
                context.user_data['new_vehicle_plate'] = plate
                context.user_data['awaiting_vehicle_name'] = True
                
                await update.message.reply_text(
                    f"🔢 {get_text('plate_number', lang)}: {plate}\n\n📝 {get_text('enter_vehicle_name', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_transport")
                    ]])
                )
                return
            
            # Vehicle - name input
            if context.user_data.get('awaiting_vehicle_name'):
                context.user_data['awaiting_vehicle_name'] = False
                lang = get_user_language(telegram_user_id, self.db)
                name = text.strip()
                
                if not name:
                    await update.message.reply_text(
                        f"❌ {get_text('name_cannot_be_empty', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_transport")
                        ]])
                    )
                    context.user_data['awaiting_vehicle_name'] = True
                    return
                
                context.user_data['new_vehicle_name'] = name
                
                # Show vehicle type selection
                keyboard = [
                    [InlineKeyboardButton("🚗 Car", callback_data="admin_vehicle_type_Car"),
                     InlineKeyboardButton("🚐 Van", callback_data="admin_vehicle_type_Van")],
                    [InlineKeyboardButton("🚚 Truck", callback_data="admin_vehicle_type_Truck"),
                     InlineKeyboardButton("🚌 Bus", callback_data="admin_vehicle_type_Bus")],
                    [InlineKeyboardButton("🏍️ Motorcycle", callback_data="admin_vehicle_type_Motorcycle"),
                     InlineKeyboardButton("🚙 Other", callback_data="admin_vehicle_type_Other")],
                    [InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_transport")]
                ]
                
                await update.message.reply_text(
                    f"🔢 {get_text('plate_number', lang)}: {context.user_data.get('new_vehicle_plate')}\n"
                    f"📝 {get_text('vehicle_name', lang)}: {name}\n\n"
                    f"🚗 {get_text('select_vehicle_type', lang)}:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            # Vehicle - description input
            if context.user_data.get('awaiting_vehicle_desc'):
                context.user_data['awaiting_vehicle_desc'] = False
                lang = get_user_language(telegram_user_id, self.db)
                desc = text.strip()
                if desc == '-':
                    desc = None
                
                from database import create_transportation
                plate = context.user_data.get('new_vehicle_plate')
                name = context.user_data.get('new_vehicle_name')
                vtype = context.user_data.get('new_vehicle_type')
                
                vehicle_id = create_transportation(self.db, plate, name, vtype, desc, telegram_user_id)
                
                if vehicle_id:
                    type_emoji = {'Car': '🚗', 'Van': '🚐', 'Truck': '🚚', 'Bus': '🚌', 'Motorcycle': '🏍️', 'Other': '🚙'}.get(vtype, '🚗')
                    
                    # Show success and redirect to vehicle list
                    from database import get_all_transportations
                    vehicles = get_all_transportations(self.db)
                    
                    text = f"{get_text('vehicle_added', lang)}\n\n"
                    text += f"{type_emoji} {name} | 🔢 {plate}\n\n"
                    text += f"� {get_text('vehicle_list', lang)}\n\n"
                    
                    if vehicles:
                        text += "```\n"
                        text += f"{'ID':<3} {'Plate':<12} {'Name':<12} {'Type':<10}\n"
                        text += "─" * 40 + "\n"
                        for v in vehicles:
                            vplate = (v['plate_number'][:10] + '..') if len(v['plate_number']) > 12 else v['plate_number']
                            vname = (v['name'][:10] + '..') if len(v['name']) > 12 else v['name']
                            vtypev = v['vehicle_type'][:8] if len(v['vehicle_type']) > 10 else v['vehicle_type']
                            text += f"{v['id']:<3} {vplate:<12} {vname:<12} {vtypev:<10}\n"
                        text += "```"
                    
                    keyboard = []
                    row = []
                    for v in vehicles:
                        vtype_emoji = {'Car': '🚗', 'Van': '🚐', 'Truck': '🚚', 'Bus': '🚌', 'Motorcycle': '🏍️', 'Other': '🚙'}.get(v['vehicle_type'], '🚗')
                        row.append(InlineKeyboardButton(
                            f"{vtype_emoji} {v['name']}",
                            callback_data=f"admin_vehicle_detail_{v['id']}"
                        ))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_transport")])
                    
                    await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('error_adding_vehicle', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="admin_transport")
                        ]])
                    )
                
                # Clear data
                context.user_data.pop('new_vehicle_plate', None)
                context.user_data.pop('new_vehicle_name', None)
                context.user_data.pop('new_vehicle_type', None)
                return
            
            # Vehicle - edit plate input
            if context.user_data.get('awaiting_vehicle_edit_plate'):
                context.user_data['awaiting_vehicle_edit_plate'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_plate = text.strip().upper()
                
                if new_plate != '-':
                    context.user_data['vehicle_edit_plate'] = new_plate
                
                context.user_data['awaiting_vehicle_edit_name'] = True
                vehicle_id = context.user_data.get('editing_vehicle_id')
                
                await update.message.reply_text(
                    f"📝 {get_text('enter_vehicle_name', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_vehicle_detail_{vehicle_id}")
                    ]])
                )
                return
            
            # Vehicle - edit name input
            if context.user_data.get('awaiting_vehicle_edit_name'):
                context.user_data['awaiting_vehicle_edit_name'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_name = text.strip()
                
                if new_name != '-':
                    context.user_data['vehicle_edit_name'] = new_name
                
                context.user_data['awaiting_vehicle_edit_desc'] = True
                vehicle_id = context.user_data.get('editing_vehicle_id')
                
                await update.message.reply_text(
                    f"📝 {get_text('enter_vehicle_description', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_vehicle_detail_{vehicle_id}")
                    ]])
                )
                return
            
            # Vehicle - edit description input
            if context.user_data.get('awaiting_vehicle_edit_desc'):
                context.user_data['awaiting_vehicle_edit_desc'] = False
                lang = get_user_language(telegram_user_id, self.db)
                vehicle_id = context.user_data.get('editing_vehicle_id')
                
                new_desc = text.strip() if text.strip() != '-' else None
                
                from database import update_transportation, get_transportation_by_id
                
                new_plate = context.user_data.get('vehicle_edit_plate')
                new_name = context.user_data.get('vehicle_edit_name')
                
                if update_transportation(self.db, vehicle_id, new_plate, new_name, None, new_desc):
                    vehicle = get_transportation_by_id(self.db, vehicle_id)
                    # Show brief success message
                    await update.message.reply_text(
                        f"✅ {get_text('vehicle_updated', lang)}\n\n"
                        f"🚗 {vehicle['name']}\n"
                        f"🔢 {vehicle['plate_number']}\n"
                        f"📋 {vehicle['description'] or get_text('no_description', lang)}"
                    )
                    
                    # Auto navigate to vehicle detail page
                    type_emojis = {'car': '🚗', 'van': '🚐', 'truck': '🚛', 'bus': '🚌', 'motorcycle': '🏍️', 'other': '🚙'}
                    type_emoji = type_emojis.get(vehicle['vehicle_type'], '🚗')
                    
                    detail_text = (
                        f"🚗 <b>{get_text('vehicle_info', lang)}</b>\n\n"
                        f"{type_emoji} <b>{get_text('vehicle_name', lang)}:</b> {vehicle['name']}\n"
                        f"🔢 <b>{get_text('plate_number', lang)}:</b> {vehicle['plate_number']}\n"
                        f"📋 <b>{get_text('vehicle_type', lang)}:</b> {get_text(vehicle['vehicle_type'], lang)}\n"
                        f"📝 <b>{get_text('description', lang)}:</b> {vehicle['description'] or get_text('no_description', lang)}\n"
                        f"📅 <b>{get_text('created_at', lang)}:</b> {vehicle['created_at'][:10] if vehicle['created_at'] else '-'}"
                    )
                    
                    detail_keyboard = [
                        [
                            InlineKeyboardButton(f"✏️ {get_text('edit', lang)}", callback_data=f"admin_vehicle_edit_{vehicle_id}"),
                            InlineKeyboardButton(f"🗑️ {get_text('delete', lang)}", callback_data=f"admin_vehicle_delete_{vehicle_id}")
                        ],
                        [InlineKeyboardButton(f"⬅️ {get_text('back', lang)}", callback_data="admin_vehicle_list")]
                    ]
                    
                    await update.message.reply_text(
                        detail_text,
                        parse_mode='HTML',
                        reply_markup=InlineKeyboardMarkup(detail_keyboard)
                    )
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('error_updating_vehicle', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_vehicle_detail_{vehicle_id}")
                        ]])
                    )
                
                # Clear edit data
                context.user_data.pop('editing_vehicle_id', None)
                context.user_data.pop('vehicle_edit_plate', None)
                context.user_data.pop('vehicle_edit_name', None)
                return
            
            # ========== STORAGE MANAGEMENT: Input Handlers ==========
            # Storage - name input
            if context.user_data.get('awaiting_storage_name'):
                context.user_data['awaiting_storage_name'] = False
                lang = get_user_language(telegram_user_id, self.db)
                name = text.strip()
                
                if not name:
                    await update.message.reply_text(
                        f"❌ {get_text('name_cannot_be_empty', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_storage")
                        ]])
                    )
                    context.user_data['awaiting_storage_name'] = True
                    return
                
                context.user_data['new_storage_name'] = name
                
                # Show storage type selection
                keyboard = [
                    [
                        InlineKeyboardButton("🍎 Food", callback_data="admin_storage_type_Food"),
                        InlineKeyboardButton("🧪 Chemicals", callback_data="admin_storage_type_Chemicals")
                    ],
                    [
                        InlineKeyboardButton("🔧 Tool Room", callback_data="admin_storage_type_ToolRoom"),
                        InlineKeyboardButton("🛒 Shop", callback_data="admin_storage_type_Shop")
                    ],
                    [InlineKeyboardButton("📦 Other", callback_data="admin_storage_type_Other")],
                    [InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_storage")]
                ]
                
                await update.message.reply_text(
                    f"📦 {get_text('add_new_storage', lang)}\n\n"
                    f"📝 {get_text('storage_name', lang)}: {name}\n\n"
                    f"📋 {get_text('select_storage_type', lang)}:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            # Storage - description input
            if context.user_data.get('awaiting_storage_desc'):
                context.user_data['awaiting_storage_desc'] = False
                lang = get_user_language(telegram_user_id, self.db)
                desc = text.strip()
                if desc == '-':
                    desc = None
                
                from database import create_storage, get_all_storages
                name = context.user_data.get('new_storage_name')
                stype = context.user_data.get('new_storage_type')
                
                storage_id = create_storage(self.db, name, stype, desc, telegram_user_id)
                
                if storage_id:
                    type_emojis = {'Food': '🍎', 'Chemicals': '🧪', 'ToolRoom': '🔧', 'Shop': '🛒', 'Other': '📦'}
                    type_emoji = type_emojis.get(stype, '📦')
                    
                    # Show success and redirect to storage list
                    storages = get_all_storages(self.db)
                    
                    text = f"{get_text('storage_added', lang)}\n\n"
                    text += f"{type_emoji} {name}\n\n"
                    text += f"📦 {get_text('storage_list', lang)}\n\n"
                    
                    if storages:
                        text += "```\n"
                        text += f"{'ID':<3} {'Name':<15} {'Type':<12}\n"
                        text += "─" * 32 + "\n"
                        for s in storages:
                            sname = (s['name'][:13] + '..') if len(s['name']) > 15 else s['name']
                            stypev = s['storage_type'][:10] if len(s['storage_type']) > 12 else s['storage_type']
                            text += f"{s['id']:<3} {sname:<15} {stypev:<12}\n"
                        text += "```"
                    
                    keyboard = []
                    row = []
                    for s in storages:
                        stype_emoji = type_emojis.get(s['storage_type'], '📦')
                        row.append(InlineKeyboardButton(
                            f"{stype_emoji} {s['name']}",
                            callback_data=f"admin_storage_detail_{s['id']}"
                        ))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_storage")])
                    
                    await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('error_adding_storage', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="admin_storage")
                        ]])
                    )
                
                # Clear data
                context.user_data.pop('new_storage_name', None)
                context.user_data.pop('new_storage_type', None)
                return
            
            # Storage - edit name input
            if context.user_data.get('awaiting_storage_edit_name'):
                context.user_data['awaiting_storage_edit_name'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_name = text.strip()
                
                if new_name != '-':
                    context.user_data['storage_edit_name'] = new_name
                
                context.user_data['awaiting_storage_edit_desc'] = True
                storage_id = context.user_data.get('editing_storage_id')
                
                await update.message.reply_text(
                    f"📝 {get_text('enter_storage_description', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_storage_detail_{storage_id}")
                    ]])
                )
                return
            
            # Storage - edit description input
            if context.user_data.get('awaiting_storage_edit_desc'):
                context.user_data['awaiting_storage_edit_desc'] = False
                lang = get_user_language(telegram_user_id, self.db)
                storage_id = context.user_data.get('editing_storage_id')
                
                new_desc = text.strip() if text.strip() != '-' else None
                
                from database import update_storage, get_storage_by_id
                
                new_name = context.user_data.get('storage_edit_name')
                
                if update_storage(self.db, storage_id, new_name, None, new_desc):
                    storage = get_storage_by_id(self.db, storage_id)
                    # Show brief success message
                    await update.message.reply_text(
                        f"✅ {get_text('storage_updated', lang)}\n\n"
                        f"📦 {storage['name']}\n"
                        f"📋 {storage['description'] or get_text('no_description', lang)}"
                    )
                    
                    # Auto navigate to storage detail page
                    type_emojis = {'Food': '🍎', 'Chemicals': '🧪', 'ToolRoom': '🔧', 'Shop': '🛒', 'Other': '📦'}
                    type_emoji = type_emojis.get(storage['storage_type'], '📦')
                    
                    detail_text = (
                        f"📦 <b>{get_text('storage_info', lang)}</b>\n\n"
                        f"{type_emoji} <b>{get_text('storage_name', lang)}:</b> {storage['name']}\n"
                        f"📋 <b>{get_text('storage_type', lang)}:</b> {storage['storage_type']}\n"
                        f"📝 <b>{get_text('description', lang)}:</b> {storage['description'] or get_text('no_description', lang)}\n"
                        f"📅 <b>{get_text('created_at', lang)}:</b> {storage['created_at'][:10] if storage['created_at'] else '-'}"
                    )
                    
                    detail_keyboard = [
                        [
                            InlineKeyboardButton(f"✏️ {get_text('edit', lang)}", callback_data=f"admin_storage_edit_{storage_id}"),
                            InlineKeyboardButton(f"🗑️ {get_text('delete', lang)}", callback_data=f"admin_storage_delete_{storage_id}")
                        ],
                        [InlineKeyboardButton(f"⬅️ {get_text('back', lang)}", callback_data="admin_storage_list")]
                    ]
                    
                    await update.message.reply_text(
                        detail_text,
                        parse_mode='HTML',
                        reply_markup=InlineKeyboardMarkup(detail_keyboard)
                    )
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('error_updating_storage', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_storage_detail_{storage_id}")
                        ]])
                    )
                
                # Clear edit data
                context.user_data.pop('editing_storage_id', None)
                context.user_data.pop('storage_edit_name', None)
                return
            
            # ========== SERVICE CONTACTS: Input Handlers ==========
            # Contact - name input
            if context.user_data.get('awaiting_contact_name'):
                context.user_data['awaiting_contact_name'] = False
                lang = get_user_language(telegram_user_id, self.db)
                name = text.strip()
                
                if not name:
                    await update.message.reply_text(
                        f"❌ {get_text('name_cannot_be_empty', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_contacts")
                        ]])
                    )
                    context.user_data['awaiting_contact_name'] = True
                    return
                
                context.user_data['new_contact_name'] = name
                
                # Show contact type selection
                keyboard = [
                    [
                        InlineKeyboardButton("⚡ Electrician", callback_data="admin_contact_type_Electrician"),
                        InlineKeyboardButton("🔥 Heating", callback_data="admin_contact_type_Heating")
                    ],
                    [
                        InlineKeyboardButton("🌐 Internet", callback_data="admin_contact_type_Internet"),
                        InlineKeyboardButton("🔧 PP Service", callback_data="admin_contact_type_PPService")
                    ],
                    [
                        InlineKeyboardButton("🐛 Pest Control", callback_data="admin_contact_type_PestControl"),
                        InlineKeyboardButton("🚕 Taxi", callback_data="admin_contact_type_Taxi")
                    ],
                    [InlineKeyboardButton("📞 Other", callback_data="admin_contact_type_Other")],
                    [InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_contacts")]
                ]
                
                await update.message.reply_text(
                    f"📞 {get_text('add_new_contact', lang)}\n\n"
                    f"📝 {get_text('contact_name', lang)}: {name}\n\n"
                    f"📋 {get_text('select_contact_type', lang)}:",
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
                return
            
            # Contact - email input
            if context.user_data.get('awaiting_contact_email'):
                context.user_data['awaiting_contact_email'] = False
                lang = get_user_language(telegram_user_id, self.db)
                email = text.strip()
                
                if not email or '@' not in email:
                    await update.message.reply_text(
                        f"❌ {get_text('email_required', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_contacts")
                        ]])
                    )
                    context.user_data['awaiting_contact_email'] = True
                    return
                
                context.user_data['new_contact_email'] = email
                context.user_data['awaiting_contact_whatsapp'] = True
                
                await update.message.reply_text(
                    f"📞 {get_text('add_new_contact', lang)}\n\n"
                    f"📝 {get_text('contact_name', lang)}: {context.user_data.get('new_contact_name')}\n"
                    f"📋 {get_text('contact_type', lang)}: {context.user_data.get('new_contact_type')}\n"
                    f"📧 {get_text('contact_email', lang)}: {email}\n\n"
                    f"📱 {get_text('enter_contact_whatsapp', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_contacts")
                    ]])
                )
                return
            
            # Contact - WhatsApp input
            if context.user_data.get('awaiting_contact_whatsapp'):
                context.user_data['awaiting_contact_whatsapp'] = False
                lang = get_user_language(telegram_user_id, self.db)
                whatsapp = text.strip()
                
                if not whatsapp:
                    await update.message.reply_text(
                        f"❌ {get_text('whatsapp_required', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_contacts")
                        ]])
                    )
                    context.user_data['awaiting_contact_whatsapp'] = True
                    return
                
                context.user_data['new_contact_whatsapp'] = whatsapp
                context.user_data['awaiting_contact_desc'] = True
                
                await update.message.reply_text(
                    f"📞 {get_text('add_new_contact', lang)}\n\n"
                    f"📝 {get_text('contact_name', lang)}: {context.user_data.get('new_contact_name')}\n"
                    f"📋 {get_text('contact_type', lang)}: {context.user_data.get('new_contact_type')}\n"
                    f"📧 {get_text('contact_email', lang)}: {context.user_data.get('new_contact_email')}\n"
                    f"📱 {get_text('contact_whatsapp', lang)}: {whatsapp}\n\n"
                    f"📝 {get_text('enter_contact_description', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_contacts")
                    ]])
                )
                return
            
            # Contact - description input
            if context.user_data.get('awaiting_contact_desc'):
                context.user_data['awaiting_contact_desc'] = False
                lang = get_user_language(telegram_user_id, self.db)
                desc = text.strip()
                if desc == '-':
                    desc = None
                
                from database import create_contact, get_all_contacts
                name = context.user_data.get('new_contact_name')
                ctype = context.user_data.get('new_contact_type')
                email = context.user_data.get('new_contact_email')
                whatsapp = context.user_data.get('new_contact_whatsapp')
                
                contact_id = create_contact(self.db, name, ctype, email, whatsapp, desc, telegram_user_id)
                
                if contact_id:
                    type_emojis = {'Electrician': '⚡', 'Heating': '🔥', 'Internet': '🌐', 'PPService': '🔧', 'PestControl': '🐛', 'Taxi': '🚕', 'Other': '📞'}
                    type_emoji = type_emojis.get(ctype, '📞')
                    
                    # Show success and redirect to contact list
                    contacts = get_all_contacts(self.db)
                    
                    text = f"{get_text('contact_added', lang)}\n\n"
                    text += f"{type_emoji} {name}\n"
                    text += f"📧 {email}\n"
                    text += f"📱 {whatsapp}\n\n"
                    text += f"📞 {get_text('contact_list', lang)}\n\n"
                    
                    if contacts:
                        text += "```\n"
                        text += f"{'ID':<3} {'Name':<12} {'Type':<12}\n"
                        text += "─" * 30 + "\n"
                        for c in contacts:
                            cname = (c['name'][:10] + '..') if len(c['name']) > 12 else c['name']
                            ctypev = c['contact_type'][:10] if len(c['contact_type']) > 12 else c['contact_type']
                            text += f"{c['id']:<3} {cname:<12} {ctypev:<12}\n"
                        text += "```"
                    
                    keyboard = []
                    row = []
                    for c in contacts:
                        ctype_emoji = type_emojis.get(c['contact_type'], '📞')
                        row.append(InlineKeyboardButton(
                            f"{ctype_emoji} {c['name']}",
                            callback_data=f"admin_contact_detail_{c['id']}"
                        ))
                        if len(row) == 2:
                            keyboard.append(row)
                            row = []
                    if row:
                        keyboard.append(row)
                    
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="admin_contacts")])
                    
                    await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="Markdown")
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('error_adding_contact', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="admin_contacts")
                        ]])
                    )
                
                # Clear data
                context.user_data.pop('new_contact_name', None)
                context.user_data.pop('new_contact_type', None)
                context.user_data.pop('new_contact_email', None)
                context.user_data.pop('new_contact_whatsapp', None)
                return
            
            # Contact - edit name input
            if context.user_data.get('awaiting_contact_edit_name'):
                context.user_data['awaiting_contact_edit_name'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_name = text.strip()
                
                if new_name != '-':
                    context.user_data['contact_edit_name'] = new_name
                
                context.user_data['awaiting_contact_edit_email'] = True
                contact_id = context.user_data.get('editing_contact_id')
                
                await update.message.reply_text(
                    f"📧 {get_text('enter_contact_email', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_contact_detail_{contact_id}")
                    ]])
                )
                return
            
            # Contact - edit email input
            if context.user_data.get('awaiting_contact_edit_email'):
                context.user_data['awaiting_contact_edit_email'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_email = text.strip()
                
                if new_email != '-':
                    context.user_data['contact_edit_email'] = new_email
                
                context.user_data['awaiting_contact_edit_whatsapp'] = True
                contact_id = context.user_data.get('editing_contact_id')
                
                await update.message.reply_text(
                    f"📱 {get_text('enter_contact_whatsapp', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_contact_detail_{contact_id}")
                    ]])
                )
                return
            
            # Contact - edit whatsapp input
            if context.user_data.get('awaiting_contact_edit_whatsapp'):
                context.user_data['awaiting_contact_edit_whatsapp'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_whatsapp = text.strip()
                
                if new_whatsapp != '-':
                    context.user_data['contact_edit_whatsapp'] = new_whatsapp
                
                context.user_data['awaiting_contact_edit_desc'] = True
                contact_id = context.user_data.get('editing_contact_id')
                
                await update.message.reply_text(
                    f"📝 {get_text('enter_contact_description', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_contact_detail_{contact_id}")
                    ]])
                )
                return
            
            # Contact - edit description input
            if context.user_data.get('awaiting_contact_edit_desc'):
                context.user_data['awaiting_contact_edit_desc'] = False
                lang = get_user_language(telegram_user_id, self.db)
                contact_id = context.user_data.get('editing_contact_id')
                
                new_desc = text.strip() if text.strip() != '-' else None
                
                from database import update_contact, get_contact_by_id
                
                new_name = context.user_data.get('contact_edit_name')
                new_email = context.user_data.get('contact_edit_email')
                new_whatsapp = context.user_data.get('contact_edit_whatsapp')
                
                if update_contact(self.db, contact_id, new_name, None, new_email, new_whatsapp, new_desc):
                    contact = get_contact_by_id(self.db, contact_id)
                    # Show brief success message
                    await update.message.reply_text(
                        f"✅ {get_text('contact_updated', lang)}\n\n"
                        f"📞 {contact['name']}\n"
                        f"📧 {contact['email']}\n"
                        f"📱 {contact['whatsapp']}"
                    )
                    
                    # Auto navigate to contact detail page
                    type_emojis = {'Electrician': '⚡', 'Heating': '🔥', 'Internet': '🌐', 'PPService': '🔧', 'PestControl': '🐛', 'Taxi': '🚕', 'Other': '📞'}
                    type_emoji = type_emojis.get(contact['contact_type'], '📞')
                    
                    detail_text = (
                        f"📞 <b>{get_text('contact_info', lang)}</b>\n\n"
                        f"{type_emoji} <b>{get_text('contact_name', lang)}:</b> {contact['name']}\n"
                        f"📋 <b>{get_text('contact_type', lang)}:</b> {contact['contact_type']}\n"
                        f"📧 <b>{get_text('contact_email', lang)}:</b> {contact['email']}\n"
                        f"📱 <b>{get_text('contact_whatsapp', lang)}:</b> {contact['whatsapp']}\n"
                        f"📝 <b>{get_text('description', lang)}:</b> {contact['description'] or get_text('no_description', lang)}\n"
                        f"📅 <b>{get_text('created_at', lang)}:</b> {contact['created_at'][:10] if contact['created_at'] else '-'}"
                    )
                    
                    detail_keyboard = [
                        [
                            InlineKeyboardButton(f"✏️ {get_text('edit', lang)}", callback_data=f"admin_contact_edit_{contact_id}"),
                            InlineKeyboardButton(f"🗑️ {get_text('delete', lang)}", callback_data=f"admin_contact_delete_{contact_id}")
                        ],
                        [InlineKeyboardButton(f"⬅️ {get_text('back', lang)}", callback_data="admin_contact_list")]
                    ]
                    
                    await update.message.reply_text(
                        detail_text,
                        parse_mode='HTML',
                        reply_markup=InlineKeyboardMarkup(detail_keyboard)
                    )
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('error_updating_contact', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_contact_detail_{contact_id}")
                        ]])
                    )
                
                # Clear edit data
                context.user_data.pop('editing_contact_id', None)
                context.user_data.pop('contact_edit_name', None)
                context.user_data.pop('contact_edit_email', None)
                context.user_data.pop('contact_edit_whatsapp', None)
                return
            
            # ========== LAUNDRY ASSIGNMENT: Input Handlers ==========
            # Laundry - description input
            if context.user_data.get('laundry_assign', {}).get('step') == 'description':
                description = text.strip()
                lang = get_user_language(telegram_user_id, self.db)
                
                if not description:
                    await update.message.reply_text(
                        get_text('order_cannot_be_empty', lang),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_assign_laundry")
                        ]])
                    )
                    return
                
                context.user_data['laundry_assign']['description'] = description
                context.user_data['laundry_assign']['step'] = 'deadline'
                
                assignee_name = context.user_data['laundry_assign'].get('assignee_name', 'Unknown')
                
                text_msg = f"{get_text('assign_laundry', lang)}\n\n"
                text_msg += f"👤 {get_text('worker_label', lang)}: {assignee_name}\n"
                text_msg += f"📝 {get_text('task_order', lang)}:\n{description}\n\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                text_msg += f"{get_text('step_deadline', lang)}\n"
                text_msg += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
                text_msg += get_text('select_deadline', lang)
                
                keyboard = [
                    [
                        InlineKeyboardButton(get_text('deadline_1h', lang), callback_data="laundry_deadline_1"),
                        InlineKeyboardButton(get_text('deadline_2h', lang), callback_data="laundry_deadline_2"),
                        InlineKeyboardButton(get_text('deadline_4h', lang), callback_data="laundry_deadline_3")
                    ],
                    [
                        InlineKeyboardButton(get_text('deadline_8h', lang), callback_data="laundry_deadline_6"),
                        InlineKeyboardButton(get_text('deadline_24h', lang), callback_data="laundry_deadline_12"),
                        InlineKeyboardButton(get_text('deadline_48h', lang), callback_data="laundry_deadline_24")
                    ],
                    [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="emp_assign_laundry")]
                ]
                
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # ========== ADMIN TOOL MANAGEMENT: Input Handlers ==========
            # Admin Tool - name input
            if context.user_data.get('awaiting_admin_tool_name'):
                context.user_data['awaiting_admin_tool_name'] = False
                lang = get_user_language(telegram_user_id, self.db)
                tool_name = text.strip()
                
                if not tool_name:
                    await update.message.reply_text(
                        f"❌ {get_text('name_cannot_be_empty', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_tools")
                        ]])
                    )
                    context.user_data['awaiting_admin_tool_name'] = True
                    return
                
                context.user_data['new_admin_tool_name'] = tool_name
                context.user_data['awaiting_admin_tool_desc'] = True
                
                await update.message.reply_text(
                    f"📝 {get_text('tool_name', lang)}: {tool_name}\n\n{get_text('enter_tool_description', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_tools")
                    ]])
                )
                return
            
            # Admin Tool - description input
            if context.user_data.get('awaiting_admin_tool_desc'):
                context.user_data['awaiting_admin_tool_desc'] = False
                lang = get_user_language(telegram_user_id, self.db)
                tool_desc = text.strip()
                if tool_desc == '-':
                    tool_desc = None
                
                context.user_data['new_admin_tool_desc'] = tool_desc
                context.user_data['awaiting_admin_tool_qty'] = True
                
                await update.message.reply_text(
                    f"📋 {get_text('description', lang)}: {tool_desc or get_text('no_description', lang)}\n\n{get_text('enter_tool_quantity', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_tools")
                    ]])
                )
                return
            
            # Admin Tool - quantity input
            if context.user_data.get('awaiting_admin_tool_qty'):
                context.user_data['awaiting_admin_tool_qty'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                try:
                    quantity = int(text.strip())
                    if quantity <= 0:
                        raise ValueError()
                except:
                    await update.message.reply_text(
                        f"❌ {get_text('enter_valid_number', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data="admin_tools")
                        ]])
                    )
                    context.user_data['awaiting_admin_tool_qty'] = True
                    return
                
                from database import create_tool
                tool_name = context.user_data.get('new_admin_tool_name')
                tool_desc = context.user_data.get('new_admin_tool_desc')
                
                tool_id = create_tool(self.db, tool_name, tool_desc, quantity, telegram_user_id)
                
                if tool_id:
                    await update.message.reply_text(
                        f"{get_text('tool_added', lang)}\n\n🔧 {tool_name}\n📋 {tool_desc or get_text('no_description', lang)}\n📦 {get_text('quantity', lang)}: {quantity}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="admin_tools")
                        ]])
                    )
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('error_adding_tool', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data="admin_tools")
                        ]])
                    )
                return
            
            # Admin Tool - edit name input
            if context.user_data.get('awaiting_admin_tool_edit_name'):
                context.user_data['awaiting_admin_tool_edit_name'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_name = text.strip()
                
                if new_name != '-':
                    context.user_data['admin_tool_edit_name'] = new_name
                
                context.user_data['awaiting_admin_tool_edit_desc'] = True
                tool_id = context.user_data.get('editing_admin_tool_id')
                
                await update.message.reply_text(
                    f"📝 {get_text('enter_tool_description', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_tool_detail_{tool_id}")
                    ]])
                )
                return
            
            # Admin Tool - edit description input
            if context.user_data.get('awaiting_admin_tool_edit_desc'):
                context.user_data['awaiting_admin_tool_edit_desc'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_desc = text.strip()
                
                if new_desc != '-':
                    context.user_data['admin_tool_edit_desc'] = new_desc
                
                context.user_data['awaiting_admin_tool_edit_qty'] = True
                tool_id = context.user_data.get('editing_admin_tool_id')
                
                await update.message.reply_text(
                    f"📝 {get_text('enter_tool_quantity', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_tool_detail_{tool_id}")
                    ]])
                )
                return
            
            # Admin Tool - edit quantity input
            if context.user_data.get('awaiting_admin_tool_edit_qty'):
                context.user_data['awaiting_admin_tool_edit_qty'] = False
                lang = get_user_language(telegram_user_id, self.db)
                tool_id = context.user_data.get('editing_admin_tool_id')
                
                new_qty = None
                if text.strip() != '-':
                    try:
                        new_qty = int(text.strip())
                        if new_qty <= 0:
                            raise ValueError()
                    except:
                        await update.message.reply_text(
                            f"❌ {get_text('enter_valid_number', lang)}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_tool_detail_{tool_id}")
                            ]])
                        )
                        context.user_data['awaiting_admin_tool_edit_qty'] = True
                        return
                
                from database import update_tool, get_tool_by_id
                
                new_name = context.user_data.get('admin_tool_edit_name')
                new_desc = context.user_data.get('admin_tool_edit_desc')
                
                if update_tool(self.db, tool_id, new_name, new_desc, new_qty):
                    tool = get_tool_by_id(self.db, tool_id)
                    await update.message.reply_text(
                        f"✅ {get_text('tool_updated', lang)}\n\n🔧 {tool['name']}\n📋 {tool['description'] or get_text('no_description', lang)}\n📦 {get_text('quantity', lang)}: {tool['total_quantity']}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_tool_detail_{tool_id}")
                        ]])
                    )
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('error_updating_tool', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('back', lang), callback_data=f"admin_tool_detail_{tool_id}")
                        ]])
                    )
                
                # Clear edit data
                context.user_data.pop('editing_admin_tool_id', None)
                context.user_data.pop('admin_tool_edit_name', None)
                context.user_data.pop('admin_tool_edit_desc', None)
                return
            
            # ========== TOOL MANAGEMENT: Input Handlers ==========
            # Tool - name input
            if context.user_data.get('awaiting_tool_name'):
                context.user_data['awaiting_tool_name'] = False
                lang = get_user_language(telegram_user_id, self.db)
                tool_name = text.strip()
                
                if not tool_name:
                    await update.message.reply_text(
                        f"❌ {get_text('name_cannot_be_empty', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_tools")
                        ]])
                    )
                    context.user_data['awaiting_tool_name'] = True
                    return
                
                context.user_data['new_tool_name'] = tool_name
                context.user_data['awaiting_tool_desc'] = True
                
                await update.message.reply_text(
                    f"📝 {get_text('tool_name', lang)}: {tool_name}\n\n{get_text('enter_tool_description', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_tools")
                    ]])
                )
                return
            
            # Tool - description input
            if context.user_data.get('awaiting_tool_desc'):
                context.user_data['awaiting_tool_desc'] = False
                lang = get_user_language(telegram_user_id, self.db)
                tool_desc = text.strip()
                if tool_desc == '-':
                    tool_desc = None
                
                context.user_data['new_tool_desc'] = tool_desc
                context.user_data['awaiting_tool_qty'] = True
                
                await update.message.reply_text(
                    f"📋 {get_text('tool_desc', lang)}: {tool_desc or get_text('no_description', lang)}\n\n{get_text('enter_tool_quantity', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_tools")
                    ]])
                )
                return
            
            # Tool - quantity input
            if context.user_data.get('awaiting_tool_qty'):
                context.user_data['awaiting_tool_qty'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                try:
                    quantity = int(text.strip())
                    if quantity <= 0:
                        raise ValueError()
                except:
                    await update.message.reply_text(
                        f"❌ {get_text('enter_valid_number', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_tools")
                        ]])
                    )
                    context.user_data['awaiting_tool_qty'] = True
                    return
                
                from database import create_tool
                tool_name = context.user_data.get('new_tool_name')
                tool_desc = context.user_data.get('new_tool_desc')
                
                tool_id = create_tool(self.db, tool_name, tool_desc, quantity, telegram_user_id)
                
                if tool_id:
                    await update.message.reply_text(
                        f"✅ {get_text('tool_created', lang)}\n\n🔧 {tool_name}\n📋 {tool_desc or get_text('no_description', lang)}\n📦 {get_text('quantity', lang)}: {quantity}",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(f"👁️ {get_text('preview', lang)}", callback_data=f"tool_detail_{tool_id}")],
                            [InlineKeyboardButton(f"🔙 {get_text('list_label', lang)}", callback_data="tool_list")]
                        ])
                    )
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('error_creating_tool', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_tools")
                        ]])
                    )
                
                context.user_data.pop('new_tool_name', None)
                context.user_data.pop('new_tool_desc', None)
                return
            
            # Tool - edit name input
            if context.user_data.get('awaiting_tool_edit_name'):
                context.user_data['awaiting_tool_edit_name'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_name = text.strip()
                if new_name == '-':
                    new_name = None
                
                context.user_data['edit_tool_name'] = new_name
                context.user_data['awaiting_tool_edit_desc'] = True
                
                await update.message.reply_text(
                    f"📝 {get_text('new_name', lang)}: {new_name or get_text('no_change', lang)}\n\n{get_text('enter_new_desc', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_tools")
                    ]])
                )
                return
            
            # Tool - edit description input
            if context.user_data.get('awaiting_tool_edit_desc'):
                context.user_data['awaiting_tool_edit_desc'] = False
                lang = get_user_language(telegram_user_id, self.db)
                new_desc = text.strip()
                if new_desc == '-':
                    new_desc = None
                
                context.user_data['edit_tool_desc'] = new_desc
                context.user_data['awaiting_tool_edit_qty'] = True
                
                await update.message.reply_text(
                    f"📋 {get_text('new_desc', lang)}: {new_desc or get_text('no_change', lang)}\n\n{get_text('enter_new_qty', lang)} ('-' {get_text('to_skip', lang)}):",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_tools")
                    ]])
                )
                return
            
            # Tool - edit quantity input
            if context.user_data.get('awaiting_tool_edit_qty'):
                context.user_data['awaiting_tool_edit_qty'] = False
                lang = get_user_language(telegram_user_id, self.db)
                
                new_qty = None
                if text.strip() != '-':
                    try:
                        new_qty = int(text.strip())
                        if new_qty <= 0:
                            raise ValueError()
                    except:
                        await update.message.reply_text(
                            f"❌ {get_text('enter_valid_number_or_dash', lang)}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_tools")
                            ]])
                        )
                        context.user_data['awaiting_tool_edit_qty'] = True
                        return
                
                from database import update_tool
                tool_id = context.user_data.get('editing_tool_id')
                new_name = context.user_data.get('edit_tool_name')
                new_desc = context.user_data.get('edit_tool_desc')
                
                if update_tool(self.db, tool_id, name=new_name, description=new_desc, total_quantity=new_qty):
                    await update.message.reply_text(
                        f"✅ {get_text('tool_updated', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"👁️ {get_text('preview', lang)}", callback_data=f"tool_detail_{tool_id}"),
                            InlineKeyboardButton(f"🔙 {get_text('list_label', lang)}", callback_data="tool_list")
                        ]])
                    )
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('error_updating_tool', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_tools")
                        ]])
                    )
                
                context.user_data.pop('editing_tool_id', None)
                context.user_data.pop('edit_tool_name', None)
                context.user_data.pop('edit_tool_desc', None)
                return
            
            # Tool - purpose input
            if context.user_data.get('awaiting_tool_purpose'):
                context.user_data['awaiting_tool_purpose'] = False
                lang = get_user_language(telegram_user_id, self.db)
                purpose = text.strip()
                
                if not purpose:
                    await update.message.reply_text(
                        f"❌ {get_text('purpose_cannot_be_empty', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_tools")
                        ]])
                    )
                    context.user_data['awaiting_tool_purpose'] = True
                    return
                
                context.user_data['tool_purpose'] = purpose
                
                await update.message.reply_text(
                    f"📝 {get_text('purpose', lang)}: {purpose}\n\n"
                    f"📸 {get_text('add_proof_question', lang)}\n\n"
                    f"• {get_text('send_proof_borrow', lang)}\n"
                    f"• {get_text('or_press_skip', lang)}",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(f"⏭️ {get_text('skip_proof', lang)}", callback_data="tool_skip_proof")],
                        [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="reception_tools")]
                    ])
                )
                context.user_data['awaiting_tool_proof'] = True
                return
            
            # Vehicle Usage - purpose input
            if self.user_context.get(telegram_user_id, {}).get('awaiting_vehicle_purpose'):
                if telegram_user_id in self.user_context:
                    self.user_context[telegram_user_id]['awaiting_vehicle_purpose'] = False
                
                purpose = text.strip()
                if not purpose:
                    await update.message.reply_text(
                        f"❌ {get_text('enter_purpose', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_vehicle_purpose'] = True
                    return
                
                self.user_context[user_id]['vehicle_purpose'] = purpose
                self.user_context[user_id]['awaiting_vehicle_mileage_before'] = True
                
                await update.message.reply_text(
                    f"📊 {get_text('enter_mileage_before', lang)}\n\n"
                    f"📝 {get_text('usage_purpose', lang)}: {purpose}",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")
                    ]])
                )
                return
            
            # Vehicle Usage - mileage before input
            if self.user_context.get(telegram_user_id, {}).get('awaiting_vehicle_mileage_before'):
                if telegram_user_id in self.user_context:
                    self.user_context[telegram_user_id]['awaiting_vehicle_mileage_before'] = False
                
                try:
                    mileage_before = int(text.strip())
                    if mileage_before < 0:
                        raise ValueError()
                except:
                    await update.message.reply_text(
                        f"❌ {get_text('enter_mileage_before', lang)} (numbers only)",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_vehicle_mileage_before'] = True
                    return
                
                # Create vehicle usage record
                from database import create_vehicle_usage
                vehicle_id = self.user_context[telegram_user_id].get('selected_vehicle_id')
                driver_id = self.user_context[telegram_user_id].get('selected_driver_id')
                driver_name = self.user_context[telegram_user_id].get('selected_driver_name')
                purpose = self.user_context[telegram_user_id].get('vehicle_purpose')
                
                usage_id = create_vehicle_usage(self.db, vehicle_id, driver_id, driver_name, purpose, mileage_before, telegram_user_id)
                
                if usage_id:
                    # Get vehicle name
                    from database import get_transportations
                    vehicles = get_transportations(self.db)
                    vehicle_name = "Vehicle"
                    for v in vehicles:
                        if v[0] == vehicle_id:
                            vehicle_name = v[1]
                            break
                    
                    text_msg = f"✅ {get_text('vehicle_borrowed', lang)}\n\n"
                    text_msg += f"🚗 {vehicle_name}\n"
                    text_msg += f"👤 {get_text('driver', lang)}: {driver_name}\n"
                    text_msg += f"📝 {get_text('usage_purpose', lang)}: {purpose}\n"
                    text_msg += f"📊 {get_text('mileage_before', lang)}: {mileage_before} km"
                    
                    await update.message.reply_text(
                        text_msg,
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")
                        ]])
                    )
                else:
                    await update.message.reply_text(
                        "❌ Error creating vehicle usage",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")
                        ]])
                    )
                
                # Clean up context
                self.user_context[telegram_user_id].pop('selected_vehicle_id', None)
                self.user_context[telegram_user_id].pop('selected_driver_id', None)
                self.user_context[telegram_user_id].pop('selected_driver_name', None)
                self.user_context[telegram_user_id].pop('vehicle_purpose', None)
                return
            
            # Vehicle Usage - mileage after input (for return)
            if self.user_context.get(telegram_user_id, {}).get('awaiting_vehicle_mileage_after'):
                if telegram_user_id in self.user_context:
                    self.user_context[telegram_user_id]['awaiting_vehicle_mileage_after'] = False
                
                try:
                    mileage_after = int(text.strip())
                    if mileage_after < 0:
                        raise ValueError()
                except:
                    await update.message.reply_text(
                        f"❌ {get_text('enter_mileage_after', lang)} (numbers only)",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")
                        ]])
                    )
                    self.user_context[telegram_user_id]['awaiting_vehicle_mileage_after'] = True
                    return
                
                self.user_context[telegram_user_id]['vehicle_mileage_after'] = mileage_after
                
                # Ask for inspection status
                await update.message.reply_text(
                    f"🔍 {get_text('vehicle_inspection', lang)}\n\n"
                    f"📊 {get_text('mileage_after', lang)}: {mileage_after} km",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(f"✅ {get_text('inspection_good', lang)}", callback_data="vehicle_inspection_good")],
                        [InlineKeyboardButton(f"⚠️ {get_text('inspection_issue', lang)}", callback_data="vehicle_inspection_issue")],
                        [InlineKeyboardButton(f"🔙 {get_text('back', lang)}", callback_data="reception_vehicles")]
                    ])
                )
                return
            
            # ========== ADMIN HOTEL ROOMS: Creation/Edit Processing ==========
            # Admin hotel room creation - step 1: name input
            if context.user_data.get('awaiting_admin_hotel_room_name'):
                lang = get_user_language(telegram_user_id, self.db)
                context.user_data['awaiting_admin_hotel_room_name'] = False
                room_name = text.strip()
                
                await update.message.reply_text(
                    f"📝 {get_text('room_name_confirmed', lang)}: {room_name}\n\n{get_text('enter_room_description', lang)}:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="admin_hotel_rooms")
                    ]])
                )
                context.user_data['new_admin_hotel_room_name'] = room_name
                context.user_data['awaiting_admin_hotel_room_desc'] = True
                return
            
            # Admin hotel room creation - step 2: description input
            if context.user_data.get('awaiting_admin_hotel_room_desc'):
                from database import create_hotel_room
                context.user_data['awaiting_admin_hotel_room_desc'] = False
                room_desc = text.strip()
                room_name = context.user_data.get('new_admin_hotel_room_name')
                
                room_id = create_hotel_room(self.db, room_name, room_desc, telegram_user_id)
                lang = get_user_language(telegram_user_id, self.db)
                
                if room_id:
                    await update.message.reply_text(
                        f"✅ {get_text('room_created_success', lang)}\n🏢 {room_name}\n📋 {room_desc}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back_to_main_menu', lang)}", callback_data="actions")
                        ]])
                    )
                else:
                    await update.message.reply_text(
                        f"❌ {get_text('room_creation_error_exists', lang)}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(f"🔙 {get_text('back_to_main_menu', lang)}", callback_data="actions")
                        ]])
                    )
                return
            
            # Admin hotel room editing - step 1: name input
            if context.user_data.get('awaiting_admin_hotel_room_edit_name'):
                lang = get_user_language(telegram_user_id, self.db)
                context.user_data['awaiting_admin_hotel_room_edit_name'] = False
                room_id = context.user_data.get('editing_admin_hotel_room_id')
                new_name = text.strip()
                
                await update.message.reply_text(
                    f"✏️ Novo ime: {new_name}\n\nUnesite novi opis prostorije:",
                    reply_markup=InlineKeyboardMarkup([[
                        InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data=f"admin_hotel_room_{room_id}")
                    ]])
                )
                context.user_data['new_admin_hotel_room_name'] = new_name
                context.user_data['awaiting_admin_hotel_room_edit_desc'] = True
                return
            
            # Admin hotel room editing - step 2: description input
            if context.user_data.get('awaiting_admin_hotel_room_edit_desc'):
                from database import update_hotel_room
                lang = get_user_language(telegram_user_id, self.db)
                context.user_data['awaiting_admin_hotel_room_edit_desc'] = False
                room_id = context.user_data.get('editing_admin_hotel_room_id')
                new_desc = text.strip()
                new_name = context.user_data.get('new_admin_hotel_room_name')
                
                if update_hotel_room(self.db, room_id, new_name, new_desc):
                    await update.message.reply_text(
                        f"✅ Prostorija ažurirana:\n🏢 {new_name}\n📋 {new_desc}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton("👁️ Pregled", callback_data=f"admin_hotel_room_{room_id}"),
                            InlineKeyboardButton("🔙 Lista", callback_data="admin_hotel_rooms")
                        ]])
                    )
                else:
                    await update.message.reply_text(
                        "❌ Greška pri ažuriranju prostorije.",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton("🔙 Nazad", callback_data=f"admin_hotel_room_{room_id}")
                        ]])
                    )
                return
            
            # ========== GUEST ROOM TEXT INPUT HANDLERS ==========
            
            # Guest room - Update guest count
            if context.user_data.get('awaiting_guest_count'):
                from database import update_guest_room_guests, get_guest_room_by_id
                lang = get_user_language(telegram_user_id, self.db)
                room_id = context.user_data.get('awaiting_guest_count')
                max_capacity = context.user_data.get('max_capacity', 5)
                
                try:
                    guest_count = int(text.strip())
                    if guest_count < 0 or guest_count > max_capacity:
                        await update.message.reply_text(
                            get_text('invalid_guest_count', lang).format(max_capacity),
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_guest_room_{room_id}")
                            ]])
                        )
                        return
                    
                    if update_guest_room_guests(self.db, room_id, guest_count):
                        context.user_data.pop('awaiting_guest_count', None)
                        context.user_data.pop('max_capacity', None)
                        
                        room = get_guest_room_by_id(self.db, room_id)
                        await update.message.reply_text(
                            f"{get_text('guests_updated', lang)}\n🚪 {room['room_number']}: {guest_count} {get_text('guests', lang)}",
                            reply_markup=InlineKeyboardMarkup([[
                                InlineKeyboardButton(get_text('view', lang), callback_data=f"admin_guest_room_{room_id}"),
                                InlineKeyboardButton(get_text('back', lang), callback_data="admin_guest_rooms")
                            ]])
                        )
                    else:
                        await update.message.reply_text("❌ Error updating")
                except ValueError:
                    await update.message.reply_text(
                        get_text('invalid_guest_count', lang).format(max_capacity),
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('cancel', lang), callback_data=f"admin_guest_room_{room_id}")
                        ]])
                    )
                return
            
            # Guest room - Add notes
            if context.user_data.get('awaiting_guest_room_notes'):
                from database import update_guest_room_notes, get_guest_room_by_id
                lang = get_user_language(telegram_user_id, self.db)
                room_id = context.user_data.get('awaiting_guest_room_notes')
                notes = text.strip()
                
                if update_guest_room_notes(self.db, room_id, notes):
                    context.user_data.pop('awaiting_guest_room_notes', None)
                    
                    room = get_guest_room_by_id(self.db, room_id)
                    await update.message.reply_text(
                        f"{get_text('notes_updated', lang)}\n🚪 {room['room_number']}",
                        reply_markup=InlineKeyboardMarkup([[
                            InlineKeyboardButton(get_text('view', lang), callback_data=f"admin_guest_room_{room_id}"),
                            InlineKeyboardButton(get_text('back', lang), callback_data="admin_guest_rooms")
                        ]])
                    )
                else:
                    await update.message.reply_text("❌ Error updating")
                return
            
            # ========== HOTEL ROOMS: Creation/Edit Processing (MOVED TO ADMIN) ==========
            # These handlers are now only in admin section with awaiting_admin_hotel_room_* keys
            # Hotel room creation - step 1: name input
            # if context.user_data.get('awaiting_hotel_room_name'):
            
            # Hotel room creation - step 2: description input
            # if context.user_data.get('awaiting_hotel_room_desc'):
            
            # Hotel room editing - step 1: name input
            # if context.user_data.get('awaiting_hotel_room_edit_name'):
            
            # Hotel room editing - step 2: description input
            # if context.user_data.get('awaiting_hotel_room_edit_desc'):
            
            # ========== Hotel Settings: Total Rooms Input Processing ==========
            if context.user_data.get('awaiting_hotel_capacity'):
                if text.lower() in ['otkaži', 'otkazi', 'cancel']:
                    context.user_data.pop('awaiting_hotel_capacity', None)
                    lang = get_user_language(telegram_user_id, self.db)
                    await update.message.reply_text(get_text('change_cancelled', lang))
                    return
                
                try:
                    total_rooms = int(text.strip())
                    if total_rooms < 0:
                        lang = get_user_language(telegram_user_id, self.db)
                        await update.message.reply_text(get_text('rooms_cannot_be_negative', lang))
                        return
                    
                    if self.db.update_hotel_settings(total_rooms=total_rooms):
                        context.user_data.pop('awaiting_hotel_capacity', None)
                        lang = get_user_language(telegram_user_id, self.db)
                        
                        room_summary = self.db.get_customer_rooms_summary()
                        
                        success_text = f"""{get_text('hotel_capacity_updated', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('new_settings_header', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🏨 {get_text('set_capacity_label', lang)}: {total_rooms} {get_text('rooms_label', lang)}
📋 {get_text('currently_registered_label', lang)}: {room_summary['total']} {get_text('rooms_label', lang)}
   ├─ {get_text('active_rooms', lang)}: {room_summary['active']}
   └─ {get_text('inactive_rooms', lang)}: {room_summary['inactive']}

━━━━━━━━━━━━━━━━━━━━━━━━━━━"""
                        
                        keyboard = [
                            [InlineKeyboardButton(get_text('back_to_room_management', lang), callback_data="action_2")]
                        ]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await update.message.reply_text(success_text, reply_markup=reply_markup)
                    else:
                        lang = get_user_language(telegram_user_id, self.db)
                        await update.message.reply_text(get_text('settings_update_error', lang))
                        context.user_data.pop('awaiting_hotel_capacity', None)
                except ValueError:
                    lang = get_user_language(telegram_user_id, self.db)
                    await update.message.reply_text(get_text('invalid_number_input', lang))
                return
            
            # ========== Employee Registration: Name Input Processing ==========
            if 'registration' in context.user_data and context.user_data['registration'].get('step') == 'name':
                name = text.strip()
                
                if len(name) < 2:
                    await update.message.reply_text("❌ Ime mora imati najmanje 2 karaktera. Molimo pokušajte ponovo:")
                    return
                
                department = context.user_data['registration'].get('department')
                work_role = context.user_data['registration'].get('work_role')
                
                # Register employee with work_role
                employee_id = self.db.register_employee(telegram_user_id, name, department, work_role)
                
                if employee_id:
                    # Clear registration data
                    context.user_data.pop('registration', None)
                    
                    lang = get_user_language(telegram_user_id, self.db)
                    emoji = get_dept_emoji(department)
                    dept_display = get_dept_display(department)
                    role_display = get_work_role_display(work_role, lang) if work_role else get_text('not_assigned_role', lang)
                    
                    # Success message
                    congratulations = f"""🎉 {get_text('congratulations_registration', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('welcome_to_system', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

👤 {get_text('your_data', lang)}:
• {get_text('employee_id_short', lang)}: {employee_id}
• {get_text('name_label', lang)}: {name}
• {get_text('department', lang)}: {emoji} {dept_display}
• {get_text('work_role_label', lang)}: 💼 {role_display}

{get_text('ready_to_use', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━"""
                    
                    keyboard = [
                        [InlineKeyboardButton(f"◆ {get_text('jobs', lang)}", callback_data="emp_work_menu"),
                         InlineKeyboardButton(f"✅ {get_text('report', lang)}", callback_data="emp_report_task")],
                        [InlineKeyboardButton(f"🔔 {get_text('notifications', lang)}", callback_data="emp_notifications")],
                        [InlineKeyboardButton(f"👤 {get_text('profile', lang)}", callback_data="emp_profile"),
                         InlineKeyboardButton(f"⚙️ {get_text('settings', lang)}", callback_data="emp_settings")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await update.message.reply_text(congratulations, reply_markup=reply_markup)
                else:
                    lang = get_user_language(telegram_user_id, self.db)
                    await update.message.reply_text(f"❌ {get_text('registration_error', lang)}")
                    context.user_data.pop('registration', None)
                return
            
            # ========== Complaint: Text Input Processing ==========
            if 'complaint' in context.user_data and context.user_data['complaint'].get('step') == 'text':
                lang = get_user_language(telegram_user_id, self.db)
                complaint_text = text.strip()
                
                if len(complaint_text) < 10:
                    await update.message.reply_text("❌ Pritužba mora imati najmanje 10 karaktera. Molimo opišite detaljnije:")
                    return
                
                context.user_data['complaint']['text'] = complaint_text
                context.user_data['complaint']['step'] = 'media'
                
                keyboard = [
                    [InlineKeyboardButton("⏭️ Preskoči (bez priloga)", callback_data="complaint_skip_media")],
                    [InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_complaint")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                await update.message.reply_text(
                    f"""📝 Nova pritužba - Korak 2/2

✅ Tekst sačuvan!

{get_text('your_complaint', lang)}
{complaint_text[:200]}{'...' if len(complaint_text) > 200 else ''}

📎 Da li želite da priložite fotografiju ili dokument?

Pošaljite fotografiju/dokument ili pritisnite "Preskoči" za slanje bez priloga.""",
                    reply_markup=reply_markup
                )
                return
            
            # ========== Work Role: Add/Edit Input Processing ==========
            # Work Role Add: Name input
            if context.user_data.get('role_add_step') == 'name':
                from database import add_work_role, get_all_work_roles
                lang = get_user_language(telegram_user_id, self.db)
                
                role_name = text.strip()
                
                if len(role_name) < 2:
                    await update.message.reply_text("❌ Naziv mora imati najmanje 2 karaktera. Molimo pokušajte ponovo:")
                    return
                
                context.user_data['role_add_name'] = role_name
                context.user_data['role_add_step'] = 'description'
                
                text_msg = f"""➕ Dodavanje novog radnog mesta

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📍 KORAK 2/2: Opis
━━━━━━━━━━━━━━━━━━━━━━━━━━━

💼 Naziv: {role_name}

Unesite opis radnog mesta (ili pošaljite "-" za prazan opis):"""
                
                keyboard = [[InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="work_roles_menu")]]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(text_msg, reply_markup=reply_markup)
                return
            
            # Work Role Add: Description input
            if context.user_data.get('role_add_step') == 'description':
                from database import add_work_role, get_all_work_roles
                
                description = text.strip()
                if description == "-":
                    description = None
                
                role_name = context.user_data.get('role_add_name')
                
                lang = get_user_language(telegram_user_id, self.db)
                
                if add_work_role(self.db, role_name, description):
                    context.user_data.pop('role_add_step', None)
                    context.user_data.pop('role_add_name', None)
                    
                    await update.message.reply_text(f"✅ {get_text('work_role', lang)} '{role_name}' {get_text('added_successfully', lang)}")
                    
                    # Show updated work roles list
                    work_roles = get_all_work_roles(self.db)
                    
                    text_msg = f"""💼 {get_text('work_roles_management', lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
{get_text('work_roles_list', lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

"""
                    keyboard = []
                    
                    if work_roles:
                        for role_id, r_name, desc, created_at in work_roles:
                            desc_short = (desc[:30] + "...") if desc and len(desc) > 30 else (desc or get_text('no_desc', lang))
                            text_msg += f"💼 {r_name}: {desc_short}\n"
                            keyboard.append([InlineKeyboardButton(f"💼 {r_name}", callback_data=f"role_view_{role_id}")])
                    else:
                        text_msg += get_text('no_work_roles', lang) + "\n"
                    
                    text_msg += f"\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n{get_text('select_role_manage', lang)}"
                    
                    keyboard.append([InlineKeyboardButton(get_text('add_work_role', lang), callback_data="role_add")])
                    keyboard.append([InlineKeyboardButton(get_text('back', lang), callback_data="employees_menu")])
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await update.message.reply_text(text_msg, reply_markup=reply_markup)
                else:
                    await update.message.reply_text(f"❌ {get_text('error_occurred', lang)}")
                    context.user_data.pop('role_add_step', None)
                    context.user_data.pop('role_add_name', None)
                return
            
            # Work Role Edit: Name input
            if context.user_data.get('role_edit_step') == 'name':
                from database import update_work_role, get_work_role_by_id
                
                new_name = text.strip()
                
                if len(new_name) < 2:
                    await update.message.reply_text("❌ Naziv mora imati najmanje 2 karaktera. Molimo pokušajte ponovo:")
                    return
                
                role_id = context.user_data.get('role_edit_id')
                
                if update_work_role(self.db, role_id, role_name=new_name):
                    context.user_data.pop('role_edit_step', None)
                    context.user_data.pop('role_edit_id', None)
                    
                    await update.message.reply_text(f"✅ Naziv radnog mesta je uspešno promenjen u '{new_name}'!")
                    
                    # Show updated role details
                    role = get_work_role_by_id(self.db, role_id)
                    if role:
                        text_msg = f"""💼 Detalji radnog mesta

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 INFORMACIJE
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🆔 ID: {role['id']}
💼 Naziv: {role['role_name']}
📝 Opis: {role['description'] or 'Bez opisa'}
📅 Kreirano: {role['created_at'] or 'N/A'}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚙️ OPCIJE
━━━━━━━━━━━━━━━━━━━━━━━━━━━"""
                        
                        keyboard = [
                            [InlineKeyboardButton("✏️ Izmeni naziv", callback_data=f"role_edit_name_{role_id}")],
                            [InlineKeyboardButton("📝 Izmeni opis", callback_data=f"role_edit_desc_{role_id}")],
                            [InlineKeyboardButton("🗑️ Obriši radno mesto", callback_data=f"role_delete_{role_id}")],
                            [InlineKeyboardButton("🔙 Nazad", callback_data="work_roles_menu")]
                        ]
                        
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await update.message.reply_text(text_msg, reply_markup=reply_markup)
                else:
                    await update.message.reply_text("❌ Greška pri promeni naziva. Molimo pokušajte ponovo.")
                    context.user_data.pop('role_edit_step', None)
                    context.user_data.pop('role_edit_id', None)
                return
            
            # Work Role Edit: Description input
            if context.user_data.get('role_edit_step') == 'description':
                from database import update_work_role, get_work_role_by_id
                
                new_description = text.strip()
                if new_description == "-":
                    new_description = ""
                
                role_id = context.user_data.get('role_edit_id')
                
                if update_work_role(self.db, role_id, description=new_description):
                    context.user_data.pop('role_edit_step', None)
                    context.user_data.pop('role_edit_id', None)
                    
                    await update.message.reply_text("✅ Opis radnog mesta je uspešno promenjen!")
                    
                    # Show updated role details
                    role = get_work_role_by_id(self.db, role_id)
                    if role:
                        text_msg = f"""💼 Detalji radnog mesta

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 INFORMACIJE
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🆔 ID: {role['id']}
💼 Naziv: {role['role_name']}
📝 Opis: {role['description'] or 'Bez opisa'}
📅 Kreirano: {role['created_at'] or 'N/A'}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚙️ OPCIJE
━━━━━━━━━━━━━━━━━━━━━━━━━━━"""
                        
                        keyboard = [
                            [InlineKeyboardButton("✏️ Izmeni naziv", callback_data=f"role_edit_name_{role_id}")],
                            [InlineKeyboardButton("📝 Izmeni opis", callback_data=f"role_edit_desc_{role_id}")],
                            [InlineKeyboardButton("🗑️ Obriši radno mesto", callback_data=f"role_delete_{role_id}")],
                            [InlineKeyboardButton("🔙 Nazad", callback_data="work_roles_menu")]
                        ]
                        
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await update.message.reply_text(text_msg, reply_markup=reply_markup)
                else:
                    await update.message.reply_text("❌ Greška pri promeni opisa. Molimo pokušajte ponovo.")
                    context.user_data.pop('role_edit_step', None)
                    context.user_data.pop('role_edit_id', None)
                return
            
            # Task Creation: Description input processing
            if 'task_creation' in context.user_data and context.user_data['task_creation'].get('step') == 'description':
                # Check admin permission
                if not self.db.check_admin(telegram_user_id):
                    await update.message.reply_text(get_text('command_not_available', lang))
                    return
                
                # Save description
                context.user_data['task_creation']['description'] = text
                context.user_data['task_creation']['step'] = 'priority'
                
                lang = get_user_language(telegram_user_id, self.db)
                dept_name = context.user_data['task_creation'].get('department_name', get_text('unknown', lang))
                emp_name = context.user_data['task_creation'].get('employee_name', 'Unassigned')
                emp_name_display = get_text('not_assigned', lang) if emp_name == "Unassigned" else emp_name
                current_priority = context.user_data['task_creation'].get('priority', 'Normal')
                proof_required = context.user_data['task_creation'].get('proof_required', False)
                
                # Priority selection buttons with proof required option
                keyboard = [
                    [
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Low' else '⬜'} 🟢 {get_text('priority_low', lang)}", callback_data="task_priority_Low"),
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Normal' else '⬜'} 🟡 {get_text('priority_normal', lang)}", callback_data="task_priority_Normal"),
                        InlineKeyboardButton(f"{'✅' if current_priority == 'Urgent' else '⬜'} 🔴 {get_text('priority_urgent', lang)}", callback_data="task_priority_Urgent")
                    ],
                    [
                        InlineKeyboardButton(f"{'✅' if proof_required else '⬜'} 📸 {get_text('proof_required', lang)}", callback_data="task_toggle_proof")
                    ],
                    [
                        InlineKeyboardButton(f"➡️ {get_text('next', lang)}", callback_data="task_proceed_duedate")
                    ],
                    [
                        InlineKeyboardButton(get_text('back', lang), callback_data=f"task_emp_{context.user_data['task_creation'].get('employee_id', 'skip')}" if context.user_data['task_creation'].get('employee_id') else "task_skip_emp"),
                        InlineKeyboardButton(get_text('cancel', lang), callback_data="actions")
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                priority_emoji = {"Low": "🟢", "Normal": "🟡", "Urgent": "🔴"}.get(current_priority, "🟡")
                priority_display = {"Low": get_text('priority_low', lang), "Normal": get_text('priority_normal', lang), "Urgent": get_text('priority_urgent', lang)}.get(current_priority, current_priority)
                proof_status = get_text('proof_required_yes', lang) if proof_required else get_text('proof_required_no', lang)
                
                await update.message.reply_text(
                    f"📝 {get_text('create_task_step', lang)} 4/6\n\n🏢 {get_text('department', lang)}: {dept_name}\n👤 {get_text('assigned_to', lang)}: {emp_name_display}\n📋 {get_text('description', lang)}: {text[:50]}{'...' if len(text) > 50 else ''}\n{priority_emoji} {get_text('priority', lang)}: {priority_display}\n📸 {get_text('proof_required', lang)}: {proof_status}\n\n⚡ {get_text('select_priority_and_proof', lang)}:",
                    reply_markup=reply_markup
                )
                return
            
            # Employee Add: Telegram ID input processing
            if context.user_data.get('emp_add_step') == 'telegram_id':
                try:
                    telegram_id = int(text.strip())
                    
                    # Check if employee already exists
                    existing = self.db.check_employee_exists(telegram_id)
                    if existing:
                        await update.message.reply_text(f"❌ Zaposleni sa ovim Telegram ID-om već postoji: {existing[1]} ({existing[0]})")
                        return
                    
                    context.user_data['emp_add_telegram_id'] = telegram_id
                    context.user_data['emp_add_step'] = 'department'
                    
                    # Show department selection
                    departments = self.db.get_departments(exclude_management=False)
                    
                    keyboard = []
                    for dept_id, dept_name, dept_content in departments:
                        emoji = get_dept_emoji(dept_name)
                        dept_display = get_dept_display(dept_name)
                        keyboard.append([InlineKeyboardButton(f"{emoji} {dept_display}", callback_data=f"emp_add_dept_{dept_name}")])
                    
                    keyboard.append([InlineKeyboardButton(f"{get_text('cancel', lang)}", callback_data="emp_list")])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await update.message.reply_text(
                        f"""➕ Dodavanje novog zaposlenog

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📍 KORAK 2/3: Odeljenje
━━━━━━━━━━━━━━━━━━━━━━━━━━━

📱 Telegram ID: {telegram_id}

Izaberite odeljenje za novog zaposlenog:""",
                        reply_markup=reply_markup
                    )
                except ValueError:
                    await update.message.reply_text("❌ Neispravan Telegram ID. Molimo unesite broj.")
                return
            
            # Employee Add: Name input processing
            if context.user_data.get('emp_add_step') == 'name':
                name = text.strip()
                
                if len(name) < 2:
                    await update.message.reply_text("❌ Ime mora imati najmanje 2 karaktera. Molimo pokušajte ponovo:")
                    return
                
                telegram_id = context.user_data.get('emp_add_telegram_id')
                department = context.user_data.get('emp_add_dept')
                
                # Register employee
                employee_id = self.db.register_employee(telegram_id, name, department)
                
                if employee_id:
                    # Log employee addition
                    try:
                        event_logger = get_event_logger()
                        admin_user = update.effective_user
                        event_logger.log_admin_action(
                            admin_id=admin_user.id,
                            admin_name=admin_user.full_name,
                            action="create",
                            target_type="employee",
                            target_id=employee_id,
                            description=f"New employee added: {name}",
                            details={
                                "employee_name": name,
                                "department": department,
                                "telegram_id": telegram_id
                            }
                        )
                    except Exception as log_error:
                        print(f"Event logging error: {log_error}")
                    
                    # Clear add data
                    context.user_data.pop('emp_add_step', None)
                    context.user_data.pop('emp_add_telegram_id', None)
                    context.user_data.pop('emp_add_dept', None)
                    
                    dept_display = get_dept_display(department)
                    
                    keyboard = [
                        [InlineKeyboardButton("👤 Pogledaj profil", callback_data=f"emp_view_{employee_id}")],
                        [InlineKeyboardButton("➕ Dodaj još jednog", callback_data="emp_add")],
                        [InlineKeyboardButton("🔙 Lista zaposlenih", callback_data="emp_list")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await update.message.reply_text(
                        f"""✅ Zaposleni uspešno dodat!

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 DETALJI
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🆔 ID: {employee_id}
👤 Ime: {name}
🏢 Odeljenje: {dept_display}
📱 Telegram ID: {telegram_id}""",
                        reply_markup=reply_markup
                    )
                else:
                    await update.message.reply_text("❌ Greška pri dodavanju zaposlenog. Molimo pokušajte ponovo.")
                return
            
            # Employee Edit: Name input processing
            if context.user_data.get('emp_edit_step') == 'name':
                name = text.strip()
                
                if len(name) < 2:
                    await update.message.reply_text("❌ Ime mora imati najmanje 2 karaktera. Molimo pokušajte ponovo:")
                    return
                
                emp_id = context.user_data.get('emp_edit_id')
                
                if self.db.update_employee(emp_id, name=name):
                    # Clear edit data
                    context.user_data.pop('emp_edit_step', None)
                    context.user_data.pop('emp_edit_id', None)
                    
                    employee = self.db.get_employee_by_id(emp_id)
                    dept_display = get_dept_display(employee['department']) if employee else 'N/A'
                    
                    keyboard = [
                        [InlineKeyboardButton("✏️ Ime", callback_data=f"emp_edit_name_{emp_id}"),
                         InlineKeyboardButton("🏢 Odeljenje", callback_data=f"emp_edit_dept_{emp_id}")],
                        [InlineKeyboardButton("🗑️ Obriši", callback_data=f"emp_delete_{emp_id}"),
                         InlineKeyboardButton("🔙 Nazad", callback_data="emp_list")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await update.message.reply_text(
                        f"""✅ Ime uspešno izmenjeno!

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 INFORMACIJE
━━━━━━━━━━━━━━━━━━━━━━━━━━━

🆔 ID: {employee['employee_id']}
👤 Ime: {employee['name']}
🏢 Odeljenje: {dept_display}
📱 Telegram ID: {employee['telegram_user_id']}""",
                        reply_markup=reply_markup
                    )
                else:
                    await update.message.reply_text("❌ Greška pri izmeni imena. Molimo pokušajte ponovo.")
                return
            
            # If input looks like a command
            if text.startswith('/'):
                await update.message.reply_text(
                    f"❌ Neregistrovana komanda: '{text}'\n\n"
                    f"📌 Dostupne komande:\n"
                    f"/start - Pokrenite bota\n"
                    f"/help - Prikažite pomoć\n"
                    f"/admin - Admin panel (samo za upravu)\n"
                    f"/rooms - Pogledajte listu soba\n"
                    f"/reservations - Pogledajte rezervacije\n\n"
                    f"Ukucajte /help za više informacija."
                )
            else:
                # Check if user is registered
                lang = get_user_language(telegram_user_id, self.db)
                employee = self.db.check_employee_exists(telegram_user_id)
                if employee:
                    await update.message.reply_text(
                        get_text('type_start_for_menu', lang)
                    )
                else:
                    await update.message.reply_text(
                        get_text('not_registered', lang)
                    )
        except Exception as e:
            import traceback
            print(f"❌ Error in handle_message: {e}")
            print(f"📍 Traceback:\n{traceback.format_exc()}")
            try:
                telegram_user_id = update.effective_user.id
                lang = get_user_language(telegram_user_id, self.db)
                await update.message.reply_text(get_text('error_occurred_try_again', lang))
            except:
                pass
    
    async def check_duty_expiration(self, duty_check_id: int, admin_id: int):
        """Check duty check expiration after 5 minutes and mark non-responders"""
        import asyncio
        
        # Wait 5 minutes
        await asyncio.sleep(300)  # 300 seconds = 5 minutes
        
        # Mark expired duty check
        self.db.update_duty_check_status(duty_check_id, 'expired')
        
        # Mark non-responders as expired (response = 3)
        self.db.mark_expired_duty_responses(duty_check_id)
        
        # Get final results
        responses = self.db.get_duty_responses(duty_check_id)
        
        on_duty = [r for r in responses if r['response'] == 1]
        not_duty = [r for r in responses if r['response'] == 2]
        no_response = [r for r in responses if r['response'] == 3]
        
        # Send summary to admin
        try:
            admin_lang = get_user_language(admin_id, self.db)
            summary_text = f"""⏰ {get_text('shift_check_completed', admin_lang)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 {get_text('final_results', admin_lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

✅ {get_text('on_duty', admin_lang)} ({len(on_duty)}):"""
            
            if on_duty:
                for r in on_duty:
                    summary_text += f"\n  👤 {r['name']}"
            else:
                summary_text += f"\n  ({get_text('none', admin_lang)})"
            
            summary_text += f"\n\n❌ {get_text('not_on_duty', admin_lang)} ({len(not_duty)}):"
            if not_duty:
                for r in not_duty:
                    summary_text += f"\n  👤 {r['name']}"
            else:
                summary_text += f"\n  ({get_text('none', admin_lang)})"
            
            summary_text += f"\n\n⚠️ {get_text('no_response_not_on_duty', admin_lang)} ({len(no_response)}):"
            if no_response:
                for r in no_response:
                    summary_text += f"\n  👤 {r['name']}"
            else:
                summary_text += f"\n  ({get_text('none', admin_lang)})"
            
            await self.application.bot.send_message(
                chat_id=admin_id,
                text=summary_text
            )
        except Exception as e:
            print(f"Error sending duty check summary: {e}")
    
    async def send_duty_check_notifications(self, duty_check_id: int, employees: list, today: str, current_time: str, admin_id: int):
        """Send duty check notifications to employees in background"""
        import asyncio
        
        sent_count = 0
        for emp_telegram_id, emp_name in employees:
            try:
                emp_lang = get_user_language(emp_telegram_id, self.db)
                emp_keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton(f"✅ {get_text('yes_on_duty', emp_lang)}", callback_data=f"duty_yes_{duty_check_id}")],
                    [InlineKeyboardButton(f"❌ {get_text('no_not_on_duty', emp_lang)}", callback_data=f"duty_no_{duty_check_id}")]
                ])
                
                await self.application.bot.send_message(
                    chat_id=emp_telegram_id,
                    text=f"""🔔 {get_text('daily_shift_check', emp_lang).upper()}

━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 {get_text('are_you_on_duty_today', emp_lang)}
━━━━━━━━━━━━━━━━━━━━━━━━━━━

📆 {get_text('date', emp_lang)}: {today}
🕐 {get_text('date_time_of_query', emp_lang)}: {current_time}

⚠️ {get_text('please_respond_within_5min', emp_lang)}""",
                    reply_markup=emp_keyboard
                )
                sent_count += 1
                print(f"✅ Duty check sent to {emp_name}")
            except Exception as e:
                print(f"❌ Error sending duty check to {emp_name}: {e}")
        
        # Notify admin about completion
        try:
            admin_lang = get_user_language(admin_id, self.db)
            await self.application.bot.send_message(
                chat_id=admin_id,
                text=f"✅ {get_text('query_sent_successfully', admin_lang).replace('{sent}', str(sent_count)).replace('{total}', str(len(employees)))}"
            )
        except:
            pass
        
        # Schedule expiration check after 5 minutes
        asyncio.create_task(self.check_duty_expiration(duty_check_id, admin_id))
    
    async def shift_report_scheduler(self):
        """Background scheduler to send shift report requests to reception employees
        
        Logic:
        - Check cycle: Every 1 minute (60 seconds) - FOR TESTING
        - Smart notification: Only send when actually needed
        - First notification: Immediately after shift ends (within 1 min detection)
        - Follow-up reminders: Every 10 minutes until report is submitted (max 3)
        """
        from database import get_shift_settings
        import asyncio
        from datetime import datetime, timedelta
        
        print("🕐 Shift report scheduler started (1-minute check cycle - TESTING MODE)")
        
        # Track pending reminders: {(shift_number, date): {'first_sent': datetime, 'last_reminder': datetime, 'next_alarm': datetime}}
        pending_reminders = {}
        
        # Perform first check immediately
        first_check = True
        
        while True:
            try:
                if not first_check:
                    await asyncio.sleep(60)  # Check every 1 minute (60 seconds) - TESTING
                else:
                    print("🚀 Performing initial shift check...")
                    first_check = False
                
                settings = get_shift_settings(self.db)
                if not settings:
                    continue
                
                current_time = datetime.now()
                current_time_str = current_time.strftime('%H:%M')
                current_date = current_time.strftime('%Y-%m-%d')
                
                shift_count = settings['shift_count']
                
                # Debug: Print current settings being used
                print(f"⏱️ Scheduler check at {current_time_str} - Shifts: {shift_count}")
                
                # Calculate all upcoming shift end times and check for pending reports
                upcoming_alarms = []
                
                for i in range(1, shift_count + 1):
                    shift_end = settings.get(f'shift_{i}_end')
                    if not shift_end:
                        continue
                    
                    try:
                        end_hour, end_min = map(int, shift_end.split(':'))
                        shift_end_datetime = current_time.replace(hour=end_hour, minute=end_min, second=0, microsecond=0)
                        
                        # Handle overnight shifts
                        if current_time.hour < 6 and end_hour > 18:
                            shift_end_datetime = shift_end_datetime - timedelta(days=1)
                        elif current_time.hour > 18 and end_hour < 6:
                            shift_end_datetime = shift_end_datetime + timedelta(days=1)
                        
                        # If shift end time is in the past but within 2 hours, it's pending
                        time_diff = (current_time - shift_end_datetime).total_seconds()
                        
                        if 0 <= time_diff <= 7200:  # Within 2 hours after shift end
                            upcoming_alarms.append({
                                'shift_number': i,
                                'shift_end': shift_end,
                                'end_datetime': shift_end_datetime,
                                'minutes_since_end': time_diff / 60
                            })
                            print(f"📌 Shift {i} ended {time_diff/60:.1f} minutes ago - checking pending reports")
                        
                    except Exception as e:
                        print(f"⚠️ Error parsing shift {i} end time: {e}")
                        continue
                
                # Process each pending shift
                for alarm in upcoming_alarms:
                    i = alarm['shift_number']
                    shift_end = alarm['shift_end']
                    minutes_since_end = alarm['minutes_since_end']
                    reminder_key = (i, current_date)
                    
                    # Get list of reception employees who haven't submitted
                    reception_employees = self.db.get_reception_employees()
                    if not reception_employees:
                        continue
                    
                    # Check if this is first notification or a follow-up reminder
                    if reminder_key not in pending_reminders:
                        # First notification - send immediately when detected
                        print(f"🔔 Shift {i} ended! Sending first notification at {current_time_str} (1/3)")
                        pending_reminders[reminder_key] = {
                            'first_sent': current_time,
                            'last_reminder': current_time,
                            'reminder_count': 1,
                            'next_alarm': current_time + timedelta(minutes=10)
                        }
                        await self.send_shift_report_reminder(i, shift_end, minutes_since_end, is_first=True)
                    else:
                        # Check if max reminders (3) already sent
                        reminder_count = pending_reminders[reminder_key].get('reminder_count', 1)
                        if reminder_count >= 3:
                            continue
                        
                        # Check if it's time for next reminder (based on calculated next_alarm time)
                        next_alarm = pending_reminders[reminder_key].get('next_alarm')
                        if next_alarm and current_time >= next_alarm:
                            reminder_count += 1
                            print(f"⏰ Shift {i} reminder at {current_time_str} ({reminder_count}/3)")
                            pending_reminders[reminder_key]['last_reminder'] = current_time
                            pending_reminders[reminder_key]['reminder_count'] = reminder_count
                            pending_reminders[reminder_key]['next_alarm'] = current_time + timedelta(minutes=10)
                            await self.send_shift_report_reminder(i, shift_end, minutes_since_end, is_first=False)
                
                # Clean up old entries (entries older than 1 day)
                keys_to_remove = []
                for key in pending_reminders:
                    shift_num, date_str = key
                    if date_str != current_date:
                        keys_to_remove.append(key)
                for key in keys_to_remove:
                    del pending_reminders[key]
                    print(f"🧹 Cleaned up old reminder tracking for shift {key[0]}")
                
                # Log next check time (1 minute for testing)
                next_check = current_time + timedelta(minutes=1)
                print(f"💤 Next scheduler check at {next_check.strftime('%H:%M:%S')} (1-min cycle)")
                        
            except Exception as e:
                print(f"❌ Shift scheduler error: {e}")
                await asyncio.sleep(60)  # 1 minute - TESTING
    
    async def send_shift_report_reminder(self, shift_number: int, shift_end_time: str, minutes_overdue: float, is_first: bool = True):
        """Send shift report reminder to reception employees who haven't submitted
        
        Args:
            shift_number: The shift number
            shift_end_time: The shift end time string (HH:MM format)
            minutes_overdue: Minutes since shift ended
            is_first: True if first notification, False if follow-up reminder
        """
        from languages import get_text
        from datetime import datetime
        
        try:
            # Map shift number to shift type (Shift 1=A, 2=B, 3=C)
            shift_type_map = {1: 'A', 2: 'B', 3: 'C', 4: 'D'}
            target_shift_type = shift_type_map.get(shift_number)
            
            if not target_shift_type:
                print(f"⚠️ Could not determine shift type for shift {shift_number}")
                # Fallback to all reception employees
                reception_employees = self.db.get_reception_employees()
                restaurant_employees = []
            else:
                # Get only employees who were ACTUALLY WORKING during this shift that just ended
                # This ensures only active workers on this shift get the notification
                shift_employees = self.db.execute_query("""
                    SELECT s.telegram_user_id, s.employee_name, s.department, s.shift_type
                    FROM tbl_employee_shifts s
                    WHERE s.department = 'Reception'
                      AND s.shift_type = %s
                      AND s.is_active = 1
                """, (target_shift_type,))
                
                # Get RESTAURANT employees for notification only (no report submission)
                restaurant_shift_employees = self.db.execute_query("""
                    SELECT s.telegram_user_id, s.employee_name, s.department, s.shift_type
                    FROM tbl_employee_shifts s
                    WHERE s.department = 'Restaurant'
                      AND s.shift_type = %s
                      AND s.is_active = 1
                """, (target_shift_type,))
                
                if shift_employees:
                    # Extract only telegram_user_id and employee_name for compatibility
                    reception_employees = [(row[0], row[1]) for row in shift_employees]
                    print(f"✅ Found {len(reception_employees)} Reception employees on Shift {target_shift_type} (#{shift_number})")
                    for emp in shift_employees:
                        print(f"   - {emp[1]} (ID: {emp[0]}, Shift: {emp[3]})")
                else:
                    print(f"⚠️ No Reception employees assigned to Shift {target_shift_type} (#{shift_number})")
                    # Fallback: Use all reception employees
                    reception_employees = self.db.get_reception_employees()
                    print(f"📢 Fallback: Sending to ALL {len(reception_employees)} Reception employees")
                
                if restaurant_shift_employees:
                    restaurant_employees = [(row[0], row[1]) for row in restaurant_shift_employees]
                    print(f"✅ Found {len(restaurant_employees)} Restaurant employees on Shift {target_shift_type} (#{shift_number})")
                    for emp in restaurant_shift_employees:
                        print(f"   - {emp[1]} (ID: {emp[0]}, Shift: {emp[3]})")
                else:
                    restaurant_employees = []
                    print(f"ℹ️ No Restaurant employees on Shift {target_shift_type} (#{shift_number})")
            
            current_date = datetime.now().strftime('%Y-%m-%d')
            
            # Send to RECEPTION employees - with report submission task
            for telegram_user_id, name in reception_employees:
                try:
                    # Get employee_id for this telegram user
                    employee = self.db.get_employee_info_by_telegram_id(telegram_user_id)
                    if not employee:
                        continue
                    
                    # Check if this employee already submitted a report using telegram_user_id
                    if self.db.has_shift_report_submitted(telegram_user_id, shift_number, current_date):
                        print(f"✓ {name} (Reception - Shift {target_shift_type if 'target_shift_type' in locals() else '?'}) already submitted report for Shift {shift_number}")
                        continue
                    
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    # Create task for shift report (only on first notification)
                    if is_first:
                        # Check if task already created
                        if not self.db.has_shift_report_task_created(telegram_user_id, shift_number, current_date):
                            # Create shift report task
                            task_description = f"📋 {get_text('shift_change_report', lang)} - Shift {shift_number}\n\n{get_text('shift_change_report_desc', lang)}"
                            task_data = {
                                'department_name': 'Reception',
                                'employee_id': telegram_user_id,
                                'employee_name': name,
                                'description': task_description,
                                'priority': 'Urgent',
                                'due_date': current_date,
                                'requires_materials': False,
                                'proof_required': True,
                                'created_by': 0  # System created
                            }
                            task_id = self.db.create_task(task_data)
                            if task_id:
                                self.db.mark_task_notification_sent(task_id)
                                shift_label = f"Shift {target_shift_type}" if 'target_shift_type' in locals() else f"Shift #{shift_number}"
                                print(f"📋 Shift report task #{task_id} created for {name} (Reception - {shift_label})")
                    
                    # Build notification text for RECEPTION
                    if is_first:
                        text = f"📋 **{get_text('shift_report_required', lang)}**\n\n"
                    else:
                        text = f"⚠️ **{get_text('shift_report_reminder', lang)}**\n\n"
                        text += f"❗ {get_text('shift_report_not_submitted', lang)}\n"
                        text += f"⏱️ {get_text('minutes_overdue', lang)}: {int(minutes_overdue)}\n\n"
                    
                    text += f"🕐 {get_text('shift_number', lang)}: {shift_number}\n"
                    text += f"⏰ {get_text('shift_ended', lang)}: {shift_end_time}\n\n"
                    text += f"📝 {get_text('please_submit_comprehensive_report', lang)}:\n"
                    text += f"• 📊 {get_text('reservations_arrivals', lang)}\n"
                    text += f"• 💰 {get_text('cash_report', lang)}\n"
                    text += f"• 🏪 {get_text('store_stock', lang)}\n"
                    text += f"• 🍽️ {get_text('restaurant_summary', lang)}\n"
                    text += f"• 🔑 {get_text('key_tool_logs', lang)}\n\n"
                    text += f"👉 {get_text('click_report_task_to_submit', lang)}"
                    
                    # Get the task ID for this shift report
                    task_id = self.db.get_shift_report_task_id(telegram_user_id, shift_number, current_date)
                    
                    keyboard = [
                        [InlineKeyboardButton(f"📝 {get_text('report', lang)}", callback_data=f"shift_report_now_{shift_number}_{task_id if task_id else 0}")],
                        [InlineKeyboardButton(f"⏰ {get_text('later', lang)}", callback_data="shift_report_later")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await self.application.bot.send_message(
                        chat_id=telegram_user_id,
                        text=text,
                        reply_markup=reply_markup,
                        parse_mode='Markdown'
                    )
                    reminder_type = "First request" if is_first else "Reminder"
                    print(f"✅ Reception report {reminder_type} sent to {name} ({telegram_user_id})")
                    
                except Exception as e:
                    print(f"❌ Failed to send to Reception {name}: {e}")
            
            # Send to RESTAURANT employees - notification only (no report submission required)
            for telegram_user_id, name in restaurant_employees:
                try:
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    # Build notification text for RESTAURANT (informational only)
                    text = f"🔔 **{get_text('shift_change_notification', lang)}**\n\n"
                    text += f"🕐 {get_text('shift_number', lang)}: {shift_number}\n"
                    text += f"⏰ {get_text('shift_ended', lang)}: {shift_end_time}\n\n"
                    text += f"ℹ️ {get_text('reception_will_submit_report', lang)}\n"
                    text += f"📋 {get_text('comprehensive_report_includes', lang)}:\n"
                    text += f"• 🍽️ {get_text('restaurant_operations', lang)}\n"
                    text += f"• 💰 {get_text('restaurant_revenue', lang)}\n"
                    text += f"• 📊 {get_text('service_summary', lang)}\n\n"
                    text += f"✅ {get_text('no_action_required', lang)}"
                    
                    keyboard = [
                        [InlineKeyboardButton(f"✅ {get_text('acknowledged', lang)}", callback_data="shift_notif_ack")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await self.application.bot.send_message(
                        chat_id=telegram_user_id,
                        text=text,
                        reply_markup=reply_markup,
                        parse_mode='Markdown'
                    )
                    print(f"✅ Restaurant shift notification sent to {name} ({telegram_user_id})")
                    
                except Exception as e:
                    print(f"❌ Failed to send to Restaurant {name}: {e}")
                    
        except Exception as e:
            print(f"❌ Error sending shift report reminders: {e}")
    
    async def event_alarm_scheduler(self):
        """Background scheduler for event alarms
        
        Alarm Rules:
        - Check cycle: Every 30 minutes (1800 seconds) - efficient for event monitoring
        - First check: Immediately on start
        - T-2 days: Send to all relevant departments, repeat every 6 hours until acknowledged
        - T-1 day: Stronger alarm, repeat every 3 hours until confirmed
        - Event Day: Critical mode - 07:00 or later, every 1 hour until READY confirmed
        """
        from database import (get_events_for_alarm, get_todays_events, get_event_history, 
                              get_unconfirmed_event_history, create_event_history, get_event_by_id,
                              should_send_alarm, update_alarm_sent_time)
        import asyncio
        from datetime import datetime, timedelta
        
        print("🎉 Event alarm scheduler started (30-minute check cycle)")
        
        # Perform first check immediately
        first_check = True
        
        while True:
            try:
                if not first_check:
                    await asyncio.sleep(1800)  # Check every 30 minutes (1800 seconds)
                else:
                    print("🚀 Performing initial event check...")
                    first_check = False
                
                current_time = datetime.now()
                current_hour = current_time.hour
                current_time_str = current_time.strftime('%H:%M')
                
                print(f"📅 Event scheduler check at {current_time_str}")
                
                # ===== T-2 Days Alarm (6 hour interval = 21600 seconds) =====
                t2_events = get_events_for_alarm(self.db, 2)
                t2_alarm_count = 0
                # Track users already notified for this event to avoid duplicates
                t2_notified_users = {}  # {event_id: set(user_ids)}
                
                for event in t2_events:
                    event_id = event[0]
                    event_name = event[1]
                    
                    if event_id not in t2_notified_users:
                        t2_notified_users[event_id] = set()
                    
                    # Get unconfirmed departments
                    unconfirmed = get_unconfirmed_event_history(self.db, event_id, 'T-2')
                    
                    for dept_id, dept in unconfirmed:
                        # Check if enough time has passed since last alarm (6 hours)
                        if should_send_alarm(self.db, event_id, 'T-2', dept, 21600):
                            sent_count = await self.send_event_alarm(event_id, dept, 'T-2', t2_notified_users[event_id])
                            if sent_count > 0:
                                update_alarm_sent_time(self.db, event_id, 'T-2', dept)
                                t2_alarm_count += sent_count
                                print(f"📢 T-2 alarm sent: Event '{event_name}' to {dept} ({sent_count} users)")
                
                if t2_alarm_count > 0:
                    print(f"✅ Sent {t2_alarm_count} T-2 alarm(s)")
                
                # ===== T-1 Day Alarm (3 hour interval = 10800 seconds) =====
                t1_events = get_events_for_alarm(self.db, 1)
                t1_alarm_count = 0
                # Track users already notified for this event to avoid duplicates
                t1_notified_users = {}  # {event_id: set(user_ids)}
                
                for event in t1_events:
                    event_id = event[0]
                    event_name = event[1]
                    
                    if event_id not in t1_notified_users:
                        t1_notified_users[event_id] = set()
                    
                    # Create T-1 history records if not exist
                    existing = get_event_history(self.db, event_id)
                    t1_depts = [h[2] for h in existing if h[3] == 'T-1']
                    departments = ['Reception', 'Kitchen', 'Housekeeping', 'Warehouse', 'Management']
                    
                    for dept in departments:
                        if dept not in t1_depts:
                            create_event_history(self.db, event_id, dept, 'T-1')
                    
                    # Get unconfirmed departments
                    unconfirmed = get_unconfirmed_event_history(self.db, event_id, 'T-1')
                    
                    for dept_id, dept in unconfirmed:
                        # Check if enough time has passed since last alarm (3 hours)
                        if should_send_alarm(self.db, event_id, 'T-1', dept, 10800):
                            sent_count = await self.send_event_alarm(event_id, dept, 'T-1', t1_notified_users[event_id])
                            if sent_count > 0:
                                update_alarm_sent_time(self.db, event_id, 'T-1', dept)
                                t1_alarm_count += sent_count
                                print(f"🔔 T-1 alarm sent: Event '{event_name}' to {dept} ({sent_count} users)")
                
                if t1_alarm_count > 0:
                    print(f"✅ Sent {t1_alarm_count} T-1 alarm(s)")
                
                # ===== Event Day - Critical Mode (1 hour interval = 3600 seconds) =====
                todays_events = get_todays_events(self.db)
                today_alarm_count = 0
                # Track users already notified for this event to avoid duplicates
                today_notified_users = {}  # {event_id: set(user_ids)}
                
                # Only trigger at specific hours: 07:00 or later
                if current_hour >= 7:
                    # Track events that need escalation (group by event)
                    events_to_escalate = {}  # event_id -> list of unconfirmed departments
                    
                    for event in todays_events:
                        event_id = event[0]
                        event_name = event[1]
                        
                        if event_id not in today_notified_users:
                            today_notified_users[event_id] = set()
                        
                        # Create event_day history records if not exist
                        existing = get_event_history(self.db, event_id)
                        day_depts = [h[2] for h in existing if h[3] == 'event_day']
                        departments = ['Reception', 'Kitchen', 'Housekeeping', 'Warehouse', 'Management']
                        
                        for dept in departments:
                            if dept not in day_depts:
                                create_event_history(self.db, event_id, dept, 'event_day')
                        
                        # Get unconfirmed departments
                        unconfirmed = get_unconfirmed_event_history(self.db, event_id, 'event_day')
                        unconfirmed_depts = []
                        
                        for dept_id, dept in unconfirmed:
                            # Check if enough time has passed since last alarm (1 hour)
                            if should_send_alarm(self.db, event_id, 'event_day', dept, 3600):
                                sent_count = await self.send_event_alarm(event_id, dept, 'event_day', today_notified_users[event_id])
                                if sent_count > 0:
                                    update_alarm_sent_time(self.db, event_id, 'event_day', dept)
                                    today_alarm_count += sent_count
                                    print(f"🚨 Critical alarm sent: Event '{event_name}' to {dept} ({sent_count} users)")
                                
                                # Track for escalation if after 10:00
                                if current_hour >= 10:
                                    unconfirmed_depts.append(dept)
                        
                        # Group unconfirmed departments for this event
                        if unconfirmed_depts:
                            events_to_escalate[event_id] = unconfirmed_depts
                    
                    # Send grouped escalation (one message per event with all unconfirmed departments)
                    for event_id, unconfirmed_depts in events_to_escalate.items():
                        await self.escalate_event_to_admin_grouped(event_id, unconfirmed_depts)
                
                if today_alarm_count > 0:
                    print(f"✅ Sent {today_alarm_count} event day alarm(s)")
                
                # Summary log
                total_alarms = t2_alarm_count + t1_alarm_count + today_alarm_count
                if total_alarms == 0:
                    print(f"✓ No alarms needed at this time")
                
                # Log next check time
                next_check = current_time + timedelta(minutes=30)
                print(f"💤 Next event check at {next_check.strftime('%H:%M')}")
                    
            except Exception as e:
                print(f"❌ Event alarm scheduler error: {e}")
                import traceback
                traceback.print_exc()
                await asyncio.sleep(1800)
    
    async def overdue_task_reminder_scheduler(self):
        """Background scheduler to send daily reminders for overdue tasks.
        
        Logic:
        - Runs every 1 hour (3600 seconds)
        - Sends reminders only between 08:00-20:00
        - Each overdue task is notified only once per day (tracked by overdue_notified_date)
        - Groups overdue tasks by employee and sends one consolidated message per employee
        """
        import asyncio
        from datetime import datetime
        
        print("⏰ Overdue task reminder scheduler started (1-hour check cycle)")
        
        first_check = True
        
        while True:
            try:
                if not first_check:
                    await asyncio.sleep(3600)  # Check every 1 hour
                else:
                    print("🚀 Performing initial overdue task check...")
                    await asyncio.sleep(60)  # Wait 1 minute on first check for bot to be ready
                    first_check = False
                
                current_time = datetime.now()
                current_hour = current_time.hour
                
                # Only send reminders between 08:00 and 20:00
                if current_hour < 8 or current_hour >= 20:
                    print(f"⏰ Overdue check skipped - outside notification hours ({current_hour}:00)")
                    continue
                
                print(f"⏰ Overdue task check at {current_time.strftime('%H:%M')}")
                
                # Get overdue tasks that haven't been notified today
                overdue_tasks = self.db.get_overdue_tasks_for_notification()
                
                if not overdue_tasks:
                    print("✓ No overdue tasks needing notification")
                    continue
                
                # Group by telegram_user_id
                from collections import defaultdict
                emp_tasks = defaultdict(list)
                for task in overdue_tasks:
                    emp_tasks[task['telegram_user_id']].append(task)
                
                notified_count = 0
                notified_task_ids = []
                
                for tg_user_id, tasks in emp_tasks.items():
                    try:
                        lang = get_user_language(tg_user_id, self.db)
                        emp_name = tasks[0]['emp_name']
                        
                        # Build consolidated overdue notification message
                        text = f"⚠️ <b>{get_text('overdue_task_reminder', lang)}</b>\n"
                        text += "━━━━━━━━━━━━━━━━━━━━━━\n"
                        text += f"👤 {emp_name}\n"
                        text += f"📋 {get_text('overdue_tasks_count', lang)}: <b>{len(tasks)}</b>\n\n"
                        
                        for idx, task in enumerate(tasks, 1):
                            priority_icon = {"Urgent": "🔴", "Normal": "🟡", "Low": "🟢"}.get(task['priority'], "⚪")
                            text += f"{idx}. {priority_icon} <b>#{task['task_id']}</b>\n"
                            text += f"   📝 {task['description'][:50]}\n"
                            text += f"   📅 {get_text('deadline', lang)}: {task['due_date']}\n"
                            text += f"   🏢 {task['department']}\n\n"
                        
                        text += f"❗ {get_text('overdue_task_action', lang)}\n"
                        
                        # Send notification
                        await self.application.bot.send_message(
                            chat_id=tg_user_id,
                            text=text,
                            parse_mode="HTML"
                        )
                        
                        notified_count += 1
                        notified_task_ids.extend([t['task_id'] for t in tasks])
                        print(f"📨 Overdue reminder sent to {emp_name} (ID: {tg_user_id}) - {len(tasks)} tasks")
                        
                    except Exception as e:
                        print(f"⚠️ Failed to send overdue reminder to {tg_user_id}: {e}")
                        continue
                
                # Mark tasks as notified today
                if notified_task_ids:
                    self.db.mark_overdue_notified(notified_task_ids)
                
                print(f"✅ Overdue reminders sent to {notified_count} employees ({len(notified_task_ids)} tasks)")
                
            except Exception as e:
                print(f"❌ Overdue task reminder scheduler error: {e}")
                import traceback
                traceback.print_exc()
                await asyncio.sleep(3600)
    
    async def send_event_alarm(self, event_id: int, department: str, alarm_type: str, notified_users: set = None):
        """Send event alarm to department employees
        
        Args:
            event_id: Event ID
            department: Department name
            alarm_type: Type of alarm ('T-2', 'T-1', 'event_day')
            notified_users: Set of user IDs already notified for this event (to prevent duplicates)
            
        Returns:
            int: Number of users actually notified
        """
        from database import get_event_by_id, has_user_been_notified, record_user_notification
        
        if notified_users is None:
            notified_users = set()
        
        try:
            event = get_event_by_id(self.db, event_id)
            if not event:
                return 0
            
            # Skip if event is cancelled or completed
            event_status = event.get('status', '').lower()
            if event_status in ('cancelled', 'completed'):
                print(f"⏭️ Skipping alarm for {event_status} event: {event.get('event_name')}")
                return 0
            
            # Get employees in department
            employees = self.db.get_employees_by_department(department)
            if not employees:
                return 0
            
            sent_count = 0
            
            for emp in employees:
                try:
                    telegram_user_id = emp[1] if len(emp) > 1 else None
                    if not telegram_user_id:
                        continue
                    
                    # Check if employee is currently on shift (only for Reception and Restaurant)
                    if department in ['Reception', 'Restaurant', 'Kitchen']:
                        shift_status = is_employee_on_shift(self.db, telegram_user_id)
                        if not shift_status.get('on_shift'):
                            print(f"⏭️ Skipping {emp[2] if len(emp) > 2 else 'employee'} - OFF_SHIFT")
                            continue
                        print(f"✅ {emp[2] if len(emp) > 2 else 'employee'} - ON_SHIFT ({shift_status.get('shift_type')})")
                    
                    # Skip if user already notified in current cycle
                    if telegram_user_id in notified_users:
                        continue
                    
                    # Skip if user already notified in database (persistent check)
                    if has_user_been_notified(self.db, event_id, telegram_user_id, alarm_type):
                        notified_users.add(telegram_user_id)  # Add to cycle set to avoid duplicate checks
                        continue
                    
                    lang = get_user_language(telegram_user_id, self.db)
                    
                    # Build alarm message
                    alarm_text = get_text('event_alarm_message', lang).format(
                        event_name=event['event_name'],
                        hall=event['hall'],
                        event_date=event['event_date'],
                        event_time=event['event_time'],
                        seats=event['seats'],
                        meals_count=event['meals_count'],
                        menu=event.get('menu') or 'N/A'
                    )
                    
                    if alarm_type == 'T-2':
                        alarm_text += f"\n\n{get_text('event_t2_message', lang)}"
                        button_text = get_text('acknowledge_event', lang)
                        callback = f"event_ack_{event_id}_{department}"
                    elif alarm_type == 'T-1':
                        alarm_text += f"\n\n{get_text('event_t1_message', lang)}"
                        button_text = get_text('confirm_preparation', lang)
                        callback = f"event_confirm_{event_id}_{department}"
                    else:  # event_day
                        alarm_text += f"\n\n{get_text('event_day_message', lang)}"
                        button_text = get_text('confirm_ready', lang)
                        callback = f"event_ready_{event_id}_{department}"
                    
                    keyboard = [[InlineKeyboardButton(button_text, callback_data=callback)]]
                    
                    await self.application.bot.send_message(
                        chat_id=telegram_user_id,
                        text=alarm_text,
                        reply_markup=InlineKeyboardMarkup(keyboard)
                    )
                    
                    # Record notification in database
                    record_user_notification(self.db, event_id, telegram_user_id, alarm_type)
                    
                    # Mark user as notified in current cycle
                    notified_users.add(telegram_user_id)
                    sent_count += 1
                    
                except Exception as e:
                    error_msg = str(e)
                    # Silently skip common errors (blocked users, deleted chats)
                    if "Chat not found" in error_msg or "bot was blocked" in error_msg or "Forbidden" in error_msg:
                        pass  # User blocked bot or chat deleted - skip silently
                    else:
                        print(f"❌ Failed to send event alarm to employee {telegram_user_id}: {e}")
            
            return sent_count
                    
        except Exception as e:
            print(f"❌ Error in send_event_alarm: {e}")
            return 0
    
    async def escalate_event_to_admin(self, event_id: int, department: str):
        """
        Escalate unconfirmed event to admin (backward compatibility).
        Now delegates to escalate_event_to_admin_grouped with single department.
        """
        await self.escalate_event_to_admin_grouped(event_id, [department])
    
    async def escalate_event_to_admin_grouped(self, event_id: int, departments: list):
        """
        Send a single escalation message to admin about multiple unconfirmed departments.
        Uses cache to prevent duplicate escalations within 1 hour.
        
        Args:
            event_id: Event ID
            departments: List of department names that haven't confirmed
        """
        from database import get_event_by_id
        
        try:
            event = get_event_by_id(self.db, event_id)
            if not event:
                return
            
            # Check if this escalation was already sent recently (within 1 hour)
            escalation_key = f"escalation_{event_id}_grouped"
            if not hasattr(self, '_escalation_cache'):
                self._escalation_cache = {}
            
            from datetime import datetime, timedelta
            current_time = datetime.now()
            
            # Check cache for recent escalation
            if escalation_key in self._escalation_cache:
                last_sent = self._escalation_cache[escalation_key]
                if current_time - last_sent < timedelta(hours=1):
                    print(f"⏭️ Skipping duplicate escalation: Event #{event_id} (sent {(current_time - last_sent).seconds // 60} minutes ago)")
                    return
            
            # Get all admins
            admins = self.db.get_all_admins()
            escalation_sent = False
            
            # Format department list
            dept_count = len(departments)
            dept_list = "\n".join([f"   🔴 {dept}" for dept in departments])
            
            for admin in admins:
                try:
                    admin_id = admin[0]
                    lang = get_user_language(admin_id, self.db)
                    
                    # Build message with proper localization and table formatting
                    text = f"🚨 <b>{get_text('escalation_alert', lang)}</b> 🚨\n\n"
                    text += f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"📅 <b>{get_text('event', lang)}:</b> {event['event_name']}\n"
                    text += f"📍 <b>{get_text('hall', lang)}:</b> {event['hall']}\n"
                    text += f"🕐 <b>{get_text('date', lang)}:</b> {event['event_date']} {event['event_time']}\n"
                    text += f"━━━━━━━━━━━━━━━━━━━━━━\n\n"
                    text += f"⚠️ <b>{dept_count} {get_text('departments_not_ready', lang)}:</b>\n"
                    text += f"{dept_list}\n\n"
                    text += f"❗ {get_text('multiple_reminders_sent', lang)}\n"
                    text += f"💼 <b>{get_text('action_required', lang)}</b> {get_text('action_required_contact', lang)}\n"
                    text += f"━━━━━━━━━━━━━━━━━━━━━━\n"
                    text += f"⏰ <b>{get_text('escalated_at', lang)}:</b> {current_time.strftime('%H:%M')}"
                    
                    await self.application.bot.send_message(
                        chat_id=admin_id,
                        text=text,
                        parse_mode='HTML'
                    )
                    escalation_sent = True
                except Exception as e:
                    print(f"❌ Failed to escalate to admin {admin_id}: {e}")
            
            # Update cache to prevent duplicate escalations
            if escalation_sent:
                self._escalation_cache[escalation_key] = current_time
                print(f"📢 Escalation sent to admin: Event #{event_id} '{event['event_name']}' - {dept_count} unconfirmed dept(s)")
                
        except Exception as e:
            print(f"❌ Error in escalate_event_to_admin_grouped: {e}")
            import traceback
            traceback.print_exc()

    async def show_overdue_tasks_page(self, query, telegram_user_id: int, page: int = 0):
        """Show paginated overdue tasks"""
        from database import get_overdue_tasks_for_escalation
        from telegram import InlineKeyboardButton, InlineKeyboardMarkup
        
        try:
            lang = get_user_language(telegram_user_id, self.db)
            
            # Get all overdue tasks (24+ hours)
            all_tasks = get_overdue_tasks_for_escalation(self.db, hours_overdue=24)
            pending_tasks = [t for t in all_tasks if t['status'] in ('pending', 'in_progress')]
            
            if not pending_tasks:
                await query.edit_message_text(
                    f"✅ No pending overdue tasks!",
                    parse_mode="HTML"
                )
                return
            
            # Pagination settings
            tasks_per_page = 10
            total_pages = (len(pending_tasks) + tasks_per_page - 1) // tasks_per_page
            page = max(0, min(page, total_pages - 1))
            
            start_idx = page * tasks_per_page
            end_idx = min(start_idx + tasks_per_page, len(pending_tasks))
            page_tasks = pending_tasks[start_idx:end_idx]
            
            # Build message
            text = f"🔴 <b>{get_text('critical_overdue_24h', lang)}</b>\n"
            text += "━━━━━━━━━━━━━━━━━━━━━━\n"
            text += f"📄 Page {page + 1}/{total_pages} | Total: {len(pending_tasks)} tasks\n\n"
            
            for idx, task in enumerate(page_tasks, start_idx + 1):
                text += f"<b>{idx}.</b> 📝 {task['description'][:45]}\n"
                text += f"   👤 {task['assignee_name']} | 🏢 {task['department']}\n"
                text += f"   ⏰ {get_text('due_date', lang)}: {task['due_date']}\n"
                text += f"   📊 {get_text('status', lang)}: {task['status']}\n\n"
            
            text += "━━━━━━━━━━━━━━━━━━━━━━\n"
            
            # Navigation buttons
            keyboard = []
            nav_row = []
            
            if page > 0:
                nav_row.append(InlineKeyboardButton("⬅️ Prev", callback_data=f"view_overdue_page_{page-1}"))
            
            nav_row.append(InlineKeyboardButton(f"📄 {page+1}/{total_pages}", callback_data="noop"))
            
            if page < total_pages - 1:
                nav_row.append(InlineKeyboardButton("Next ➡️", callback_data=f"view_overdue_page_{page+1}"))
            
            keyboard.append(nav_row)
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(
                text=text,
                parse_mode="HTML",
                reply_markup=reply_markup
            )
            
        except Exception as e:
            print(f"❌ Error showing overdue tasks page: {e}")
            import traceback
            traceback.print_exc()
    
    async def task_escalation_scheduler(self):
        """Background scheduler for task escalation
        
        Escalation Rules:
        - Check cycle: Every 1 hour
        - Level 1 (4 hours overdue): Alert assignee
        - Level 2 (8 hours overdue): Escalate to department manager
        - Level 3 (24 hours overdue): Escalate to admin
        """
        from database import get_overdue_tasks_for_escalation, escalate_overdue_task
        import asyncio
        from datetime import datetime
        
        print("⚠️ Task escalation scheduler started (1-hour check cycle)")
        
        # Wait a bit on first start
        await asyncio.sleep(60)
        
        while True:
            try:
                current_time = datetime.now()
                current_hour = current_time.hour
                
                # Only run during work hours (7am - 10pm)
                if current_hour < 7 or current_hour >= 22:
                    print(f"⏰ Escalation check skipped - outside work hours ({current_hour}:00)")
                    await asyncio.sleep(3600)
                    continue
                
                print(f"🔍 Checking overdue tasks for escalation at {current_time.strftime('%H:%M')}")
                
                # Level 1: 4 hours overdue - Alert assignee (once)
                tasks_4h = get_overdue_tasks_for_escalation(self.db, hours_overdue=4)
                level1_count = 0
                
                # Filter only pending/in-progress tasks
                pending_tasks_4h = [t for t in tasks_4h if t['status'] in ('pending', 'in_progress')]
                
                # Group tasks by assignee
                from collections import defaultdict
                from telegram import InlineKeyboardButton, InlineKeyboardMarkup
                assignee_tasks = defaultdict(list)
                for task in pending_tasks_4h:
                    assignee_tasks[task['assignee_id']].append(task)
                
                for assignee_id, tasks in assignee_tasks.items():
                    try:
                        lang = get_user_language(assignee_id, self.db)
                        assignee_name = tasks[0]['assignee_name']
                        
                        # Send single summary message with top 5 + View All button
                        text = f"⚠️ <b>{get_text('overdue_alert', lang)}</b>\n"
                        text += "━━━━━━━━━━━━━━━━━━━━━━\n"
                        text += f"👤 <b>{assignee_name}</b>\n"
                        text += f"📋 {len(tasks)} {get_text('total_overdue_tasks', lang)}\n"
                        text += f"⏱️ 4+ hours overdue\n\n"
                        
                        # Show top 5 critical tasks only
                        top_tasks = tasks[:5]
                        for idx, task in enumerate(top_tasks, 1):
                            text += f"{idx}. 📝 <b>{task['description'][:40]}</b>\n"
                            text += f"   🏢 {task['department']} | ⏰ {task['due_date']}\n\n"
                        
                        if len(tasks) > 5:
                            text += f"... and {len(tasks) - 5} more tasks\n\n"
                        
                        text += f"❗ {get_text('please_handle_quickly', lang)}"
                        
                        # Add View All button for pagination
                        keyboard = [[
                            InlineKeyboardButton(
                                f"📋 View All ({len(tasks)} tasks)",
                                callback_data=f"view_overdue_page_0"
                            )
                        ]]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        
                        await self.application.bot.send_message(
                            chat_id=assignee_id,
                            text=text,
                            parse_mode="HTML",
                            reply_markup=reply_markup
                        )
                        
                        level1_count += len(tasks)
                        print(f"📨 Level 1 alert sent to {assignee_name} - {len(tasks)} task(s)")
                        
                    except Exception as e:
                        error_msg = str(e)
                        # Skip common errors silently
                        if "Chat not found" not in error_msg and "bot was blocked" not in error_msg and "Forbidden" not in error_msg:
                            print(f"❌ Failed to send Level 1 alert to {assignee_id}: {e}")
                
                # Level 2: 8 hours overdue - Escalate to manager
                tasks_8h = get_overdue_tasks_for_escalation(self.db, hours_overdue=8)
                level2_count = 0
                
                # Group tasks by manager
                manager_tasks = defaultdict(list)
                for task in tasks_8h:
                    try:
                        # Get department manager
                        managers = self.db.execute_query("""
                            SELECT telegram_user_id, name FROM tbl_employeer 
                            WHERE department = %s AND work_role LIKE '%Mana%'
                            LIMIT 1
                        """, (task['department'],))
                        
                        if managers and len(managers) > 0:
                            manager_id = managers[0][0]
                            manager_name = managers[0][1]
                            manager_tasks[manager_id].append({
                                **task,
                                'manager_name': manager_name
                            })
                    except Exception as e:
                        print(f"❌ Failed to get manager for task {task['id']}: {e}")
                
                for manager_id, tasks in manager_tasks.items():
                    try:
                        lang = get_user_language(manager_id, self.db)
                        manager_name = tasks[0]['manager_name']
                        
                        # Build consolidated escalation message
                        text = f"🚨 <b>{get_text('overdue_escalation_8h', lang)}</b>\n"
                        text += "━━━━━━━━━━━━━━━━━━━━━━\n"
                        text += f"👔 {manager_name}\n"
                        text += f"⚠️ {len(tasks)} {get_text('overdue_tasks_count', lang).lower()}\n\n"
                        
                        for idx, task in enumerate(tasks, 1):
                            text += f"{idx}. 📝 <b>{task['description'][:50]}</b>\n"
                            text += f"   👤 {get_text('assigned_to', lang)}: {task['assignee_name']}\n"
                            text += f"   🏢 {get_text('department', lang)}: {task['department']}\n"
                            text += f"   ⏰ {get_text('due_date', lang)}: {task['due_date']}\n"
                            text += f"   📊 {get_text('status', lang)}: {task['status']}\n\n"
                            
                            # Escalate each task
                            escalate_overdue_task(self.db, task['id'], task['table'], manager_id)
                        
                        text += f"⚠️ {get_text('action_required', lang)}"
                        
                        await self.application.bot.send_message(
                            chat_id=manager_id,
                            text=text,
                            parse_mode="HTML"
                        )
                        level2_count += len(tasks)
                        print(f"🔼 Level 2 escalation to {manager_name} - {len(tasks)} task(s)")
                        
                    except Exception as e:
                        print(f"❌ Failed Level 2 escalation to manager {manager_id}: {e}")
                
                # Level 3: 24 hours overdue - Escalate to admin
                tasks_24h = get_overdue_tasks_for_escalation(self.db, hours_overdue=24)
                level3_count = 0
                
                if tasks_24h:
                    # Filter only pending tasks
                    pending_tasks = [t for t in tasks_24h if t['status'] in ('pending', 'in_progress')]
                    
                    if not pending_tasks:
                        print(f"✓ All overdue tasks are completed or not actionable")
                    else:
                        # Get all admins
                        admins = self.db.get_all_admins()
                        
                        for admin in admins:
                            try:
                                admin_id = admin[0]
                                lang = get_user_language(admin_id, self.db)
                                
                                # Send SINGLE summary message with button to view details
                                text = f"🔴 <b>{get_text('critical_overdue_24h', lang)}</b>\n"
                                text += "━━━━━━━━━━━━━━━━━━━━━━\n"
                                text += f"⚠️ <b>{len(pending_tasks)}</b> {get_text('total_overdue_tasks', lang)}\n\n"
                                
                                # Show top 5 most critical
                                text += f"🔥 <b>Top 5 Most Critical:</b>\n"
                                for idx, task in enumerate(pending_tasks[:5], 1):
                                    text += f"{idx}. � {task['description'][:35]}...\n"
                                    text += f"   👤 {task['assignee_name']} | 🏢 {task['department']}\n\n"
                                
                                text += "━━━━━━━━━━━━━━━━━━━━━━\n"
                                text += f"� Use the button below to view all tasks with pagination\n"
                                text += f"❗ {get_text('urgent_action_required', lang)}"
                                
                                # Add inline keyboard button for pagination
                                from telegram import InlineKeyboardButton, InlineKeyboardMarkup
                                keyboard = [[
                                    InlineKeyboardButton(
                                        f"📋 View All ({len(pending_tasks)} tasks)",
                                        callback_data=f"view_overdue_page_0"
                                    )
                                ]]
                                reply_markup = InlineKeyboardMarkup(keyboard)
                                
                                await self.application.bot.send_message(
                                    chat_id=admin_id,
                                    text=text,
                                    parse_mode="HTML",
                                    reply_markup=reply_markup
                                )
                                
                                print(f"🔴 Level 3 summary sent to admin {admin_id} ({len(pending_tasks)} pending tasks)")
                                
                            except Exception as e:
                                error_msg = str(e)
                                if "Message is too long" not in error_msg:
                                    print(f"❌ Failed Level 3 escalation to admin {admin_id}: {e}")
                        
                        level3_count = len(pending_tasks)
                    print(f"🔴 Level 3 critical escalation for {level3_count} task(s)")
                
                # Summary
                total = level1_count + level2_count + level3_count
                if total > 0:
                    print(f"✅ Escalation summary: L1={level1_count}, L2={level2_count}, L3={level3_count}")
                else:
                    print(f"✓ No tasks need escalation at this time")
                
                # Wait 1 hour before next check
                await asyncio.sleep(3600)
                
            except Exception as e:
                print(f"❌ Task escalation scheduler error: {e}")
                import traceback
                traceback.print_exc()
                await asyncio.sleep(3600)
    
    def run(self):
        """Run bot"""
        print("🤖 Starting Telegram bot...")
        print(f"🏨 Bot: @MySVEN0125_Hotel_ManagerBot")
        print("✅ Timeout setting: 60 seconds")
        print("📡 Waiting for messages...\n")
        
        max_retries = 5
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                # Initialize the application before first run
                import asyncio
                from telegram import BotCommand
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                loop.run_until_complete(self.application.initialize())
                
                # Remove all bot commands to hide Menu button completely
                loop.run_until_complete(self.application.bot.set_my_commands([]))
                print("✅ Bot commands cleared (Menu button removed)")
                
                # Initialize notification manager after application is ready
                from notification_manager import get_notification_manager
                from email_ai_analyzer import _secrets_cache
                
                email_user = _secrets_cache.get('sender_email', '')
                email_password = _secrets_cache.get('app_password', '')
                
                self.notification_manager = get_notification_manager(self.db, self.application, email_user, email_password)
                
                # Start shift report scheduler as background task
                loop.create_task(self.shift_report_scheduler())
                
                # Start event alarm scheduler as background task
                loop.create_task(self.event_alarm_scheduler())
                
                # Start overdue task reminder scheduler as background task
                loop.create_task(self.overdue_task_reminder_scheduler())
                
                # Start task escalation scheduler as background task
                loop.create_task(self.task_escalation_scheduler())
                
                self.application.run_polling(
                    allowed_updates=Update.ALL_TYPES,
                    drop_pending_updates=True,
                    poll_interval=1.0,
                    timeout=60
                )
                break  # Exit loop on normal termination
            except KeyboardInterrupt:
                print("\n⚠️ User interrupted the program...")
                break
            except Exception as e:
                retry_count += 1
                print(f"\n⚠️ Network error (attempt {retry_count}/{max_retries}): {e}")
                if retry_count < max_retries:
                    import time
                    print(f"🔄 Reconnecting in 5 seconds...")
                    time.sleep(5)
                    # Create new Application object and properly initialize
                    self.application = Application.builder().token(self.token).build()
                    self._setup_handlers()
                    # Initialize the application before polling
                    import asyncio
                    asyncio.get_event_loop().run_until_complete(self.application.initialize())
                else:
                    print(f"\n❌ Max retries reached. Bot stopped.")





